;;; Hey, emacs(1), this is -*- Mode: TDL; Coding: utf-8; -*- got it?
;;;

;;;
;;; This is Norsyg. Norwegian syntax-based grammar. 
;;; Copyright (C) 2012  Petter Haugereid
;;; 
;;; Permission is hereby granted, free of charge, to any person
;;; obtaining a copy of this software and associated documentation
;;; files (the "Software"), to deal in the Software without
;;; restriction, including without limitation the rights to use, copy,
;;; modify, merge, publish, distribute, sublicense, and/or sell copies
;;; of the Software, and to permit persons to whom the Software is
;;; furnished to do so, subject to the following conditions:
;;; 
;;; The above copyright notice and this permission notice shall be
;;; included in all copies or substantial portions of the Software.
;;; 
;;; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
;;; EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
;;; MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
;;; NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
;;; HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
;;; WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
;;; OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
;;; DEALINGS IN THE SOFTWARE.
;;; 
;;; Petter Haugereid
;;; Email: petterha@gmail.com
;;;

;;;
;;; PH 14-aug-2006: Norsyg is a continuation of phdgram.
;;; PH 2005: Phdgram is a grammar for Norwegian developed on the basis of 
;;; NorSource since February 2004.
;;; PH 30-jan-2004: This version of NorSource is based on Matrix0.6
;;;

;;;;;
;;;;;   TENSE/ASPECT/MOOD (TAM) AND PERSON/NUMBER/GENDER (PNG) TYPES
;;;;;

fin-infin := tense.
infin-pres := fin-infin.
pres-pret-perf := tense.
pret-perf := pres-pret-perf.
finite := pres-pret-perf & imp-fin & fin-infin.
present := finite & infin-pres.
pret := finite & pret-perf.
no_tense := tense.
untensed := tense.
imp-infin := no_tense.
imp-fin := tense.
infin := imp-infin & infin-pres.
perf := no_tense & pret-perf.
imp := imp-infin & imp-fin.
prespart := no_tense.
animacy := semsort.
animate := animacy.
non-human := animacy.
human := animate.
animal := animate & non-human.
non-animate := non-human.

number-png := png &
[ PN pn,
  GEN gender,
  ANIM animacy ].

pn := sort.
count := pn.
mass-or-sg := 3p.
mass-or-pl := 3p.
mass := mass-or-sg & mass-or-pl.
sg := count.
pl := count.
1p := count.
2pl-or-3pl := pl.
2p := count.
3p := pn.
1sg := 1p & sg.
2sg := 2p & sg.
3sg := sg & mass-or-sg.
1pl := 1p & pl.
2pl := 2p & 2pl-or-3pl.
3pl := 2pl-or-3pl & mass-or-pl.

num := sort.

gender := sort.
masc-or-neut := gender.

comm := gender.
masc := comm & masc-or-neut.
fem := comm.
neut := masc-or-neut.

;;;;;
;;;;;   VALENCE TYPES
;;;;;

link := predsort.

;;;
;;; Valence types automatically derived with the 'convlex.py' script
;;;

arg1+ := link.
arg1- := link.
arg2+ := link.
arg2- := link.
arg3+ := link.
arg3- := link.
arg4+ := link.
arg4- := link.

;;; Modified/added link type from vpidiom paper

nom+ := link.
nom- := link.
vbl+ := link.
expl+ := link.
comp+ := nom+.
inq+ := nom+.
wh+ := nom+.
inf+ := nom-.
mod+ := nom-.
mass+ := nom+.

restr_rel_rel := mod+ & arg2+.
non-restr_rel_rel := mod+ & arg2+.
time_rel := mod+ & nom+.
poss_rel := norm_rel & mod+ & nom+.

1np := arg1+ & wh+.
1cp := arg1+ & comp+.
1ip := arg1+ & inf+.
2expl := arg2+ & expl+.
2cp := arg2+ & comp+.
2inq := arg2+ & inq+.
2wh := arg2+ & wh+.
2ip := arg2+ & inf+.
rais := 2ip.
2ip1 := 2ip.
2ip3 := 2ip.
2ip4 := 2ip.
2vp := arg2+ & inf+.
2np := arg2+ & nom+.
2idiom := arg2+.
3np := arg3+ & nom+.
4cp := arg4+ & comp+.
4wh := arg4+ & wh+.
4ip := arg4+ & inf+.
4ip1 := arg4+ & inf+.
4ip2 := arg4+ & inf+.
4infbare1 := arg4+ & inf+.
4infbare2 := arg4+ & inf+.
4np := arg4+ & nom+.
4ap := arg4+.
4advp := arg4+.
4idiom := arg4+.

vrb+ := link.
prt+ := link.
prt- := predsort.
refl := idiomform.
2refl := arg2+ & refl.
3refl := arg3+ & refl.
4refl := arg4+ & refl.
adj+ := nom+.
adv+ := mod+.
prp+ := mod+.
postp+ := mod+.
sadv+ := link.
degadv+ := link.
deg-pos := degadv+.
deg-cmp := degadv+.
deg-sup := degadv+.
deg-adv := degadv+.
deg-sadv := degadv+.
deg-nom := degadv+.
deg-num := degadv+.
deg-verb := degadv+.
deg-imp := degadv+.
deg-qnt := degadv+.
meas+ := predsort.
cadv+ := prt- & arg1+ & arg3- & arg4- & prp+.			;
q+ := predsort.
prp- := predsort.
no-link := arg1- & arg2- & arg3- & arg4- & prt- & prp-.

time-loc_prd := predsort.

kveld_prd := link.
_kveld_n_rel := kveld_prd & arg1- & arg2- & arg3- & arg4- & prt- & atom & time-loc_prd.

liter_prd := predsort.
_liter_meas_rel := liter_prd & arg1- & arg2- & arg3- & arg4- & prt- & meas+.

hvis_prd := predsort.
_hvis_x_rel := hvis_prd & cadv+.
mens_prd := predsort.
_mens_x_rel := mens_prd & cadv+.
_når_adv-wh_rel := arg1+ & prt- & når_prp & arg2- & arg3- & arg4- & wh+.
_når_x_rel := når_prd & cadv+.
om_prd := predsort.
om_prp := om_prd & prp+.
om_prt := om_prd & prt+.
_om_x_rel := om_prd & cadv+.
hvorvidt_prd := predsort.
hvorvidt_prp := hvorvidt_prd & prp+.
hvorvidt_prt := hvorvidt_prd & prt+.
_hvorvidt_x_rel := hvorvidt_prd & cadv+.
selv*om_prd := predsort.
_selv*om_x_rel := selv*om_prd & cadv+.
_siden_adv_rel := siden_prp & adv-link.
_siden_p_rel := siden_prp & arg1+ & 2np & arg3- & arg4- & prt-.
_siden_sadv_rel := siden_prd & sadv+.
_siden_x_rel := siden_prd & cadv+.
siden_prd := predsort.
siden_prp := siden_prd & prp+.
som_prd := predsort.
som_prp := som_prd & prp+.
_som_p_rel := som_prp & arg1+ & 2np & arg3- & arg4- & prt-.
_som_x_rel := som_prd & cadv+.
som*om_prd := predsort.
_som*om_x_rel := som*om_prd & cadv+.
da_prd := predsort.
da_prp := da_prd & prp+.
_da_adv_rel := da_prp & adv-link.
_da_sadv_rel := da_prd & sadv+.
_da_x_rel := da_prd & cadv+.
etc_prd := predsort.
etc_prp := etc_prd & prp+.
_etc_adv_rel := etc_prp & adv-link.
dersom_prd := predsort.
_dersom_x_rel := dersom_prd & cadv+.
det*at_prd := predsort.
_det*at_x_rel := det*at_prd & cadv+.
efter_prd := predsort.
efter_prp := efter_prd & prp+.
efter_prt := efter_prd & prt+.
_efter_adv_rel := efter_prp & adv-link.
_efter_p_rel := efter_prp & arg1+ & 2np & arg3- & arg4- & prt-.
_efter-cp_p_rel := efter_prp & arg1+ & 2cp & arg3- & arg4- & prt-.
_efter-ip_p_rel := efter_prp & arg1+ & 2ip & arg3- & arg4- & prt-.

etter_prd := predsort.
etter_prp := etter_prd & prp+.
etter_prt := etter_prd & prt+.
_etter_p_rel := etter_prp & arg1+ & 2np & arg3- & arg4- & prt-.
_etter-cp_p_rel := etter_prp & arg1+ & 2cp & arg3- & arg4- & prt-.
_etter-ip_p_rel := etter_prp & arg1+ & 2ip & arg3- & arg4- & prt-.
_etter_x_rel := etter_prd & cadv+.

for_prd := predsort.
for_prp := for_prd & prp+.
for_prt := for_prd & prt+.

_for_deg_rel := for_prd & degadv+.
_for_p_rel := for_prp & arg1+ & 2np & arg3- & arg4- & prt-.
_for-cp_p_rel := for_prp & arg1+ & 2cp & arg3- & arg4- & prt-.
_for-ip_p_rel := for_prp & arg1+ & 2ip & arg3- & arg4- & prt-.

gjennom_prd := predsort.
gjennom_prp := gjennom_prd & prp+.
gjennom_prt := gjennom_prd & prt+.
_gjennom_p_rel := gjennom_prp & arg1+ & 2np & arg3- & arg4- & prt-.
_gjennom-cp_p_rel := gjennom_prp & arg1+ & 2cp & arg3- & arg4- & prt-.
_gjennom-ip_p_rel := gjennom_prp & arg1+ & 2ip & arg3- & arg4- & prt-.

i*egenskap*av_prd := predsort.
i*egenskap*av_prp := i*egenskap*av_prd & prp+.
_i*egenskap*av_p_rel := i*egenskap*av_prp & arg1+ & 2np & arg3- & arg4- & prt-.
_i*egenskap*av-ip_p_rel := i*egenskap*av_prp & arg1+ & 2ip & arg3- & arg4- & prt-.

i*ferd*med_prd := predsort.
i*ferd*med_prp := i*ferd*med_prd & prp+.
_i*ferd*med-cp_p_rel := i*ferd*med_prp & arg1+ & 2cp & arg3- & arg4- & prt-.
_i*ferd*med-ip_p_rel := i*ferd*med_prp & arg1+ & 2ip & arg3- & arg4- & prt-.

ettersom_prd := predsort.
_ettersom_x_rel := ettersom_prd & cadv+.
fordi_prd := predsort.
_fordi_x_rel := fordi_prd & cadv+.
før_prd := predsort.
før_prp := før_prd & prp+.
_før_adv_rel := før_prp & adv-link.
_før_p_rel := før_prp & arg1+ & 2np & arg3- & arg4- & prt-.
_før_x_rel := før_prd & cadv+.

flest_prd := predsort.
flest_prp := flest_prd & prp+.
_flest_adv_rel := flest_prp & adv-link.

innenlands_prd := predsort.
innenlands_prp := innenlands_prd & prp+.
_innenlands_adv_rel := innenlands_prp & adv-link.

utenlands_prd := predsort.
utenlands_prp := utenlands_prd & prp+.
_utenlands_adv_rel := utenlands_prp & adv-link.

etterpå_prd := predsort.
etterpå_prp := etterpå_prd & prp+.
_etterpå_adv_rel := etterpå_prp & adv-link.

ene_v := vrb+.
_ene_1_rel := ene_v & vbl+ & 1np & arg2- & arg3- & arg4- & prt-.

mandag_prd := predsort.
mandag_prp := mandag_prd & prp+.
_mandag_adv_rel := arg1+ & prt- & mandag_prp & arg2- & arg3- & arg4-.
_mandag_n_rel := mandag_prd & arg1- & arg2- & arg3- & arg4- & prt- & atom & time-loc_prd.

tirsdag_prd := predsort.
tirsdag_prp := tirsdag_prd & prp+.
_tirsdag_adv_rel := arg1+ & prt- & tirsdag_prp & arg2- & arg3- & arg4-.
_tirsdag_n_rel := tirsdag_prd & arg1- & arg2- & arg3- & arg4- & prt- & atom & time-loc_prd.

onsdag_prd := predsort.
onsdag_prp := onsdag_prd & prp+.
_onsdag_adv_rel := arg1+ & prt- & onsdag_prp & arg2- & arg3- & arg4-.
_onsdag_n_rel := onsdag_prd & arg1- & arg2- & arg3- & arg4- & prt- & atom & time-loc_prd.

torsdag_prd := predsort.
torsdag_prp := torsdag_prd & prp+.
_torsdag_adv_rel := arg1+ & prt- & torsdag_prp & arg2- & arg3- & arg4-.
_torsdag_n_rel := torsdag_prd & arg1- & arg2- & arg3- & arg4- & prt- & atom & time-loc_prd.

fredag_prd := predsort.
fredag_prp := fredag_prd & prp+.
_fredag_adv_rel := arg1+ & prt- & fredag_prp & arg2- & arg3- & arg4-.
_fredag_n_rel := fredag_prd & arg1- & arg2- & arg3- & arg4- & prt- & atom & time-loc_prd.

lørdag_prd := predsort.
lørdag_prp := lørdag_prd & prp+.
_lørdag_adv_rel := arg1+ & prt- & lørdag_prp & arg2- & arg3- & arg4-.
_lørdag_n_rel := lørdag_prd & arg1- & arg2- & arg3- & arg4- & prt- & atom & time-loc_prd.

søndag_prd := predsort.
søndag_prp := søndag_prd & prp+.
_søndag_adv_rel := arg1+ & prt- & søndag_prp & arg2- & arg3- & arg4-.
_søndag_n_rel := søndag_prd & arg1- & arg2- & arg3- & arg4- & prt- & atom & time-loc_prd.

heldigvis_prd := predsort.
heldigvis_prp := heldigvis_prd & prp+.
_heldigvis_sadv_rel := heldigvis_prd & sadv+.

kanskje_prd := predsort.
kanskje_prp := kanskje_prd & prp+.
kanskje_prt := kanskje_prd & prt+.
_kanskje_sadv_rel := kanskje_prd & sadv+.

hva_prd := predsort.
_hva_pron_rel := hva_prd & wh+.

hvem_prd := predsort.
_hvem_pron_rel := hvem_prd & wh+.

_noe-som-helst_pron_rel := pron_rel.
_man_pron_rel := pron_rel.

hvor_prd := predsort.
hvor_prp := hvor_prd & prp+.
_hvor_adv_rel := arg1+ & prt- & hvor_prp & arg2- & arg3- & arg4- & wh+.
_hvor_x_rel := hvor_prd & cadv+.
_hvor_deg-pos_rel := hvor_prd & deg-pos.

der_prd := predsort.
der_prp := der_prd & prp+.
_der_x_rel := der_prd & cadv+.

hvordan_prd := predsort.
hvordan_prp := hvordan_prd & prp+.
_hvordan_adv_rel := adv-link & hvordan_prp & wh+.

hvorledes_prd := predsort.
hvorledes_prp := hvorledes_prd & prp+.
_hvorledes_adv_rel := adv-link & hvorledes_prp & wh+.

hvorfor_prd := predsort.
hvorfor_prp := hvorfor_prd & prp+.
_hvorfor_adv_rel := adv-link & hvorfor_prp & wh+.
_hvorfor_x_rel := hvorfor_prd & cadv+.


enn_prd := predsort.
enn_prp := enn_prd & prp+.
_enn_p_rel := arg1+ & enn_prp & 2np & arg3- & arg4- & prt-.

klokka_prd := predsort.
klokka_prp := klokka_prd & prp+.
_klokka_p_rel := arg1+ & klokka_prp & 2np & arg3- & arg4- & prt-.

ferdig_prd := predsort.
ferdig_prt := ferdig_prd & prt+.

klar_prd := predsort.
klar_prt := klar_prd & prt+.

nå_prd := predsort.
nå_prp := nå_prd & prp+.
_nå_sadv_rel := nå_prd & sadv+.

ren_prd := predsort.
ren_prt := ren_prd & prt+.

jo_prd := predsort.
_jo_sadv_rel := jo_prd & sadv+.

feks_prd := predsort.
_feks_sadv_rel := feks_prd & sadv+.

og*så*videre_prd := predsort.
_og*så*videre_sadv_rel := og*så*videre_prd & sadv+.

osv_prd := predsort.
_osv_sadv_rel := osv_prd & sadv+.

sine*anno_prd := predsort.
_sine*anno_sadv_rel := sine*anno_prd & sadv+.

i*tide*og*utide_prd := predsort.
_i*tide*og*utide_sadv_rel := i*tide*og*utide_prd & sadv+.

alltid_prd := predsort.
_alltid_sadv_rel := alltid_prd & sadv+.

ikke_prd := predsort.
_ikke_sadv_rel := ikke_prd & sadv+.
_ikke_deg-imp_rel := ikke_prd & deg-imp.


nok_prd := predsort.
_nok_part_rel := nok_prd & sadv+.

bare_prd := predsort.
_bare_sadv_rel := bare_prd & sadv+.
_bare_mod_rel := bare_prd & degadv+.

herr_prd := predsort.
_herr_ttl_rel := herr_prd & deg-nom.

_både_c_rel := degadv+.
_enten_c_rel := degadv+.
_verken_c_rel := degadv+.
_såvel_c_rel := degadv+.

_hvor_deg_rel := hvor_prd & degadv+.


så_prd := predsort.
_så_deg_rel := så_prd & degadv+.

mest_prd := predsort.
mest_grade_rel := mest_prd & degadv+.

minst_prd := predsort.
minst_grade_rel := minst_prd & degadv+.

også_prd := predsort.
_også_sadv_rel := også_prd & sadv+.
_også_deg_rel := også_prd & degadv+.

svært_prd := predsort.
_svært_deg-adv_rel := svært_prd & deg-adv.
_svært_deg-pos_rel := svært_prd & deg-pos.
_svært_deg-qnt_rel := svært_prd & deg-qnt.

godt_prd := predsort.

langt_prd := predsort.
_langt_deg_rel := langt_prd & degadv+.

_kanskje_deg_rel := kanskje_prd & degadv+.

selv_prd := predsort.
selv_prp := selv_prd & prp+.

snart_prd := predsort.
snart_prp := snart_prd & prp+.

utenom_prd := predsort.
utenom_prp := utenom_prd & prp+.
_utenom_p_rel := arg1+ & utenom_prp & 2np & arg3- & arg4- & prt-.

unna_prd := predsort.
unna_prp := unna_prd & prp+.
unna_prt := unna_prd & prt+.

;; FIXME
velkommen_v := vrb+.
velkommen_2_rel := velkommen_v & vbl+ & prt- & arg1- & 2np & arg3- & arg4-.

prøve_v := vrb+.
prøve-refl-frem_1_rel := prøve_v & vbl+ & 1np & refl & arg2+ & arg3- & arg4- & frem_prt.
_prøve*for_124_rel := prøve_v & vbl+ & 1np & 2np & arg3- & 4np & for_prp & prt-.
_prøve-ut_12_rel := prøve_v & vbl+ & 1np & 2np & arg3- & arg4- & ut_prt.
_prøve-refl*på-ip1_14_rel := prøve_v & vbl+ & 1np & refl & arg2+ & arg3- & 4ip1 & på_prp & prt-.
_prøve-refl*på_14_rel := prøve_v & vbl+ & 1np & refl & arg2+ & arg3- & 4np & på_prp & prt-.
_prøve-refl_1_rel := prøve_v & vbl+ & 1np & refl & arg2+ & arg3- & arg4- & prt-.
_prøve-ip1_12_rel := prøve_v & vbl+ & 1np & 2ip1 & arg3- & arg4- & prt-.
_prøve_12_rel := prøve_v & vbl+ & 1np & 2np & arg3- & arg4- & prt-.
_prøve_a_rel := prøve_v & adj+ & 1np & 2np & arg3- & arg4- & prt-.
_prøve-infbare_14_rel := prøve_v & vbl+ & 1np & arg2- & arg3- & 4infbare1 & prt-.
_prøve*på-ip1_14_rel := prøve_v & vbl+ & 1np & arg2- & arg3- & 4ip1 & på_prp & prt-.
_prøve_1_rel := prøve_v & vbl+ & 1np & arg2- & arg3- & arg4- & prt-.

dette_v := vrb+.
_dette-ned_1_rel := dette_v & vbl+ & 1np & arg2- & arg3- & arg4- & ned_prt.
_dette_2_rel := dette_v & vbl+ & arg1- & 2np & arg3- & arg4- & prt-.

vise_v := vrb+.
_vise-cp-cp_12_rel := vise_v & vbl+ & 1cp & 2cp & arg3- & arg4- & prt- & nom-.
_vise-cp-wh_12_rel := vise_v & vbl+ & 1cp & 2wh & arg3- & arg4- & prt-.
_vise-wh_12_rel := vise_v & vbl+ & 1np & 2wh & arg3- & arg4- & prt-.
_vise*til_14_rel := vise_v & vbl+ & 1np & arg2- & arg3- & 4np & til_prp & prt-.
_vise-tilbake_12_rel := vise_v & vbl+ & 1np & 2np & arg3- & arg4- & tilbake_prt.
_vise-bort_12_rel := vise_v & vbl+ & 1np & 2np & arg3- & arg4- & bort_prt.
_vise-ut_12_rel := vise_v & vbl+ & 1np & 2np & arg3- & arg4- & ut_prt.
_vise-refl_1_rel := vise_v & vbl+ & 1np & refl & arg2+ & arg3- & arg4- & prt-.
_vise-cp_123_rel := vise_v & vbl+ & 1np & 2cp & 3np & arg4- & prt-.
_vise_123_rel := vise_v & vbl+ & 1np & 2np & 3np & arg4- & prt-.
_vise-cp_12_rel := vise_v & vbl+ & 1np & 2cp & arg3- & arg4- & prt-.
_vise_12_rel := vise_v & vbl+ & 1np & 2np & arg3- & arg4- & prt-.
_vise_a_rel := vise_v & adj+ & 1np & 2np & arg3- & arg4- & prt-.
_vise_1_rel := vise_v & vbl+ & 1np & arg2- & arg3- & arg4- & prt-.
_vise-frem_12_rel := vise_v & vbl+ & 1np & 2np & arg3- & arg4- & frem_prt.
_vise*til-cp_14_rel := vise_v & vbl+ & 1np & arg2- & arg3- & 4cp & til_prp & prt-.
_vise-refl-cp_2_rel := vise_v & vbl+ & arg1- & 2cp & arg3+ & refl & arg4- & prt-.
_vise-refl-ip1_12_rel := vise_v & vbl+ & 1np & 2ip1 & arg3+ & refl & arg4- & prt-.
_vise*til_124_rel := vise_v & vbl+ & 1np & 2np & arg3- & 4np & til_prp & prt-.


være_v := vrb+.
_være_12_rel := være_v & vbl+ & 1np & 2np & arg3- & arg4- & prt-.
_være-ap_14_rel := være_v & vbl+ & 1np & arg2- & arg3- & 4ap & prp- & prt-.
_være_14_rel := være_v & vbl+ & 1np & arg2- & arg3- & 4np & prp- & prt-.
_være-til_1_rel := være_v & vbl+ & 1np & arg2- & arg3- & arg4- & til_prt.
_være-i*med-ip1_14_rel := være_v & vbl+ & 1np & arg2- & arg3- & 4ip1 & med_prp & i_prt.
_være-lei*av-cp_14_rel := være_v & vbl+ & 1np & arg2- & arg3- & 4cp & av_prp & lei_prt.
_være-med*på-ip1_14_rel := være_v & vbl+ & 1np & arg2- & arg3- & 4ip1 & på_prp & med_prt.
_være-med*på_14_rel := være_v & vbl+ & 1np & arg2- & arg3- & 4np & på_prp & med_prt.
_være-med-ip1_12_rel := være_v & vbl+ & 1np & 2ip1 & arg3- & arg4- & med_prt.
_være-opp*til_14_rel := være_v & vbl+ & 1np & arg2- & arg3- & 4np & til_prp & opp_prt.
_være-ip-ip1_12_rel := være_v & vbl+ & 1ip & 2ip1 & arg3- & arg4- & prt- & prp-.
_være-ip-4ap_14_rel := være_v & vbl+ & 1ip & arg2- & arg3- & 4ap & prt- & prp-.
_være-cp-4ap_14_rel := være_v & vbl+ & 1cp & arg2- & arg3- & 4ap & prt- & prp-.
_være_2_rel := være_v & vbl+ & prt- & arg1- & 2np & arg3- & arg4-.
_være*som-ip1_14_rel := være_v & vbl+ & 1np & arg2- & arg3- & 4ip1 & som_prp & prt-.
_være*som-ip-ip1_14_rel := være_v & vbl+ & 1ip & arg2- & arg3- & 4ip1 & som_prp & prt-.

bli_v := vrb+.
_bli_12_rel := bli_v & vbl+ & prt- & 1np & 2np & arg3- & arg4-.
_bli_2_rel := bli_v & vbl+ & arg1- & 2np & arg3- & arg4- & prt-.
_bli-igjen_1_rel := bli_v & vbl+ & 1np & arg2- & arg3- & arg4- & igjen_prt.
_bli-til_1_rel := bli_v & vbl+ & 1np & arg2- & arg3- & arg4- & til_prt.
_bli*ved_14_rel := bli_v & vbl+ & 1np & arg2- & arg3- & 4np & ved_prp & prt-.
_bli*med_14_rel := bli_v & vbl+ & 1np & arg2- & arg3- & 4np & med_prp & prt-.
_bli-ap_14_rel := bli_v & vbl+ & 1np & arg2- & arg3- & 4ap & prp- & prt-.
_bli_1_rel := bli_v & vbl+ & 1np & arg2- & arg3- & arg4- & prt-.
_bli-lei*av-cp_14_rel := bli_v & vbl+ & 1np & arg2- & arg3- & 4cp & av_prp & lei_prt.
_bli-med_1_rel := bli_v & vbl+ & 1np & arg2- & arg3- & arg4- & med_prt.
_bli-ved_1_rel := bli_v & vbl+ & 1np & arg2- & arg3- & arg4- & ved_prt.
_bli-noe_1_rel := bli_v & vbl+ & 1np & arg2- & arg3- & arg4- & noe_prt.
_bli*til_14_rel := bli_v & vbl+ & 1np & arg2- & arg3- & 4np & til_prp & prt-.

ha_v := vrb+.
_ha*det-ap_14_rel := ha_v & vbl+ & 1np & 2expl & arg3- & 4ap & prp- & prt-.
_ha-tilbake_12_rel := ha_v & vbl+ & 1np & 2np & arg3- & arg4- & tilbake_prt.
_ha*imot_124_rel := ha_v & vbl+ & 1np & 2np & arg3- & 4np & imot_prp & prt-.
_ha*imot_14_rel := ha_v & vbl+ & 1np & arg2- & arg3- & 4np & imot_prp & prt-.
_ha-refl_12_rel := ha_v & vbl+ & 1np & 2np & arg3+ & refl & arg4- & prt-.
_ha*til-ip2_124_rel := ha_v & vbl+ & 1np & 2np & arg3- & 4ip2 & til_prp & prt-.
_ha-frem_12_rel := ha_v & vbl+ & 1np & 2np & arg3- & arg4- & frem_prt.
_ha-igjen_12_rel := ha_v & vbl+ & 1np & 2np & arg3- & arg4- & igjen_prt.
_ha-opp_12_rel := ha_v & vbl+ & 1np & 2np & arg3- & arg4- & opp_prt.
_ha_12_rel := ha_v & vbl+ & 1np & 2np & arg3- & arg4- & prt-.
_ha_1_rel := ha_v & vbl+ & 1np & arg2- & arg3- & arg4- & prt-.
_ha-med_12_rel := ha_v & vbl+ & 1np & 2np & arg3- & arg4- & med_prt.
_ha*med-refl_12_rel := ha_v & vbl+ & 1np & 2np & arg3- & arg4+ & refl & med_prp & prt-.
_ha*på-refl_12_rel := ha_v & vbl+ & 1np & 2np & arg3- & arg4+ & refl & på_prp & prt-.
_ha*rundt-refl_12_rel := ha_v & vbl+ & 1np & 2np & arg3- & arg4+ & refl & rundt_prp & prt-.
_ha*i-refl_12_rel := ha_v & vbl+ & 1np & 2np & arg3- & arg4+ & refl & i_prp & prt-.
_ha-til-ip1_12_rel := ha_v & vbl+ & 1np & 2ip1 & arg3- & arg4- & til_prt.
_ha-på_12_rel := ha_v & vbl+ & 1np & 2np & arg3- & arg4- & på_prt.
_ha-godt*av-ip1_14_rel := ha_v & vbl+ & 1np & arg2- & arg3- & 4ip1 & av_prp & godt_prt.
_ha-godt*av_14_rel := ha_v & vbl+ & 1np & arg2- & arg3- & 4np & av_prp & godt_prt.
_ha-med-cp_12_rel := ha_v & vbl+ & 1np & 2cp & arg3- & arg4- & med_prt.
_ha-å*med_14_rel := ha_v & vbl+ & 1np & arg2- & arg3- & 4np & med_prp & å_prt.
_ha-å*med_124_rel := ha_v & vbl+ & 1np & 2np & arg3- & 4np & med_prp & å_prt.
; _ha-rede*på-wh_14_rel := ha_v & vbl+ & 1np & arg2- & arg3- & 4wh & på_prp & rede_prt.
; _ha-rede*på_14_rel := ha_v & vbl+ & 1np & arg2- & arg3- & 4np & på_prp & rede_prt.
_ha-på*på_14_rel := ha_v & vbl+ & 1np & arg2- & arg3- & 4np & på_prt & på_prp.
rett_prd := predsort.
rett_n := rett_prd & idiomform.
_rett_n_rel := rett_prd & arg1- & arg2- & arg3- & arg4- & prt- & atom.
_ha*rett*i-cp_14_rel := ha_v & vbl+ & 1np & rett_n & arg2+ & arg3- & 4cp & i_prd & prp+ & prt-.
tak_n := tak_prd & idiomform.
tak_prd := predsort.
_ha*tak*i_14_rel := ha_v & vbl+ & 1np & tak_n & arg2+ & arg3- & 4np & i_prd & prp+ & prt-.
_ha-refl-frabedt-cp_12_rel := ha_v & vbl+ & 1np & 2cp & arg3+ & refl & arg4- & frabedt_prt.

rydde_v := vrb+.
_rydde*av_14_rel := rydde_v & vbl+ & 1np & arg2- & arg3- & 4np & av_prp & prt-.
_rydde-av*av_14_rel := rydde_v & vbl+ & 1np & arg2- & arg3- & 4np & av_prp & av_prt.
_rydde*etter-refl_1_rel := rydde_v & vbl+ & 1np & arg2- & arg3- & arg4+ & refl & etter_prp & prt-.
_rydde*opp_14_rel := rydde_v & vbl+ & 1np & arg2- & arg3- & 4np & opp_prp & prt-.
_rydde-bort_12_rel := rydde_v & vbl+ & 1np & 2np & arg3- & arg4- & bort_prt.
_rydde-inn_12_rel := rydde_v & vbl+ & 1np & 2np & arg3- & arg4- & inn_prt.
_rydde-opp_1_rel := rydde_v & vbl+ & 1np & arg2- & arg3- & arg4- & opp_prt.
_rydde-refl_12_rel := rydde_v & vbl+ & 1np & 2np & arg3+ & refl & arg4- & prt-.
_rydde-refl_1_rel := rydde_v & vbl+ & 1np & refl & arg2+ & arg3- & arg4- & prt-.
_rydde-unna_12_rel := rydde_v & vbl+ & 1np & 2np & arg3- & arg4- & unna_prt.
_rydde-ut_12_rel := rydde_v & vbl+ & 1np & 2np & arg3- & arg4- & ut_prt.
_rydde-vekk_12_rel := rydde_v & vbl+ & 1np & 2np & arg3- & arg4- & vekk_prt.
_rydde_12_rel := rydde_v & vbl+ & 1np & 2np & arg3- & arg4- & prt-.
_rydde_1_rel := rydde_v & vbl+ & 1np & arg2- & arg3- & arg4- & prt-.

dekke_v := vrb+.
_dekke*opp_14_rel := dekke_v & vbl+ & 1np & arg2- & arg3- & 4np & opp_prp & prt-.
_dekke*over_14_rel := dekke_v & vbl+ & 1np & arg2- & arg3- & 4np & over_prp & prt-.
_dekke*på_14_rel := dekke_v & vbl+ & 1np & arg2- & arg3- & 4np & på_prp & prt-.
_dekke-på*på_14_rel := dekke_v & vbl+ & 1np & arg2- & arg3- & 4np & på_prp & på_prt.
_dekke-på_1_rel := dekke_v & vbl+ & 1np & arg2- & arg3- & arg4- & på_prt.
_dekke-refl_1_rel := dekke_v & vbl+ & 1np & refl & arg2+ & arg3- & arg4- & prt-.
_dekke-til_12_rel := dekke_v & vbl+ & 1np & 2np & arg3- & arg4- & til_prt.
_dekke_12_rel := dekke_v & vbl+ & 1np & 2np & arg3- & arg4- & prt-.
_dekke_1_rel := dekke_v & vbl+ & 1np & arg2- & arg3- & arg4- & prt-.
_dekke_2_rel := dekke_v & vbl+ & arg1- & 2np & arg3- & arg4- & prt-.

hete_v := vrb+.
_hete_12_rel := hete_v & vbl+ & 1np & 2np & arg3- & arg4- & prt-.
_hete-opp_12_rel := hete_v & vbl+ & 1np & 2np & arg3- & arg4- & opp_prt.

la_v := vrb+.
la-vp_123_rel := la_v & vbl+ & prt- & 1np & 2vp & 3np & arg4-.

beundre_v := vrb+.
beundre-cp_12_rel := beundre_v & vbl+ & prt- & 1np & 2cp & arg3- & arg4-.

bane_prd := idiomform.
bringe_v := vrb+.
bringe*på*bane_rel := bringe_v & vbl+ & 1np & 2np & på_prd & prp+ & bane_prd & arg3- & prt- & 4idiom.
_bringe_123_rel := bringe_v & vbl+ & 1np & 2np & 3np & arg4- & prt-.
_bringe_12_rel := bringe_v & vbl+ & 1np & 2np & arg3- & arg4- & prt-.
_bringe_a_rel := bringe_v & adj+ & 1np & 2np & arg3- & arg4- & prt-.

kalle_v := vrb+.
_kalle_124_rel := kalle_v & vbl+ & 1np & 2np & arg3- & 4np & prp- & prt-.

tenke_v := vrb+.
_tenke_134_rel := tenke_v & vbl+ & 1np & refl & arg2+ & 3np & 4ap & prp- & prt-.

idiomform := link.

ansvarlig_prd := predsort.
_ansvarlig*for-cp_rel := ansvarlig_prd & arg1- & arg2- & arg3- & 4cp & for_prp & prt-.
_ansvarlig*for-np_rel := ansvarlig_prd & arg1- & arg2- & arg3- & 4np & for_prp & prt-.

arbeid_prd := predsort.
_arbeid_n_rel := arbeid_prd & arg1- & arg2- & arg3- & arg4- & prt- & atom.
_arbeid_mass_rel := arbeid_prd & arg1- & arg2- & arg3- & arg4- & prt- & mass+.
_arbeid*med-ip1_rel := arbeid_prd & arg1- & arg2- & arg3- & 4ip1 & med_prp & prt-.

dryppe_v := vrb+.
_dryppe_0_rel := dryppe_v & vbl+ & arg1- & arg2- & arg3- & arg4- & prt-.
_dryppe_12_rel := dryppe_v & vbl+ & 1np & 2np & arg3- & arg4- & prt-.
_dryppe_a_rel := dryppe_v & adj+ & 1np & 2np & arg3- & arg4- & prt-.
_dryppe_123_rel := dryppe_v & vbl+ & 1np & 2np & 3np & arg4- & prt-.
_dryppe*i_1234_rel := dryppe_v & vbl+ & 1np & 2np & 3np & 4np & i_prp & prt-.
_dryppe_2_rel := dryppe_v & vbl+ & arg1- & 2np & arg3- & arg4- & prt-.


;;;;;
;;;;;   CASE TYPES
;;;;;

case-min := avm &
  [ SU bool ].
non-case := case-min.
case := case-min.
subj-case := case &
  [ SU + ].
non-subj-case := case &
  [ SU - ].

arg1-case := case.
arg2-case := case.
arg3-case := case.
arg4-case := case.

arg1-su-case := arg1-case & subj-case.
arg2-su-case := arg2-case & subj-case.
arg3-su-case := arg3-case & subj-case.
arg4-su-case := arg4-case & subj-case.

arg2-non-su-case := arg2-case & non-subj-case.
arg3-non-su-case := arg3-case & non-subj-case.
arg4-non-su-case := arg4-case & non-subj-case.


agree := avm &
  [ DEFINITENESS definiteness,
    GENDER gender ].

definiteness := sort.
def := definiteness.
indef := definiteness.

;; PH 31-mar-2005: Categories that can be conjoined.
category := sort.
verb-cat := category.
nominal-cat := category.
noun-cat := category.
adj-cat := category.
adv-cat := category.
sadv-cat := category.
prep-cat := category.
subord-cat := category.
inf-cat := category.
det-cat := category.

non-head := head-min.
start := head.
adj-adv-compl-nominal-verb := head.
adj-compl-nominal-verb := adj-adv-compl-nominal-verb.
adj-noun-prep-verb := adj-adv-compl-noun-prep-verb.
adj-noun-prep := adj-noun-prep-verb.
adj-adv-compl-prep-sadv-verb := head.
adj-adv-compl-noun-prep-verb := head.
adj-adv-compl-prep-verb := adj-adv-compl-prep-sadv-verb & adj-adv-compl-noun-prep-verb.
adv-compl-prep-sadv-verb := adj-adv-compl-prep-sadv-verb.
adv-compl-prep-sadv := adv-compl-prep-sadv-verb.
adv-cadv-prep-sadv := adv-compl-prep-sadv.
part := adv-cadv-prep-sadv.
adv-compl-prep-verb := adj-adv-compl-prep-verb & adv-compl-prep-sadv-verb.
compl-det-prep-verb := head.
adj-adv-card-cond-compl-nominal-prep := head.
adj-adv-card-cond-compl-noun-prep := adj-adv-card-cond-compl-nominal-prep.
adj-adv-card-cond-compl-det-poss-prep := adj-adv-card-cond-compl-nominal-prep.
adj-adv-card-compl-det-poss-prep := adj-adv-card-cond-compl-det-poss-prep.
adv-compl-prep := adv-compl-prep-verb & adj-adv-card-compl-det-poss-prep & adv-compl-prep-sadv.
; PH 05-dec-2005: RESTRICTED is introduced in order to distiguish between 
; restricted and nonrestricted relative clauses
compl-prep-verb := adv-compl-prep-verb & compl-det-prep-verb &
  [ RESTRICTED bool ].
prep-relcompl-verb := compl-prep-verb.
subcompl-prep-verb := compl-prep-verb.
adj-compl-verb := adj-compl-nominal-verb & adj-adv-compl-prep-verb.
adj-noun-verb := adj-compl-nominal-verb & adj-noun-prep-verb.
adj-verb := adj-noun-verb & adj-adv-verb & adj-compl-verb.
adj-noun-mainverb := adj-noun-verb.
adj-andre-card-noun := adj-poss-card-noun-refl & adj-adv-card-cond-compl-noun-prep.
adj-andre-carddef-noun := adj-andre-card-noun.
adj-andre-carddef := adj-andre-carddef-noun.
card-carddef := adj-andre-card-noun.
compl-nominal-verb := adj-compl-nominal-verb.
compl-noun-verb := compl-nominal-verb.
nominal-verb := compl-nominal-verb.
noun-verb := nominal-verb & compl-noun-verb.
subcompl-cadv-infcompl-noun := compl-noun-verb.
adj-adv-subcompl-infcompl-noun-prep := head.
adj-subcompl-infcompl-noun-prep := adj-adv-subcompl-infcompl-noun-prep.
adj-subcompl-infcompl-noun := adj-subcompl-infcompl-noun-prep.
subcompl-infcompl-noun-prep := adj-subcompl-infcompl-noun-prep.
subcompl-omcompl := subcompl-cadv-infcompl-noun & complementizer &
  [ KEYS.KEY at-om-c,
    CATEGORY subord-cat ].
subcompl-infcompl-noun := subcompl-cadv-infcompl-noun & 
			 subcompl-infcompl-noun-prep & 
                         adj-subcompl-infcompl-noun.
adj-atfull-infcompl-noun := adj-subcompl-infcompl-noun.
atfull-infcompl-noun := subcompl-infcompl-noun & adj-atfull-infcompl-noun.
; PH 2007-08-13: This type is introduced in order to account for the 
; preposition `som' to occur without the complementizer `om' in 
; `Jon later som han er syk':
compl-som-verb := compl-prep-verb.
compl-verb := compl-som-verb & adj-compl-verb & compl-noun-verb &
  [ COMPL-PASS bool ].
subcompl-infcompl-verb := compl-verb.
infcompl-verb := subcompl-infcompl-verb.
subcompl-verb := subcompl-infcompl-verb & subcompl-prep-verb.
aux-compl := compl-verb.
relcompl-verb := compl-verb & prep-relcompl-verb.
compl-noun := adj-compl-nominal-verb.
relcompl-noun := compl-noun.
subcompl-noun := compl-noun & subcompl-infcompl-noun & subcompl-nominal-prep.
infcompl-noun := atfull-infcompl-noun.
adj-adv-nominal-prep := adj-adv-card-cond-compl-nominal-prep & adj-adv-subcompl-infcompl-noun-prep.
adj-adv-nominal := adj-adv-nominal-prep.
adv-nominal := adj-adv-nominal.
noun-refl := adv-nominal.
; PH 2019-06-11: CARD-IN and CARD-OUT are supposed to account for there
; being only one cardinal: *De to andre to guttene sover.
adj-nominal := adj-adv-nominal & adj-noun-mainverb &
	       adj-atfull-infcompl-noun & adj-noun-prep &
  [ CATEGORY nominal-cat,
    CARD-IN bool,
    CARD-OUT bool ].
adj-card-det-commnoun := adj-nominal.
adj-det := adj-card-det-commnoun.
adj-noun := adj-andre-noun.
nominal := subcompl-noun & infcompl-noun & nominal-verb & nominal-prep &
           adj-nominal & adv-nominal.
card-commnoun-det-quant := nominal.
card-det-quant := card-commnoun-det-quant.
det-quant := card-det-quant.
garpe := nominal.
quant := card-quant & det-quant.
card-det-noun-poss := nominal.
card-det-noun := card-det-noun-poss.
adj-poss-card-noun-refl := adj-card-det-commnoun.
adv-card-noun-poss-prep-refl := head.
adv-noun-prep := adv-card-noun-poss-prep-refl.
card-noun-poss-prep := adv-card-noun-poss-prep-refl.
noun-poss-prep := card-noun-poss-prep & adj-noun-prep.
poss-card-noun := card-det-noun-poss & adj-poss-card-noun-refl & 
		  card-noun-poss-prep.
poss-prep := noun-poss-prep & adj-adv-poss-prep-refl.
card-det-poss-quant := adj-adv-card-compl-det-poss-prep.
poss := poss-card-noun & poss-prep & card-det-poss-quant.
reflex := nominal & adv-card-noun-poss-prep-refl & adj-poss-card-noun-refl & adj-adv-poss-prep-refl.
non-refl := nominal.
pron := nominal & adj-poss-card-noun-refl.
refl-poss := poss & reflex.
non-refl-poss := non-refl & poss.
card-noun := poss-card-noun & adj-andre-card-noun & card-det-noun & card-commnoun-det-quant.
card-quant := card-det-poss-quant & card-det-quant.
card := card-noun & card-quant & card-carddef &
  [ CARD-IN -,
    CARD-OUT + ].
carddef := adj-andre-carddef & card-carddef & card-det-noun.

adj-andre-noun := adj-andre-carddef-noun.
adj-andre := adj-andre-noun & adj-andre-carddef.
andre := adj-andre.
adj-mod-mod := head.
mod-mod := adj-mod-mod.

nom := nominal.
det-noun := card-det-noun.
indirquest := nom.
det := det-noun & card-det-poss-quant & compl-det-prep-verb & adj-det & det-quant &
  [ CATEGORY nominal-cat ].
adj-adv-verb := adj-adv-compl-nominal-verb.
adv-nominal-prep := adj-adv-nominal-prep.
subcompl-nominal-prep := subcompl-infcompl-noun-prep.
nominal-prep := adv-nominal-prep & subcompl-nominal-prep.
adj-adv-cadv-poss-prep := adj-adv-card-compl-det-poss-prep.
adj-adv-poss-prep-refl := adj-adv-cadv-poss-prep.
adj-adv-cadv-prep := adj-adv-cadv-poss-prep & adj-adv-card-cond-compl-noun-prep.
adj-adv-prep := adj-adv-nominal-prep & adj-adv-prep-sadv & 
		adj-adv-cadv-prep & adj-adv-poss-prep-refl.
adj-adv := adj-adv-prep & adj-adv-nominal & adj-adv-verb.
adj-prep-verb := adj-noun-prep-verb.
adj-prep := adj-adv-prep & adj-prep-verb.
adv-prep-verb := adv-compl-prep-verb.
adj-adv-prep-sadv := adj-adv-card-cond-compl-noun-prep.
adv-prep-sadv := adj-adv-prep-sadv & adv-cadv-prep-sadv.
adv-prep := adv-prep-verb & adj-adv-prep & adv-compl-prep & 
	    adv-noun-prep & adv-prep-sadv.
adv := adv-prep & adj-adv & adv-nominal &
  [ CATEGORY adv-cat ].
continuative := head.
sadv := adv-prep-sadv &
  [ MOD < [ ] >,
    CATEGORY sadv-cat,
    MESS prop_m_rel,
    UNIV bool ].
noun-pn := det-noun & nom & relcompl-noun & non-refl & 
	noun-poss-prep &
  [ CATEGORY nominal-cat ].
noun := noun-pn & adj-noun & card-noun & noun-refl & adv-noun-prep.
; The feature 'FIRST-PN bool' is introduced in order to restrict how sequences
; with more than one proper noun are combined.                  (10-jan-10; ph)
proper-noun := noun-pn &
  [ FIRST-PN bool ].
;; FIXME nominal a supertype of adj
adj := adj-prep & adj-verb & adj-noun & adj-adv & adj-mod-mod & adj-det & adj-andre &
  [ CATEGORY nominal-cat ].
compl-prep := compl-prep-verb & adv-compl-prep.
prep-verb := adv-prep-verb & prep-relcompl-verb & subcompl-prep-verb & adj-prep-verb &
  [ KEYS.KEY prep-verb-p ].
aux-verb := noun-verb & infcompl-verb & subcompl-verb & adj-prep-verb.
verb := aux-verb & relcompl-verb & prep-verb & adj-verb &
  [ MOD <>,
    CATEGORY verb-cat ].
aux-subcompl := aux-compl.
aux := aux-verb & aux-subcompl.
mainverb := verb & adj-noun-mainverb.
prep-min := prep-verb & adv-prep & compl-prep & adj-prep & nominal-prep & 
	poss-prep &
  [ CATEGORY prep-cat ].
prep := prep-min.
som := prep-min & compl-som-verb.
complementizer := compl-prep & aux-compl.
subcompl-infcompl := complementizer.
infcompl := infcompl-noun & subcompl-infcompl & infcompl-verb &
  [ MOD <>,
    MESS prop_m_rel,
    CATEGORY inf-cat ].
subcompl := subcompl-noun & subcompl-omcompl & subcompl-verb & 
	   subcompl-infcompl & aux-subcompl &
  [ MESS prop_m_rel ].
atfull := subcompl & atfull-infcompl-noun.
whcompl := complementizer.
atnull := subcompl.
cadv := subcompl-cadv-infcompl-noun & complementizer & adj-adv-cadv-prep & adv-cadv-prep-sadv.
cond := adj-adv-card-cond-compl-det-poss-prep & adj-adv-card-cond-compl-noun-prep &
  [ MESS prop-yn_m_rel ].
omcompl := subcompl-omcompl & cadv.
relcompl := complementizer & relcompl-verb & relcompl-noun &
  [ CATEGORY subord-cat ].
expl-pron := noun &
  [ MESS prop_m_rel ].
refl-pron := nom & reflex.
refl-pron-light := noun-refl.
refl-pron-heavy := refl-pron.
conj := head.
interj := head.

;;;;;   MODALS
modal := modal-min &
  [ BURDE bool,
    KUNNE bool,
    MATTE bool,
    SKULLE bool,
    VILLE bool ].

;;;;;
;;;;;   PREDSORT
;;;;;

nonpred := predsort.
prep-verb-p := predsort.
aux-compl-p := predsort.
compl-c := aux-compl-p.
prep-p := prep-verb-p.
at-om-c := cadv+.
selv_om-c := cadv+.
dersom-c := cadv+.
når-c := cadv+.
da-c := cadv+.
før-c := cadv+.			;
etter-c := cadv+.
til-c := cadv+.
fordi-c := cadv+.
mens-c := cadv+.
ettersom-c := cadv+.
siden-c := cadv+.
at-det-at-c := at-om-c.
det-at-c := at-det-at-c.
at-c := at-det-at-c.
om-c := at-om-c.
; & med-om-c.
som_om-c := cadv+.
som-c := som_om-c.
å-det-å-c := prep-p.
å-c := å-det-å-c.
det-å-c := å-det-å-c.

;;;
;;; Pred values for resticting the application of rules for sub-coordination.
;;;                                                            (2008-04-09; ph)
sub-coord_rel := predsort.
bicl_rel := sub-coord_rel.
bicl_contr_rel := bicl_rel.
_sitte_v_rel := bicl_contr_rel.
_stå_v_rel := bicl_contr_rel.
_ligge_v_rel := bicl_contr_rel.
_være_v_rel := bicl_contr_rel.
_komme_v_rel := bicl_contr_rel.
_gå_v_rel := bicl_contr_rel.
;_sette*seg_v_rel := bicl_contr_rel.
;_legge*seg_v_rel := bicl_contr_rel.
;_ringe_v_rel := bicl_contr_rel.

bicl_rais_rel := bicl_rel.
_drive_v_rel := bicl_rais_rel.

monocl_rel := sub-coord_rel.
eoc_rel := sub-coord_rel.
cmplx-pass_rel := predsort.
_skrive_v_rel := eoc_rel.
_ta_v_rel := eoc_rel & monocl_rel.


;;;;;
;;;;;   SEMANTIC RELATIONS
;;;;;


; PH 2013-01-31: Made a distinction between quant_m_rel and
; anti-quant_m_rel in the hierarchy of scopal relation
; predicates. This in order to prevent modifiers from being assigned
; to quantifiers. ('Mannen kom gående.')
quant-or-anti-quant_m_rel := predsort.
quant_m_rel := quant-or-anti-quant_m_rel & atom.
anti-quant_m_rel := quant-or-anti-quant_m_rel.
non-bare_q := quant-or-anti-quant_m_rel.
def_q := non-bare_q.
def_q_rel := def_q & quant_m_rel.
anti-def_q_rel := def_q & anti-quant_m_rel.
def_implicit_q := quant-or-anti-quant_m_rel.
def_implicit_q_rel := def_implicit_q & quant_m_rel.
anti-def_implicit_q_rel := def_implicit_q & anti-quant_m_rel.
demonstr_q := non-bare_q.
demonstr_q_rel := demonstr_q & quant_m_rel.
anti-demonstr_q_rel := demonstr_q & anti-quant_m_rel.
udef_q := non-bare_q.
udef_q_rel := udef_q & quant_m_rel.
anti-udef_q_rel := udef_q & anti-quant_m_rel.
proper_q := non-bare_q.
proper_q_rel := proper_q & quant_m_rel.
anti-proper_q_rel := proper_q & anti-quant_m_rel.
pronoun_q := non-bare_q.
pronoun_q_rel := pronoun_q & quant_m_rel.
anti-pronoun_q_rel := pronoun_q & anti-quant_m_rel.
bare-sg_q := quant-or-anti-quant_m_rel.
bare-sg_q_rel := bare-sg_q & quant_m_rel.
anti-bare-sg_q_rel := bare-sg_q & anti-quant_m_rel.
_hvilken_q_rel := non-bare_q & quant_m_rel.
_all_q_rel := non-bare_q & quant_m_rel.
_halve_q_rel := def_q  & quant_m_rel.
_hele_q_rel := def_q  & quant_m_rel.
_hver_q_rel := non-bare_q & quant_m_rel.
_hvor-mye_q_rel := non-bare_q & quant_m_rel.
_ingen_q_rel := non-bare_q & quant_m_rel.
_mindre_q_rel := non-bare_q & quant_m_rel.

mye_prd := predsort.
mye_prp := mye_prd & prp+.
_mye_q_rel := quant_m_rel & mye_prd.
_mye_deg_rel := degadv+ & mye_prd.

_noen_q_rel := non-bare_q & quant_m_rel.
_noe_q_rel := non-bare_q & quant_m_rel.
_nok_q_rel := non-bare_q & quant_m_rel.
_lite_q_rel := non-bare_q & quant_m_rel.
_mer_q_rel := non-bare_q & quant_m_rel.
_mest_q_rel := non-bare_q & quant_m_rel.
_minst_q_rel := non-bare_q & quant_m_rel.
_enkelte_q_rel := non-bare_q & quant_m_rel.
_begge_q_rel := non-bare_q & quant_m_rel.
_et-par_q_rel := non-bare_q & quant_m_rel.
_en-del_q_rel := non-bare_q & quant_m_rel.
_en-rekke_q_rel := non-bare_q & quant_m_rel.
_enhver_q_rel := non-bare_q & quant_m_rel.
_flere_q_rel := non-bare_q & quant_m_rel.
_samtlige_q_rel := non-bare_q & quant_m_rel.
_annenhver_q_rel := non-bare_q & quant_m_rel.
_halvannen_q_rel := non-bare_q & quant_m_rel.
_hvor-mange_q_rel := non-bare_q & quant_m_rel.
_mange_q_rel := non-bare_q & quant_m_rel.
every_q_rel := non-bare_q & quant_m_rel.
unknown_q_rel := quant_m_rel & non-bare_q.
_selve_q_rel := non-bare_q & quant_m_rel.

generic_entity_rel := atom.

scope-relation := quant-relation &
  [ PRED quant-or-anti-quant_m_rel ].

sub-relation := arg0-relation.
nom-relation := arg0-relation &
  [ ARG0 ref-ind ].
pron-relation := nom-relation &
  [ PRED "pron_rel" ].
def-relation := scope-relation &
  [ PRED def_q_rel ].
demonstr-relation := scope-relation &
  [ PRED demonstr_q ].
def-implicit-relation := scope-relation &
  [ PRED def_implicit_q ].
gen-indef-relation := scope-relation.
indef-relation := gen-indef-relation &
  [ PRED udef_q ].
bare-sg-relation := gen-indef-relation &
  [ PRED bare-sg_q ].
pronoun-q-relation := scope-relation &
  [ PRED pronoun_q ].
proper-q-relation := scope-relation &
  [ PRED proper_q ].
every_q_relation := quant-relation &
  [ PRED every_q_rel ].

multiple-pn-relation := arg0-relation &
  [ PRED "multiple-pn_rel",
    FIRST-NAME handle,
    LAST-NAME handle ].
multiple-card-relation := arg0-relation &
  [ PRED "multiple-card_rel",
    FIRST-CARD handle,
    LAST-CARD handle ].


;;;;;
;;;;;   WORD OR LEXEME
;;;;;

start-phrase := binary-phrase & embedded-phrase-min &
  [ CONJ no-conj,
    LINK-INPUT #li,
    INFLECTED +,
    SYNSEM [ FIRST-WORD +,
	     LOCAL [ CAT [ HEAD #head & aux-verb,
			   VAL #val,
			   VBL #verbal,
			   QUANT #q,
			   ARGUMENT #arg & [ LOCAL.CAT.CASE subj-case ],
			   CASE #case,
			   COMPARATIVE #com ],
		     TOPIC #topic,
		     CONT [ HOOK #hook,
			    MSG #msg ],
		     AGR #agr ],
	     NON-LOCAL #nl,
	     SAT #bool,
	     --PHR-KEY no-msg,
	     LKEYS #lk,
	     MODIFIED #mod ],
    C-CONT [ RELS <!!>,
	     HCONS <!!> ],
    ARGS < [ START + ],           
	   word & 
	   [ LINK-INPUT #li,
	     INFLECTED +,
             SYNSEM [ FIRST-WORD -,
		      LOCAL  [ CAT [ HEAD #head,
				     VAL #val,
				     VBL #verbal,
				     QUANT #q,
				     ARGUMENT #arg,
				     CASE #case,
				     COMPARATIVE #com ],
			       TOPIC #topic,
			       AGR #agr,
			       CONT [ HOOK #hook,
				      MSG #msg ] ],
		      NON-LOCAL #nl,
		      SAT #bool,
		      LKEYS #lk,
		      MODIFIED #mod ] ] > ].

; Input for the genitive inflectional rule
non-gen-word := word.

downward-entailing := word-or-lexrule &
  [ SYNSEM.LOCAL [ NEG-OUT neg_m_rel,
		   NEG-IN message_m_rel ] ].

non-down-entailing := word-or-lexrule &
  [ SYNSEM.LOCAL [ NEG-OUT #bool,
		   NEG-IN #bool ] ].

yn-pol-item := non-down-entailing &
  [ SYNSEM.LOCAL.NEG-IN yes-no-ques_m_rel ].                   

neg-pol-item := non-down-entailing &
  [ SYNSEM.LOCAL.NEG-IN neg-or-yn_m_rel ].                   

1rel-lex-item := norm-lex-item &
  [ SYNSEM.LOCAL.CONT.RELS <! [] !> ].

;;;;;
;;;;;   VALENCE
;;;;;

open-lxm := lexeme & non-gen-word &
  [ SYNSEM [ LOCAL [ CAT [ HEAD adj-noun-mainverb,
                           VAL.CMP4.LOCAL.CAT.HEAD adj-adv-prep,
                           VBL anti-synsem &
                                [ NON-LOCAL.SLASH <> ] ],
                     CONT [ HOOK.INDEX event-or-ref-index,
                            RELS <! arg0-relation !> ]] ],
    INFLECTED - ].

;;;;;
;;;;;   BASIC VERB LEXEME TYPES
;;;;;

verb-lex-item := lex-item.

verb-lxm := lexeme & verb-lex-item.

main-verb-lxm-min := verb-lxm &
  [ ALTS.PASSIVE -,
    SYNSEM [ LOCAL [ CAT [ HEAD verb & [ PERFPART bool ],
			   VBL anti-synsem ],
		     CONT [ HOOK.INDEX #ind & event,
			    RELS <! !>,
			    HCONS <!!> ] ],
	     LKEYS [ KEYREL #cnstr & [ ARG0 #ind & [ PERF bool ] ],
		     CNSTR #cnstr ] ] ].

main-verb-lxm := main-verb-lxm-min &
  [ SYNSEM [ LOCAL.CAT.VAL.ARGFRAME #argframe,
	     LKEYS.KEYREL.PRED #argframe ] ].

intrans-link := vrb+ & prt- & 1np & arg2- & arg3- & arg4-.

intrans-verb-lxm := main-verb-lxm-min &
  [ SYNSEM.LOCAL.CAT.VAL.ARGFRAME intrans-link ]. 

trans-link := vrb+ & prt- & 1np & 2np & arg3- & arg4-.

trans-verb-lxm := main-verb-lxm-min &
  [ SYNSEM.LOCAL.CAT.VAL.ARGFRAME trans-link ]. 

tiltrenge_v := vrb+.
_tiltrenge_12_rel := trans-link & tiltrenge_v.

frastå_v := vrb+.
_frastå_12_rel := trans-link & frastå_v.

rule_v := vrb+.
_rule_1_rel := vbl+ & 1np & arg2- & arg3- & arg4- & prt- & rule_v.

complex-pass-verb_le := verb-lxm & 1rel-lex-item &
  [ SYNSEM [ LOCAL.CAT [ HEAD #head & verb,
			 VAL #val & [ CMP2.LOCAL.CAT.HEAD nominal ],
			 CASE #case,
			 STACK #stack,
			 ARGUMENT #arg & 
			      [ LOCAL.CAT.CASE non-subj-case ],
			 VBL synsem &
			      [ LOCAL [ CAT [ HEAD #head,
					      VAL #val,
					      CASE #case,
					      STACK #stack,
					      ARGUMENT #arg & 
						   [ LOCAL.CAT.CASE non-subj-case ] ],
					CONT.HOOK.INDEX.E.TENSE perf ] ] ],
	     LKEYS.CNSTR.ARG1 expl-ind ] ].

; ; Alternation frames for the vpidiom paper (2014-04-15; ph)
; idiom-verb := main-verb-lxm-min &
;   [ SYNSEM [ LOCAL.CAT.VAL.ARGFRAME #argframe,
; 	     LKEYS.KEYREL.PRED #argframe & vrb+ ] ].


; ; bringe på bane
; arg12-123-124_np_np_idiom_le := arg2_np & idiom-verb.
; ; løfte i flokk
; arg1-12-14_np_np_idiom_le := arg2_np & idiom-verb.
; ; legge skjul på
; arg1-12-124_np_np_idiom_le := arg2_np & idiom-verb.
; ; gå konkurs
; arg1-12_np_idiom_le := arg2_np & idiom-verb.

;;;; Ordbank types



;;;;;
;;;;;   AUXILIARIES
;;;;;

verbal-item := sign.

non-rel-item := verbal-item & bottom-gap-item.

aux-lxm := verb-lxm & non-rel-item &
  [ SYNSEM.LOCAL.CAT [ HEAD aux,
                       VBL synsem ] ].

non-pass-aux-lxm := aux-lxm & non-pass-verbal-item &
  [ ALTS.PASSIVE -,
    SYNSEM [ LOCAL [ CAT.VBL.MODIFIED notmod-or-rmod,
		     CONT.RELS diff-list ],
	     LKEYS.ALTKEYREL no-msg ] ].

modal-aux-lxm := non-pass-aux-lxm & norm-lex-item &
  [ SYNSEM [ LOCAL [ CAT.VBL.LKEYS.KEYREL.LBL #larg,
		     CONT.HCONS <! [ HARG #harg,
				     LARG #larg ] !>],
	     LKEYS.KEYREL.ARG1 #harg ] ].
		   
; Jon kan smile
; Jon kan ha smilt
inf-pres-modal-aux-lxm := modal-aux-lxm &
  [ SYNSEM [ LOCAL [ CONT.RELS <! #keyrel & [ ARG0.E.TENSE infin-pres ] !>,
		     CAT [ HEAD.PERFPART -,
			   VBL.LOCAL.CONT.HOOK.INDEX [ E.TENSE infin,
						     PERF - ] ] ],
	     LKEYS.KEYREL #keyrel ] ].

; Jon kunne ha smilt
; Jon kunne smile
pret-perf-modal-aux-lxm := modal-aux-lxm &
  [ SYNSEM [ LOCAL [ CONT.RELS <! #keyrel & [ ARG0.E.TENSE pret-perf ] !>,
		     CAT.VBL.LOCAL.CONT.HOOK.INDEX.E.TENSE infin ],
	     LKEYS.KEYREL #keyrel ] ].

basic-non-modal-aux-lxm := aux-lxm &
  [ SYNSEM [ LOCAL [ MODAL #modal,
		     CAT [ VBL [ LOCAL [ MODAL #modal,
					 CAT.HEAD.PERFPART + ],
				 LKEYS.KEYREL [ LBL #ltop] ] ],
		     CONT [ HOOK.LTOP #ltop,
			    HCONS <!!> ] ] ] ].

non-modal-aux-lxm := basic-non-modal-aux-lxm & non-pass-aux-lxm &
  [ SYNSEM [ LOCAL [ CAT [ HEAD.PERFPART -,
			   VBL [ LOCAL.CONT.HOOK.INDEX event & [ PERF + ],
				 LKEYS.KEYREL [ LBL #ltop,
						ARG0 #index ] ] ],
		     CONT [ HOOK.INDEX event & [ E.TENSE #tense ],
			    RELS  <! #relation !> ] ],
	     LKEYS.KEYREL #relation & [ LBL #ltop,
					ARG0 #index & [ E.TENSE #tense ] ] ] ].

;;;;;
;;;;;   NOMINAL WORD-OR-LEXEME TYPES
;;;;;

quant-lex-item := nominal-item.

noquant-lex-item := nominal-item &
  [ SYNSEM.LOCAL.CONT.HCONS <! !> ].

indef-art-lex-item := indef-lex-item & quant-lex-item &
  [ SYNSEM.LKEYS.Q.QREL indef-relation ].

def-det-item := def-lex-item & 
  [ SYNSEM [ LOCAL [ CAT [ QUANT +,
			   VAL.SISTER synsem,
			   HEAD.AGREE.GENDER #gen ],
		     CONT [ HOOK [ LTOP #larg,
				   INDEX #ind ],
			    RELS <! !>,
			    HCONS <! !> ] ],
	     LKEYS [ KEYREL [ LBL #larg,
			      ARG0 #ind ],
		     Q.QREL quant-relation & 
			    [ PRED quant_m_rel,
			      ARG0 #ind & [ PNG.GEN #gen ] ] ] ] ].

def-art-lex-item := def-det-item & qrel-lex-item &
  [ SYNSEM.LKEYS.Q.QREL def-relation ].

dem-lex-item := def-det-item &
  [ SYNSEM.LKEYS.Q.QREL demonstr-relation ].

nominal-item := word-or-lexrule &
  [ SYNSEM [ PHR - ] ].

; PH 2019-06-07: Unified KEYREL and ALTKEYREL in order to account for
; genitives. The genitive inflectional rule needs to grab a relation,
; also from determiners, and I have given them ALTKEYREL
noun-lxm-min := nominal-item & lexeme &
  [ SYNSEM [ LOCAL [ CAT [ HEAD noun & [ AGREE.GENDER #gen ],
			   VAL [ SISTER anti-synsem ],
			   COMPARATIVE - ],
		     CONT [ HOOK [ INDEX #index,
				   LTOP #hndl ],
			    RELS <! !>,
			    HCONS <!!> ] ],
	     LKEYS.KEYREL [ ARG0 #index & [ PNG.GEN #gen ],
			    LBL #hndl ] ] ].

noun-lxm := noun-lxm-min &
  [ SYNSEM [ LOCAL.CAT [ HEAD [ MOD <>,
				NOM + ],
			 VAL.SISTER [ SAT + ] ],
	     LKEYS.KEYREL [ ARG0.PNG.PN 3p ] ] ].

;Jon kommer fredag
mod-noun-lxm := count-noun-lxm &
  [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CAT.HEAD compl-verb ] > ].

;Trondheim sentrum
mod-pn-noun-lxm := noun-lxm-min &
  [ SYNSEM.LOCAL [ CAT.HEAD.MOD < [ LOCAL [ CAT.HEAD proper-noun,
					    CONT.HOOK.INDEX.PNG.PN #pn ],
				    LEX + ] >,
		   CONT.HOOK.INDEX.PNG.PN #pn ] ].

;En liter is
;mod-det-noun-lxm := noun-lxm-min &
;  [ SYNSEM.LOCAL [ CAT.HEAD.MOD < [ SAT -,
;				    LOCAL [ CAT.HEAD card-det-poss-quant & 
;						  [ AGREE.DEFINITENESS indef ],
;					    CONT.HOOK.INDEX.PNG.PN #pn ] ] >,
;		   CONT.HOOK.INDEX.PNG.PN #pn ] ].

mod-det-noun-item := nominal-item & no-slash &
  [ SYNSEM [ SAT +,
             LOCAL [ CAT [ HEAD noun & 
				[ MOD < [ LOCAL [ CAT.HEAD card-det-poss-quant ],
					  LEX bool ] > ],
			   VAL [ CMP1.LINK arg1-,
				 CMP2.LINK arg2-,
				 CMP3.LINK arg3-,
				 CMP4.LINK arg4-,
				 SISTER synsem-min ] ] ] ] ].

mod-det-noun-word := mod-det-noun-item & 1rel-lex-item.
mod-det-noun-lxm := mod-det-noun-item & noun-lxm-min.
mod-det-mascorneut-noun-lxm := mod-det-noun-lxm.
mod-det-mascorneut-cmp-noun-lxm := mod-det-mascorneut-noun-lxm & cmp-lxm.
mod-det-masc-noun-lxm := mod-det-mascorneut-noun-lxm & masc-item.
mod-det-masc-cmp-noun-lxm := mod-det-mascorneut-noun-lxm & masc-item & cmp-lxm.

mass-item := lex-item &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.PN mass-or-sg ].

mass-noun-word := noun-word-min &
  [ SYNSEM.LOCAL [ CAT.QUANT -,
		   CONT.HOOK.INDEX.PNG.PN mass ],
    ARGS < mass-noun-lxm >,
    C-CONT [ RELS <!!>,
	     HCONS <!!> ] ].
; comm-mass-item := lex-item &
;   [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.GEN comm-or-mass ].
; mascorneut-mass-item := lex-item &
;   [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.GEN masc-or-neut-or-mass ].
; masc-mass-item := lex-item &
;   [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.GEN masc-or-mass ].
; fem-mass-item := lex-item &
;   [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.GEN fem-or-mass ].
; neut-mass-item := lex-item &
;   [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.GEN neut-or-mass ].

comm-noun-lxm-min := noun-lxm.
masc-noun-lxm-min := noun-lxm.
fem-noun-lxm-min := noun-lxm.
neut-noun-lxm-min := noun-lxm.
comm-mod-noun-lxm-min := mod-noun-lxm.

mass-noun-lxm := noun-lxm-min &
  [ SYNSEM.LKEYS.KEYREL.ARG0.PNG.PN mass ].
count-noun-lxm := noun-lxm-min &
  [ SYNSEM.LKEYS.KEYREL.ARG0.PNG.PN count ].

;;; noun lexeme types
comm-noun-lxm := comm-noun-lxm-min & comm-item.
comm-cmp-noun-lxm := comm-noun-lxm & cmp-lxm.
comm-mwe-noun-lxm := comm-noun-lxm & mwe-lxm.
;; le types
comm-cmp-count-noun-lxm := comm-cmp-noun-lxm & count-noun-lxm.
comm-cmp-mass-noun-lxm := comm-cmp-noun-lxm & mass-noun-lxm.
comm-mwe-count-noun-lxm := comm-mwe-noun-lxm & count-noun-lxm.
comm-mwe-mass-noun-lxm := comm-mwe-noun-lxm & mass-noun-lxm.

masc-noun-lxm := masc-noun-lxm-min & masc-item.
masc-cmp-noun-lxm := masc-noun-lxm & cmp-lxm.
masc-mwe-noun-lxm := masc-noun-lxm & mwe-lxm.
;; le types
masc-cmp-count-noun-lxm := masc-cmp-noun-lxm & count-noun-lxm.
masc-cmp-mass-noun-lxm := masc-cmp-noun-lxm & mass-noun-lxm.
masc-mwe-count-noun-lxm := masc-mwe-noun-lxm & count-noun-lxm.
masc-mwe-mass-noun-lxm := masc-mwe-noun-lxm & mass-noun-lxm.

fem-noun-lxm := fem-noun-lxm-min & fem-item.
fem-cmp-noun-lxm := fem-noun-lxm & cmp-lxm.
fem-mwe-noun-lxm := fem-noun-lxm & mwe-lxm.
;; le types
fem-cmp-count-noun-lxm := fem-cmp-noun-lxm & count-noun-lxm.
fem-cmp-mass-noun-lxm := fem-cmp-noun-lxm & mass-noun-lxm.
fem-mwe-count-noun-lxm := fem-mwe-noun-lxm & count-noun-lxm.
fem-mwe-mass-noun-lxm := fem-mwe-noun-lxm & mass-noun-lxm.


neut-noun-lxm := neut-noun-lxm-min & neut-item.
neut-cmp-noun-lxm := neut-noun-lxm & cmp-lxm.
neut-mwe-noun-lxm := neut-noun-lxm & mwe-lxm.
;; le types
neut-cmp-count-noun-lxm := neut-cmp-noun-lxm & count-noun-lxm.
neut-cmp-mass-noun-lxm := neut-cmp-noun-lxm & mass-noun-lxm.
neut-mwe-count-noun-lxm := neut-mwe-noun-lxm & count-noun-lxm.
neut-mwe-mass-noun-lxm := neut-mwe-noun-lxm & mass-noun-lxm.


comm-mod-noun-lxm := comm-mod-noun-lxm-min & comm-item.
comm-mod-mwe-noun-lxm := comm-mod-noun-lxm & mwe-lxm.



; comm-mass-noun-lxm := noun-lxm & mass-noun-lxm & comm-mass-item.
; mascorneut-mass-noun-lxm := noun-lxm & mass-noun-lxm & mascorneut-mass-item.
; masc-mass-noun-lxm := noun-lxm & mass-noun-lxm & masc-mass-item.
; fem-mass-noun-lxm := noun-lxm & mass-noun-lxm & fem-mass-item.
; neut-mass-noun-lxm := neut-noun-lxm-min & mass-noun-lxm & neut-mass-item.
; comm-mod-mass-noun-lxm := comm-mod-noun-lxm-min & mass-noun-lxm & comm-mass-item.
; comm-mod-mwe-mass-noun-lxm := comm-mod-mass-noun-lxm & mwe-lxm.

; comm-noun-lxm := noun-lxm & comm-item.
; masc-noun-lxm := comm-noun-lxm & masc-item.
; fem-noun-lxm := comm-noun-lxm & fem-item.
; neut-noun-lxm := noun-lxm & neut-item.
; comm-mod-noun-lxm := mod-noun-lxm & comm-item.
masc-mod-noun-lxm := comm-mod-noun-lxm & masc-item.
masc-mod-cmp-noun-lxm := comm-mod-noun-lxm & masc-item & cmp-lxm.
comm-mod-cmp-noun-lxm := comm-mod-noun-lxm & fem-item & cmp-lxm.
neut-mod-noun-lxm := mod-noun-lxm & neut-item.
neut-mod-cmp-noun-lxm := mod-noun-lxm & neut-item & cmp-lxm.

comm-mod-pn-noun-lxm := mod-pn-noun-lxm & comm-item.
masc-mod-pn-noun-lxm := comm-mod-pn-noun-lxm & masc-item.
fem-mod-pn-noun-lxm := comm-mod-pn-noun-lxm & fem-item.
neut-mod-pn-noun-lxm := mod-pn-noun-lxm & neut-item.
neut-mod-pn-cmp-noun-lxm := mod-pn-noun-lxm & neut-item & cmp-lxm.


mascorneut-noun-lxm := noun-lxm &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.GEN gender ].
mascorneut-mwe-noun-lxm := mascorneut-noun-lxm & mwe-lxm.
mascorneut-cmp-noun-lxm := mascorneut-noun-lxm & cmp-lxm.

nominal-lex-item := 1rel-lex-item &
  [ SYNSEM [ FIRST-WORD -,
	     LOCAL [ CONT [ HOOK [ INDEX #ind,
                                   LTOP #ltop ],
                            RELS <! #rel & [ LBL #ltop,
					     ARG0 #ind ] !> ] ],
             NON-LOCAL.SLASH <>,
	     LKEYS.KEYREL #rel ] ].

adj-mod := sign &
  [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CAT.HEAD compl-verb ] > ].

adj-lxm-min := lexeme & adj-mod &
  [ SYNSEM [ LOCAL [ CAT [ HEAD adj & [ MOD < [ LOCAL [ CAT.HEAD.AGREE #agr,
							CONT.HOOK.LTOP #ltop ] ] >,
					AGREE #agr ],
			   VAL [ ARGFRAME adj+,
				 SISTER.LOCAL [ CAT.HEAD adj-noun,
						CONT.HOOK.LTOP #ltop ] ],
			   STACK <>],
		     CONT [ HOOK [ LTOP #ltop ],
			    RELS <! !>,
			    HCONS <!!> ] ],
	     LKEYS.KEYREL relation & [ LBL #ltop ] ] ].

adj-lxm := adj-lxm-min &
  [ SYNSEM.LOCAL.CAT.VAL.ARGFRAME arg1+ & arg2- & arg3- & arg4- & prt- & prp- & atom ].

mwe-lxm := lexeme &
  [ SYNSEM [ LOCAL.CAT.VAL.ARGFRAME #1,
	     LKEYS.KEYREL.PRED #1 & arg3- & prt- ] ].

mwe-adj-lxm := mwe-lxm & adj-lxm-min.

; compositional adjective lexemes
cmp-lxm := lexeme &
  [ SYNSEM.LOCAL.CAT.VAL.ARGFRAME arg2- & arg3- & arg4- & prt- & prp- ].
cmp-adj-lxm := adj-lxm & cmp-lxm.

da-word := word & native-lex-item &
  [ LEXREL <! #relation !>,
    SYNSEM [ FIRST-WORD -,
	     LOCAL [ CAT [ HEAD andre & [ MOD <>,
					  AGREE #agr & [ GENDER #gen ] ],
			   VAL.SISTER [ SAT -,
					LOCAL [ CAT.HEAD adj-andre-card-noun & 
							 [ AGREE #agr ],
						CONT.HOOK.LTOP #lbl ],
					LKEYS.KEYREL.LBL #lbl ],
			   STACK <>,
			   QUANT - ],
		     CONT [ HOOK [ LTOP #lbl ],
			    HCONS <!!>,
			    RELS <!  !>] ],
	     LKEYS [ KEYREL #relation &
				  [ LBL #lbl,
				      ARG0 event,
				      ARG1 #ind & [ PNG.GEN #gen ] ],
		     ALTKEYREL [ LBL #lbl,
				 PRED generic_entity_rel,
				 ARG0 #ind ] ] ] ].

indef-sg-da-word := indef-lex-item & da-word &
  [ SYNSEM.LKEYS.KEYREL.ARG1.PNG.PN sg ].
indef-sg-masc-da-word := indef-sg-da-word & sg-item & masc-item.
indef-sg-comm-da-word := indef-sg-da-word & sg-item & comm-item.
indef-sg-fem-da-word := indef-sg-da-word & sg-item & fem-item.
indef-sg-neut-da-word := indef-sg-da-word & sg-item & neut-item.

def-da-word := def-lex-item & da-word.

indef-pl-da-word := indef-lex-item & da-word &
  [ SYNSEM.LKEYS.KEYREL.ARG1 [ PNG.PN pl,
			       COGN-ST type-id ] ].
; PH 2019-01-09: Removed LKEYS.Q.QREL indef-relation constraint.
; PH 2017-11-09: Underspecified ARGFRAME value in order to allow for
; "jeg smiler en dag"
cardinal := sign &
  [ SYNSEM.LOCAL.CAT.VAL.ARGFRAME predsort ].

; PH 2019-06-06: Changed SISTER.HEAD adj-andre-card-noun to adj-andre-noun in order
; to avoid overgeneration: to to to to ....
; PH 2017-11-09: Underspecified NOM value in order to allow for
; "jeg smiler en dag"
; PH 2017-08-30: Removed SISTER synsem constraint in order to account for
; nr. 3 brauter, where 3 does not have a sister: *nr. tre menn brauter.
card-word := cardinal & non-wh-word & word & no-link-item & native-lex-item &
  [ SYNSEM [ FIRST-WORD -,
	     LOCAL [ CAT [ HEAD card-carddef & [ AGREE #agr,
						 NOM bool,
						 MOD list ],
			   VAL.SISTER synsem-min &
				[ SAT -,
				  LOCAL [ CAT.HEAD adj-andre-noun & 
						   [ AGREE #agr & [ GENDER #gen ],
						     MOD list ],
					  CONT.HOOK [ INDEX #ind ] ] ],
			   QUANT + ],
		     CONT [ HOOK [ LTOP #lbl,
				   INDEX #ind & [ PNG.GEN #gen ] ],
			    HCONS <! !>] ],
	     LKEYS [ KEYREL [ LBL #lbl ],
		     Q.QREL.ARG0 #ind ] ],
    LEXREL <! [ PRED card_rel,
		LBL #lbl,
		ARG0 [ PERF -,
		       E.TENSE untensed ],
		ARG1 #ind ] !> ].

multiple-card-phrase := basic-binary-phrase & cardinal &
  [ SYNSEM.LOCAL [ CAT #cat & [ HEAD card ],
                   CONT.HOOK [ LTOP #ltop,
                               INDEX #2 ] ],
    ARGS < cardinal & [ SYNSEM.LOCAL [ CAT #cat,
                                          CONT.HOOK [ LTOP #1,
                                                      INDEX #2 ] ] ], 
           card-word &
           [ SYNSEM.LOCAL.CONT.HOOK [ LTOP #3,
                                      INDEX #2 ] ] >,
    C-CONT.RELS <! multiple-card-relation & [ LBL #ltop,
                                            ARG0 #2,
                                            FIRST-CARD #1,
                                            LAST-CARD #3 ] !> ].

; PH 2019-01-09: Removed the LKEYS.Q.QREL.PRED "pronoun_rel" constraint.
indef-card-word := card-word &
  [ SYNSEM [ LOCAL [ CAT [ HEAD card & [ MOD < [ LOCAL [ CAT [ HEAD noun-verb & 
			              [ AGREE.DEFINITENESS indef ],
				      VAL.SISTER anti-synsem ] ] ] > ],
					    VAL.SISTER.LOCAL [ CAT.HEAD adj-andre-carddef-noun &
		                          [ AGREE.DEFINITENESS indef ],
				   CONT.HOOK.INDEX.COGN-ST type-id ] ],
		     CONT [ RELS <! #rel !> ] ],
	     LKEYS [ ALTKEYREL.PRED generic_entity_rel,
		     Q.QREL indef-relation ] ],
    LEXREL <!#rel!>].

sg-card-word := indef-card-word & sg-item & non-gen-word.
masc-sg-card-word := sg-card-word & masc-item.
fem-sg-card-word := sg-card-word & fem-item.
neut-sg-card-word := sg-card-word & neut-item.

pl-card-word := card-word & pl-item &
  [ SYNSEM [ LOCAL [ CAT.HEAD card,
		     CONT.RELS <! #rel !> ],
	     LKEYS [ Q.QREL indef-relation,
		     ALTKEYREL.ARG0.COGN-ST type-id ] ],
    LEXREL <!#rel!> ].

digit-word := pl-card-word &
  [ STEM [ FORM #form ],
    SYNSEM.LKEYS.KEYREL.CARG #form ].

def-mod-word := word &
  [ SYNSEM [ LOCAL [ CAT [ HEAD.AGREE.DEFINITENESS #definiteness,
			 VAL.SISTER [ LOCAL.CAT.HEAD.AGREE.DEFINITENESS #definiteness,
				      LKEYS.KEYREL.ARG0.COGN-ST uniq-or-more ] ] ] ] ].

def-card-word := card-word & def-mod-word &
  [ SYNSEM [ LOCAL [ CAT [ HEAD carddef & [ MOD < [ LOCAL.CAT.HEAD verb ] > ],
			   VAL.SISTER.LOCAL.CAT.HEAD adj-andre-card-noun ],
		     CONT.RELS <!!> ],
	     LKEYS [ KEYREL #rel,
		     ALTKEYREL.PRED def_digit ] ],
    LEXREL <!#rel!> ].

sg-def-card-word := def-card-word & sg-item.

; De to hundene sover.
pl-def-card-word := def-card-word & pl-item &
  [ SYNSEM [ LOCAL.CAT [ HEAD.AGREE.DEFINITENESS #def,
			 VAL.SISTER.LOCAL [ CAT.HEAD.AGREE.DEFINITENESS #def,
					    CONT.HOOK.INDEX.COGN-ST uniq-or-more ] ],
	     SAT - ] ].


card-select-lex-item := marker-word &
  [ SYNSEM [ LOCAL [ CAT [ HEAD noun & [ MOD list ],
			   VAL.SISTER synsem &
				[ LOCAL.CAT.HEAD card & 
						 [ AGREE.DEFINITENESS indef ] ] ],
		     CONT [ HOOK.INDEX.COGN-ST type-id,
			    RELS <! !> ] ] ] ].
; nr fem
card-select-word := card-select-lex-item & keyrel-lex-item.
; nummer fem
card-select-le := card-select-lex-item & lexeme.

; 2016-09-07: Constrained possessives to be NOM + in order to avoid the
; application of the modifier rule, as long as we are using the
; post-poss-rule
; (2013-01-28; ph) Took out the MOD..MODIFIED notmod constraint and changed
; the MOD..HEAD value from noun to nominal
poss-word-min := mod-word &
  [ LEXREL <! #lexrel !>,
    SYNSEM [ LOCAL [ CAT [ HEAD [ MOD < [ LOCAL [ CAT.HEAD nominal & 
							   [ AGREE.DEFINITENESS def ],
						  CONT.HOOK [ LTOP #sis,
							      INDEX #arg1 ] ],
					  MODIFIED xmod ] >,
				  NOM + ],
			   VAL [ CMP4.MARKED -,
				 SISTER [ SAT -,
					  LOCAL [ CAT [ HEAD adj-andre-card-noun &
							     [ AGREE.DEFINITENESS indef ] ],
						  CONT.HOOK [ INDEX #arg1 & [ COGN-ST uniq-or-more ],
							      LTOP #sis ] ] ] ] ],
		     CONT [ HOOK [ LTOP #sis,
				   INDEX #arg1 ],
			    RELS <! #lexrel & poss-relation &
				  [ ARG1 #arg1 ] !>,
			    HCONS <! !> ] ],
	     LKEYS [ ALTKEYREL.PRED generic_entity_rel,
		     Q [ QREL def-relation &
			    [ ARG0 #arg1,
			      RSTR #harg2 ],
			 QEQ [ HARG #harg2,
			       LARG #sis ] ] ] ] ].

poss-word := poss-word-min &
  [ SYNSEM.LOCAL [ CAT [ HEAD poss,
			 VAL.SISTER synsem ] ] ].

garpe-word := norm-lex-item & phrase & keyrel-lex-item & 
  [ LEXREL <!#relation!>,
    SYNSEM.LOCAL [ CAT [ HEAD garpe & [ MOD <> ],
			 STACK <> ],
		   CONT [ RELS <! #relation &
				arg12-relation & [ PRED "poss_rel" ] !>,
			  HCONS <!!>] ] ].

garpe-phrase := binary-phrase &
  [ START -,
    SYNSEM [ LOCAL [ CAT [ HEAD #head,
			   VAL [ CMP4 anti-synsem,
				 SISTER synsem &
					[ SAT -,
					  LOCAL [ CAT.HEAD card-noun &
							   [ AGREE.DEFINITENESS indef ] ],
					  LKEYS.KEYREL.PRED atom ] ],
			   QUANT +,
			   STACK #stack ],
		     CONT.HOOK [ LTOP handle,
				 INDEX #1 & ref-ind ] ],
	     LKEYS [ KEYREL [ PRED generic_entity_rel,
			      ARG0 #1 ],
		     Q.QREL def-relation & [ ARG0 #1 ] ] ],
    ARGS < [ SYNSEM [ LOCAL [ CAT [ HEAD #head & det-noun,
				    STACK #stack ],
			      CONT.HOOK.INDEX #1 & ref-ind ],
		      LKEYS [ KEYREL #keyrel & [ LBL #larg,
						 ARG0 #2 ],
			      Q.QREL #qrel & [ RSTR #harg ] ] ] ],
	   garpe-word & [ SYNSEM.LOCAL.CONT.RELS <! arg12-relation & 
						  [ ARG0 event,
						    ARG1 #1,
						    ARG2 #2 ] !> ] >,
    C-CONT [ RELS <! #keyrel, #qrel !>,
	     HCONS <! qeq & [ HARG #harg,
			      LARG #larg ] !> ] ].

genitive-word := inflecting-lex-rule & word & keyrel-lex-item &
  [ INFLECTED +,
    SYNSEM [ FIRST-WORD -,
	     LOCAL [ CAT [ HEAD #head,
			   VAL.SISTER synsem &
				[ SAT -,
				  LOCAL [ CAT.HEAD adj-nominal &
						   [ AGREE.DEFINITENESS indef ],
					  CONT.HOOK [ LTOP #larg,
						      INDEX #2 ] ],
				  LKEYS [ KEYREL [ LBL #larg ] ] ],
			   QUANT #q ],
		     CONT.HOOK [ LTOP #larg,
				 INDEX #1  ] ],
	     LKEYS [ ALTKEYREL [ PRED generic_entity_rel,
			      ARG0 #2 ],
		     
		     Q.QREL def-relation ] ],
    ARGS < non-gen-word &
	   [ INFLECTED +,
	     SYNSEM [ LOCAL [ CAT [ HEAD #head & card-det-noun & [ NOM + ],
				    QUANT #q ],
			      CONT.HOOK.INDEX #1 ],
		      LKEYS [ ALTKEYREL #altkeyrel & [ LBL #larg,
						       PRED atom,
						       ARG0 #1 ],
			      Q.QREL #qrel & [ ARG0 #1,
					       RSTR #harg ] ] ] ] >,
    C-CONT [ RELS <! arg12-relation & [ PRED "poss_rel",
					ARG0 event,
					ARG1 #2,
					ARG2 #1 ], #qrel, #altkeyrel !>,
	     HCONS <! qeq & [ HARG #harg,
			      LARG #larg ] !> ] ].

marker-word := word &
  [ SYNSEM [ FIRST-WORD -,
	     LOCAL [ CAT [ VAL [ ARGFRAME no-link,
				 CMP4.MARKED -,
				 SISTER synsem-min & 
					  [ LOCAL [ CONT.HOOK [ LTOP handle ] ],
					    LKEYS.Q [ QREL.ARG0 #ind ] ] ],
			   STACK <>,
			   QUANT + ],
		     CONT [ HOOK.INDEX #ind & [ PNG.PN 3p ],
			    RELS <!  !>,
			    HCONS <!  !>] ],
	     NON-LOCAL.SLASH <>,
	     LKEYS [ Q.QREL [ PRED quant_m_rel ] ] ] ].

; PH 2016-08-05: link between AGREE and SISTER..AGREE:
; Hvilken hund bjeffer
; *Hvilket hund bjeffer
det-word-min := marker-word & qrel-lex-item & non-gen-word &
  [ LEXREL <! #relation !>,
    SYNSEM [ LOCAL [ CAT [ HEAD det-quant & [ AGREE #agr ],
			 VAL.SISTER synsem-min &
			      [ SAT -,
				LOCAL.CAT.HEAD adj-andre-card-noun &
				    [ AGREE #agr ] ] ],
		   CONT.HOOK.INDEX ref-ind ],
	     LKEYS [ Q.QREL #relation,
		     ALTKEYREL relation & [ PRED "pron_rel" ] ] ] ].


det-word := det-word-min & 
  [ SYNSEM.LOCAL.CAT.COMPARATIVE - ].


mer-mest-det-word := det-word-min &
  [ SYNSEM.LOCAL.CAT [ HEAD quant &
			    [ MOD < [ SYNSEM.LOCAL.CAT.HEAD verb ] > ],
		       VAL.SISTER [ LOCAL.CAT.HEAD.AGREE.DEFINITENESS indef,
				    LKEYS.KEYREL.ARG0.PNG.PN mass-or-pl ] ] ].

; Jon spiser mer is.
; Jon har mer problemer.
mer-det-word := mer-mest-det-word &
  [ SYNSEM.LOCAL.CAT.COMPARATIVE + ].
			   
; Jon spiser mest is.
mest-det-word := mer-mest-det-word &
  [ SYNSEM.LOCAL.CAT.COMPARATIVE - ].

; Det kommer en pr mann
per-word := keyrel-lex-item &
  [ SYNSEM [ LOCAL [ CAT [ HEAD prep & [ MOD < [ LOCAL.CAT.HEAD nominal,
						 SAT + ] > ],
			   VAL [ SISTER [ SAT -,
					  LOCAL [ CAT.HEAD adj-nominal &
							   [ AGREE.DEFINITENESS indef ] ] ],
				 CMP2 synsem & 
					[ LINK arg2+ ] ],
			   ARGUMENT synsem ],
		     CONT.RELS <! !> ],
	     LKEYS.ALTKEYREL.PRED generic_entity_rel ] ].

quant-word := marker-word & qrel-lex-item &
  [ SYNSEM [ LOCAL [ CAT [ HEAD quant & [ AGREE #agree ],
                         VAL.SISTER synsem &
			      [ LOCAL.CAT.HEAD adj-card-det-commnoun &
					       [ AGREE #agree ] ] ],
                   CONT [ RELS <! !> ] ],
	     LKEYS [ ALTKEYREL.PRED "pron_rel" ] ] ].

sg-quant-word := quant-word & sg-item.

float-quant-word := quant-word.

all-quant-word := non-down-entailing & float-quant-word &
  [ SYNSEM [ LOCAL.CAT.VAL.SISTER [ SAT + ],
	     LKEYS.Q.QREL.PRED _all_q_rel ] ].

comm-all-quant-word := comm-item & all-quant-word & mass-item. 

neut-all-quant-word := neut-item & mass-item & all-quant-word.

pl-all-quant-word := pl-item & all-quant-word.

hver-quant-word := quant-word & non-down-entailing &
  [ SYNSEM [ LOCAL.CAT.VAL.SISTER.SAT -,
             SAT +,
             LKEYS.KEYREL [ ARG0 [ PNG.PN sg,
				   COGN-ST type-id ] ] ] ].

comm-hver-quant-word := comm-item & sg-item & hver-quant-word. 

neut-hver-quant-word := neut-item & sg-item & hver-quant-word.

both-quant-word := pl-item & float-quant-word &
  [ SYNSEM [ LOCAL.CAT.VAL.SISTER [ LOCAL.CAT.HEAD.AGREE.DEFINITENESS def,
                                    SAT + ],
             LKEYS.Q.QREL.PRED _begge_q_rel ] ].

down-entailing-quant := downward-entailing & quant-word &
  [ SYNSEM.LOCAL.CAT.VAL.SISTER.LOCAL.CAT.HEAD adj-andre-carddef-noun ].

hv-word := wh-word & keyrel-lex-item &
  [ SYNSEM [ LOCAL [ CAT [ HEAD indirquest,
                           VAL [ CMP2.LINK arg2- ] ], 
                     CONT [ HOOK.INDEX.PNG.PN 3p,
                            RELS <! !>,
                            HCONS <! !> ] ],
             NON-LOCAL.SLASH <> ] ].

; PH 2019-06-07: Unified KEYREL and ALTKEYREL in order to account for
; genitives. The genitive inflectional rule needs to grab a relation,
; also from determiners, and I have given them ALTKEYREL
noun-word-min-min := nominal-item & non-gen-word & keyrel-lex-item & 
		     non-pronoun &
  [ SYNSEM [ LOCAL [ CAT #cat & [ HEAD noun ],
		     CONT.HOOK [ INDEX #index,
				 LTOP #hndl,
				 CONJ-IND #index ],
		     EXTR-REL [ ARG0 #index,
				PRED #pred,
				LBL #hndl ] ],
	     NON-LOCAL.SLASH <>,
	     LKEYS [ KEYREL #keyrel &
			    [ PRED #pred,
			      ARG0 #index,
			      LBL #hndl ],
		     ALTKEYREL #keyrel,
		     Q [ QREL.ARG0 #index,
			 QEQ.LARG #hndl ] ] ],
    LINK-INPUT -,
    ARGS < lexeme &
	   [ SYNSEM [ LOCAL.CAT #cat,
		      LKEYS [ KEYREL [ PRED #pred,
				       ARG0 #index,
				       LBL #hndl ] ] ] ] > ].

noun-word := noun-word-min-min & gap-unary & non-wh-word &
  [ SYNSEM.SAT bool ].

; PH 2016-03-31: Linked the LINK to the KEYREL.PRED value. This constrains
; the function words to be a part of the construction.
empty-sign := no-slash & word & keyrel-lex-item &
[ SYNSEM [ LINK #link,
	   LOCAL [ CAT [ VAL [ SISTER anti-synsem ],
			 STACK <> ],
                   CONT [ RELS <!!>,
                          HCONS <!!> ] ],
	   LKEYS.KEYREL.PRED #link,
           NON-LOCAL.SLASH <>,
           FIRST-WORD - ],
  LINK-INPUT - ].

expletive-noun-phrase := empty-sign &
[ SYNSEM [ LOCAL [ CAT.HEAD expl-pron & [ MOD <> ],
		   CONT.HOOK.INDEX expl-ind ],
	   LKEYS.KEYREL.ARG0 expl-ind,
	   LINK expl+ ] ].

;;; Empty words for vpidiom paper (2014-04-15; ph)
empty-noun-word := empty-sign &
[ SYNSEM [ LOCAL.CAT [ HEAD noun,
		       QUANT - ],
	   LKEYS.KEYREL.PRED idiomform ] ].

empty-refl-word := empty-sign &
[ SYNSEM [ LOCAL.CAT [ HEAD refl-pron-light & [ MOD <> ],
		       QUANT - ],
	   LKEYS.KEYREL.PRED idiomform & refl ] ].

func-word-min := empty-sign &
  [ SYNSEM.LOCAL.CAT.HEAD adv-cadv-prep-sadv &
			  [ MOD < [ LOCAL.CAT.HEAD head ] > ] ]. ;

func-word-prd := func-word-min &
  [ SYNSEM [ LOCAL.CAT.VAL.ARGFRAME #frame,
	     LKEYS.KEYREL.PRED #frame ] ].

func-word := func-word-prd & non-down-entailing & non-wh-word.

part-word := func-word &
  [ SYNSEM.LKEYS.KEYREL.PRED prt+ ].

; prep-word := func-word &
;   [ SYNSEM.LKEYS.KEYREL.PRED prp+ ].

down-func-word := downward-entailing & func-word-prd.

; nr. 3 smiler
number-mod-word := func-word &
  [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CAT.VAL.SISTER anti-synsem ] > ].
  

adv-link := prp+ & arg1+ & arg2- & arg3- & arg4- & prt-.
prp-link := prp+ & arg1+ & 2np & arg3- & arg4- & prt-.

adv-word := func-word-min & non-wh-word &
  [ SYNSEM [ LOCAL.CAT.VAL.ARGFRAME adv-link,
	     LKEYS.KEYREL.ARG0.SF prop_m_rel ] ].

prp-word := func-word-min & non-wh-word &
  [ SYNSEM.LOCAL.CAT.VAL.ARGFRAME prp-link ].

func-wh-word := func-word-prd & wh-word.

empty-prep-word := empty-sign &
[ SYNSEM [ LOCAL.CAT [ HEAD prep,
		       VAL.CMP2.LINK arg2+ ],
	   LINK prp+ ] ].

empty-part-word := empty-sign &
[ SYNSEM [ LOCAL.CAT.HEAD prep,
	   LINK prt+ ] ].



content-noun-word := noun-word & lexeme-to-word-rule &
[ ARGS < lexeme & [ SYNSEM.LOCAL.CAT.HEAD noun ] > ].

def-word := word-or-lexrule &
[ SYNSEM.LOCAL.CAT.HEAD.AGREE.DEFINITENESS def ].

indef-word := lex-item &
[ SYNSEM.LOCAL.CAT.HEAD.AGREE.DEFINITENESS indef ].

; PH 2007-04-28: New type for indefinite singular nouns where the C-CONT.RELS
; list is empty.
noun-word-min := lex-rule & norm-lex-item & noun-word-min-min &
  [ SYNSEM [ LOCAL [ CAT [ HEAD noun & [ MESS prop_m_rel,
					 AGREE #agr & [ GENDER #gen ] ], 
                           VAL [ SISTER #dobj ],
                         COMPARATIVE #comp ] ],
	     LKEYS.KEYREL.ARG0.PNG.GEN #gen,
             NON-LOCAL.SLASH <> ],
    ARGS < lexeme &
           [ SYNSEM [ LOCAL [ CAT [ HEAD noun & [ AGREE #agr ],
                                    VAL.SISTER #dobj,
                                    COMPARATIVE #comp ] ],
                      MODIFIED notmod-or-rmod ] ] >,
    C-CONT.RELS <!!> ].

sg-noun-word := noun-word-min & sg-mass-item.

indef-sg-qrel := keyrel-lex-item &
  [ SYNSEM.LKEYS.Q.QREL bare-sg-relation ].

; DEBUG 2013-11-24: No COGN-ST constraint because of "min hund" is uniq.
indef-noun-word := noun-word-min-min & phrase-or-lexrule &
  [ SYNSEM.LOCAL.CAT [ HEAD.AGREE.DEFINITENESS indef,
		       QUANT + ],
    C-CONT [ RELS <! !>,
	     HCONS <! !> ] ].

indef-sg-noun-word := sg-noun-word & indef-word & 
		      indef-sg-qrel & indef-noun-word.

; PH 2006-12-02: New type for singular indefinite nouns. Replaces the old
; type for singular indefinite nouns and the bare singular type.
;indef-sg-noun-word := sg-item & infl-noun-word & indef-lex-item &
;  [ C-CONT.RELS <! [ PRED "indef_rel" ] !> ].

infl-indef-sg-noun-word := indef-sg-noun-word & inflecting-lex-rule.
const-indef-sg-noun-word := indef-sg-noun-word & constant-lex-rule.
indef-pl-comm-noun-word := indef-plur-noun-word & comm-item.

const-indef-pl-comm-noun-word := indef-pl-comm-noun-word & 
                            constant-lex-rule &
  [ INFLECTED +,
    ARGS < [ INFLECTED - ] > ].

infl-indef-pl-comm-noun-word := indef-pl-comm-noun-word & inflecting-lex-rule &
  [ INFLECTED +,
    ARGS < [ INFLECTED - ] > ].

indef-pl-neut-noun-word := indef-plur-noun-word & neut-item. 
const-indef-pl-neut-noun-word := indef-pl-neut-noun-word & constant-lex-rule.
infl-indef-pl-neut-noun-word := indef-pl-neut-noun-word & inflecting-lex-rule.

scope-word-phrase := phrase-or-lexrule &
  [ SYNSEM [ LOCAL [ CAT.QUANT +,
		     CONT [ HOOK [ LTOP #larg,
				   INDEX #ind ],
			    RELS.LIST.FIRST quant-relation & [ ARG0 #ind,
						     RSTR #harg ],
			    HCONS <! qeq & [ HARG #harg,
					     LARG #larg ] !> ] ],
	     SAT + ] ].

scope-word-min := phrase-or-lexrule &
  [ SYNSEM.LOCAL [ CAT.QUANT +,
		   CONT.HOOK [ LTOP #larg,
			       INDEX #ind ] ],
    C-CONT [ RELS.LIST.FIRST quant-relation & [ ARG0 #ind,
						RSTR #harg ],
	     HCONS <! qeq & [ HARG #harg,
			      LARG #larg ] !> ] ].

scope-word := scope-word-min &
  [ C-CONT.RELS <! [] !> ].

; PH 2016-08-03: Changed ARGS.FIRST.CONJ from no-pre-conj to conj-value.
; Changed input from phrase-or-lexrule to phrase (2015-10-22; ph)
scope-phrase-min := unary-phrase &
  [ SYNSEM [ LOCAL [ CAT [ HEAD det & [ MESS #mess,
					AGREE #agr,
					NOM #nom & + ],
			   COMPARATIVE #cmp,
			   QUANT bool,
			   CASE #case,
			   STACK #stack ],
		     CONT.HOOK #hook ],
	     NON-LOCAL #nl,
	     LKEYS.KEYREL #keyrel,
	     SAT #sat,
	     MODIFIED #modif ],
    ARGS < phrase &
	   [ CONJ conj-value,
	     SYNSEM [ LOCAL [ CAT [ HEAD adj-nominal & [ MESS #mess,
							 AGREE #agr,
							 NOM #nom ],
				    COMPARATIVE #cmp,
				    CASE #case,
				    STACK #stack ],
			      CONT.HOOK #hook & [ INDEX ref-ind ] ],
		      NON-LOCAL #nl,
		      LKEYS.KEYREL #keyrel,
		      SAT #sat,
		      MODIFIED #modif ] ] > ].

scope-phrase := scope-phrase-min & scope-word-min &
  [ SYNSEM.LOCAL.CAT [ HEAD.MOD <>,
		       VAL #val ],
    C-CONT [ RELS <! #qrel & scope-relation & [ PRED quant_m_rel,
						RSTR #harg ] !>,
	     HCONS <! qeq & [ HARG #harg, LARG #larg ] !> ],
    ARGS < [ SYNSEM [ LOCAL [ CAT [ VAL #val & [ SISTER anti-synsem ],
				    QUANT - ],
			      CONT.HOOK.LTOP #larg ],
		      LKEYS.Q.QREL #qrel ] ] > ].

gen-ent-scope-phrase := scope-phrase-min & neg-link &
  [ CONJ no-conj,
    SYNSEM [ LOCAL [ CAT [ HEAD.MOD < >,
			   VAL.SISTER anti-synsem,
			   QUANT #q ],
		     CONT.HOOK [ LTOP #lbl,
				 INDEX #ind ] ],
	     LKEYS.Q #qrel ],
    C-CONT [ RELS <! [ LBL #lbl,
		       PRED generic_entity_rel,
		       ARG0 #ind ] !>,
	     HCONS <!  !> ],
    ARGS < [ SYNSEM [ SAT +,
		      LOCAL.CAT [ HEAD adj-nominal,
				  VAL.SISTER synsem &
				       [ LKEYS [ KEYREL [ LBL #lbl,
							  ARG0 #ind ],
						 Q.QEQ.LARG #lbl ] ],
				  QUANT #q ],
		      LKEYS.Q #qrel & [ QREL [ PRED quant_m_rel ] ] ] ] > ].

infl-noun-word := lex-rule & norm-lex-item & noun-word-min-min &
  [ SYNSEM [ LOCAL [ CAT [ HEAD noun & [ MESS prop_m_rel ],
			   VAL [ SISTER #dobj ],
			   COMPARATIVE #comp ]],
	     NON-LOCAL.SLASH <>],
    ARGS < lexeme &
           [ SYNSEM [ LOCAL.CAT [ HEAD noun,
				  VAL.SISTER #dobj,
				  COMPARATIVE #comp ],
		      MODIFIED notmod-or-rmod ] ] > ].

pl-noun-word := pl-item & infl-noun-word.

indef-plur-noun-word := pl-noun-word & indef-word & indef-noun-word &
  [ SYNSEM.LKEYS.Q.QREL indef-relation ].

; This type caused sentences like 'Mannen sover i skogen.' to fail.
; no-det-word := phrase-or-lexrule & word &
;   [ STEM [ FROM #from,
; 	   TO #to ],
;     SYNSEM [ LOCAL [ CAT.QUANT bool,
; 		     CONT.HOOK [ LTOP #ltop,
; 				 INDEX #ind ] ],
; 	     LKEYS.Q [ QREL [ ARG0 #ind,
; 			      RSTR #harg,
; 			      CFROM #from, 
; 			      CTO #to ],
; 		       QEQ qeq & [ HARG #harg, LARG #ltop ] ] ],
;     C-CONT [ RELS <! !>,
; 	     HCONS <! !> ] ].

no-det-word := phrase-or-lexrule & word &
  [ SYNSEM [ LOCAL [ CAT.QUANT bool,
		     CONT.HOOK [ LTOP #ltop,
				 INDEX #ind ] ],
	     LKEYS.Q [ QREL [ ARG0 #ind,
			      RSTR #harg ],
		       QEQ qeq & [ HARG #harg, LARG #ltop ] ] ],
    C-CONT [ RELS <! !>,
	     HCONS <! !> ] ].

def-noun-word := def-lex-item & infl-noun-word & no-det-word &
  [ SYNSEM [ LOCAL [ CAT.QUANT +,
		     CONT.HOOK.INDEX.COGN-ST uniq-or-more ],
	     LKEYS.Q.QREL def-relation ] ].
 
def-sg-comm-noun-word := sg-item & def-noun-word & comm-item & 
                         inflecting-lex-rule.
def-sg-masc-noun-word := def-noun-word & masc-item & sg-item & 
                         inflecting-lex-rule.
def-sg-fem-noun-word := def-noun-word & fem-item & sg-item & 
                         inflecting-lex-rule.
def-sg-neut-noun-word := def-noun-word & neut-item & 
                         inflecting-lex-rule & sg-item.
pl-def-noun-word := pl-item & def-noun-word & inflecting-lex-rule. 

; Type constructed for "kr."
non-infl-noun-word := nominal-item & 1rel-lex-item & non-pronoun &
  [ SYNSEM [ LOCAL [ CAT [ HEAD noun & 
				[ MOD < [ LOCAL.CAT.HEAD compl-verb ] > ],
			   VAL.SISTER synsem-min & [ SAT - ],
			   STACK <> ] ] ] ].

non-infl-mass-noun-word := mass-noun-word.

mod-noun-word := non-infl-noun-word &
  [ SYNSEM.LOCAL.CAT.VAL.SISTER anti-synsem ].

non-comp-item := lex-item &
  [ SYNSEM.LOCAL.CAT.COMPARATIVE - ].

; PH 2016-09-15: Changed SISTER synsem to synsem-min in order to allow
; adjectives to undergo the mod-embedded-rule.
adj-word-min := non-gen-word & non-pronoun & nominal-item & keyrel-lex-item &
  [ SYNSEM [ LOCAL [ CAT [ HEAD adj & [ AGREE #agr ],
			   VAL [ SISTER synsem-min &
					[ SAT -,
					  LOCAL.CAT.HEAD noun & [ AGREE #agr ] ] ],
			   QUANT -,
			   STACK <> ] ],
	     LKEYS #lkeys,
	     FIRST-WORD - ],
    ARGS < [ SYNSEM.LKEYS #lkeys ] > ].

adj-word := adj-word-min.

adj_basic := adj-word.

adj_komp_word := adj_basic &
  [ SYNSEM.LOCAL [ CAT [ HEAD.MOD < [ LOCAL.CAT.HEAD.AGREE.DEFINITENESS indef ] >,
		 COMPARATIVE + ],
		   CONT.HOOK.INDEX.GRADE comparative ] ].

adj_sup_word := adj_basic & sup-adj-word.

;; adj-word := adj-word-min &
;;   [ SYNSEM [ LOCAL.CONT [ HOOK [ LTOP #lbl,
;; 				 INDEX #ind,
;; 				 XARG #ind ],
;; 			  RELS <! arg1-relation & [ LBL #lbl,
;; 						    ARG0 #ind ], 
;; 				#keyrel !> ],
;; 	     LKEYS.KEYREL #keyrel ] ].
; PH 2016-06-23: Added VAL.SISTER.LKEYS.KEYREL.ARG0.COGN-ST type-id constraint
; in order to differentiate from definite adjectives: "Jeg har det bra"
indef-adj-word := adj-word &
  [ SYNSEM [ LOCAL [ CAT [ HEAD.AGREE.DEFINITENESS indef,
			   VAL.SISTER.LKEYS.KEYREL.ARG0.COGN-ST type-id,
			   QUANT - ] ],
	     LKEYS.Q.QREL relation &
		   [ PRED quant-or-anti-quant_m_rel ]] ].


pos-adj-word := non-comp-item &
  [ SYNSEM.LKEYS.KEYREL.ARG0.GRADE positive ].

sg-adj-word := indef-adj-word & pos-adj-word & indef-sg-qrel &
  [ SYNSEM [ LOCAL.CAT.VAL.SISTER.LOCAL.CONT.HOOK.INDEX.PNG.PN sg,
	     LKEYS.KEYREL.ARG1.PNG.PN sg ] ].

norm-adj-word := adj-word & lex-rule &
  [ SYNSEM [ LOCAL [ CONT.HOOK.XARG #xarg,
		     CAT #cat ],
	     LKEYS.KEYREL #keyrel & [ ARG1 #xarg] ],
    ARGS < adj-lxm-min &
	   [ SYNSEM [ LOCAL [ CAT #cat ],
		      LKEYS.KEYREL #keyrel ] ] >,
    C-CONT [ RELS <! !>,
	     HCONS <!!> ] ].

; PH 2016-09-15: Changed PREDIATIVE - to bool in order to account for
; "Jon er godt likt".
participle-adj-word := adj-word-min & lex-rule &
  [ SYNSEM [ LOCAL [ CAT [ HEAD [ MOD < [ LOCAL [ CONT.HOOK.INDEX [ PNG #png ] ] ] >,
				  PREDICATIVE bool ],
			   VAL.ARGFRAME arg1+ & arg2- & arg3- & arg4-,
			   QUANT - ],
                   CONT.HOOK [ LTOP #1,
                               INDEX [ PNG #png,
				       GRADE positive ],
			       XARG #arg2 ] ],
	     LKEYS #lkeys & [ Q.QREL.ARG0 #arg2 ] ],
    ARGS < perf-part-verb-word &
           [ SYNSEM [ LOCAL [ CAT [ HEAD verb ],
                            CONT.HOOK.LTOP #1 ],
	     LKEYS #lkeys & [ KEYREL arg12-relation & [ PRED 1np & 2np & arg3- & arg4- & prt-,
							       LBL #1,
							ARG0.E.TENSE untensed,
							       ARG2 #arg2 ] ] ] ] >,
    C-CONT [ RELS <! !>,
	     HCONS <!!> ] ].

premod-adj-word := adj-word &
  [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ MODIFIED lmod ] > ].

const-participle-adj-word := participle-adj-word & constant-lex-rule.
infl-participle-adj-word := participle-adj-word & inflecting-lex-rule.

const-sg-adj-word := sg-adj-word & constant-lex-rule & norm-adj-word.
sg-comm-adj-word := sg-adj-word & comm-item & norm-adj-word & premod-adj-word.
infl-sg-comm-adj-word := sg-comm-adj-word & inflecting-lex-rule.
const-sg-comm-adj-word := sg-comm-adj-word & constant-lex-rule.
sg-neut-adj-word := sg-adj-word & neut-item & norm-adj-word &
  [ SYNSEM.LKEYS.KEYREL.ARG1.PNG.GEN neut ]. 
infl-sg-neut-adj-word := sg-neut-adj-word & inflecting-lex-rule.
const-sg-neut-adj-word := sg-neut-adj-word & constant-lex-rule.
sg-fem-adj-word := sg-adj-word & fem-item & 
                   inflecting-lex-rule & norm-adj-word. 

part-indef-sg-adj-word := sg-adj-word & const-participle-adj-word &
  [ SYNSEM.LOCAL.CAT [ HEAD.MOD < [ LOCAL.CAT.HEAD compl-nominal-verb ] >,
		       VAL.SISTER synsem ] ].

pl-adj-word := pos-adj-word & premod-adj-word &
  [ SYNSEM [ LOCAL.CAT.VAL.SISTER.LOCAL.CONT.HOOK.INDEX.PNG.PN pl,
	     LKEYS [ KEYREL.ARG1.PNG.PN pl,
		     Q.QREL indef-relation ] ] ].

pl-indef-adj-word := pl-adj-word & indef-adj-word &
  [ SYNSEM [ LKEYS [ Q.QREL indef-relation ] ] ].

; PH 05-May-2007: This type allows plural adjectives to act as nouns: 
; "flinke sover"
norm-pl-indef-adj-word := non-gen-word & indef-lex-item & keyrel-lex-item & 
			  non-comp-item & lex-rule &
 [ SYNSEM.LKEYS.KEYREL.ARG0 [ PNG.PN pl,
			      GRADE positive ],
   ARGS < adj-lxm-min >,
   C-CONT [ RELS <!  !>,
	    HCONS <!!>] ].

infl-pl-indef-adj-word := pl-indef-adj-word & inflecting-lex-rule & norm-adj-word.
const-pl-indef-adj-word := pl-indef-adj-word & constant-lex-rule & norm-adj-word.

;norm-pl-indef-adj-word := pl-indef-adj-word & norm-adj-word.
part-indef-pl-adj-word := pl-adj-word & infl-participle-adj-word &
  [ SYNSEM.LOCAL.CAT.QUANT - ].

; PH 2016-08-17: Added a INDEX..PN sg constraint in order to avoid two
; analyses of "de store mennene".
; PH 2016-06-14: Took out the SISTER ...HEAD.AGREE.DEFINITENESS def 
; constraint in order to account for "Norges største dikter"
def-adj-word := premod-adj-word & def-mod-word &
  [ SYNSEM [ SAT -,
	     LKEYS.Q.QREL.PRED anti-quant_m_rel ] ]. 

pos-def-adj-word := def-adj-word & pos-adj-word. 
norm-pos-def-adj-word := pos-def-adj-word & norm-adj-word.
infl-norm-pos-def-adj-word := norm-pos-def-adj-word & inflecting-lex-rule.
const-norm-pos-def-adj-word := norm-pos-def-adj-word & constant-lex-rule.
part-pos-def-adj-word := pos-def-adj-word & infl-participle-adj-word.


sup-adj-word := norm-adj-word & non-comp-item &
  [ SYNSEM.LKEYS.KEYREL.ARG0.GRADE superlative ]. 

sup-unsat-adj-word := sup-adj-word & def-adj-word & inflecting-lex-rule &
  [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CAT.HEAD head ] > ].

sup-adj-word-2 := sup-adj-word & indef-adj-word & inflecting-lex-rule &
  [ SYNSEM [ SAT #sat,
	     LOCAL.CAT.HEAD.MOD < [ SAT #sat,
				    LOCAL [ CAT.HEAD head,
					   CONT.HOOK.INDEX.PNG.PN sg ] ]  > ] ].

sup-sat-adj-word := sup-adj-word & inflecting-lex-rule & indef-adj-word &
  [ SYNSEM [ SAT + ] ].

comp-adj-word := norm-adj-word & inflecting-lex-rule &
  [ SYNSEM [ SAT #bool,
	     LOCAL [ CAT [ HEAD.MOD < [ SAT #bool ] >,
			   COMPARATIVE +,
			   QUANT - ] ],
	     LKEYS.KEYREL.ARG0.GRADE comparative ] ]. 


;indef-pl-adj-word := pl-adj-word. 

;samme bil, samme bilen, den samme bilen 
lex-adj-word := adj-word & norm-lex-item &
  [ SYNSEM.LOCAL [ CAT [ VAL.SISTER.LOCAL.CONT.HOOK.INDEX #1,
			 HEAD.MOD < [ LOCAL.CONT.HOOK.INDEX #1 ] > ],
		   CONT [ HOOK.LTOP #lbl,
			  RELS <! arg1-relation &
				[ LBL #lbl,
				  ARG0 #1 ] !> ] ] ].

verb-word-min := lex-rule & gap-unary & verb-lex-item & 
             bottom-gap-item & non-gen-word & no-slash & keyrel-lex-item &
  [ BOUNDARY -,
    INFLECTED +,
    KEY-ARG #keyarg,
    SYNSEM [ LOCAL [ CAT #cat & [ HEAD aux-verb ],
                     CONT [ HOOK #hook & [ INDEX event ] ] ],
	     LKEYS [ CNSTR #cnstr,
		     KEYREL #cnstr ],
             PHR - ],
    ROOT #root,
    DTR [ INFLECTED -,
          KEY-ARG #keyarg,
	  SYNSEM [ FIRST-WORD -,
		   LOCAL [ CAT #cat,
                         CONT.HOOK #hook ],
		   LKEYS.CNSTR #cnstr ],
          ROOT #root ] ].

verb-word := verb-word-min &
  [ ALTS #alts,
    DTR.ALTS #alts ].

non-imp-verb-word := verb-word &
  [ LINK-INPUT - ].

non-perf-verb-word := lexeme-to-word-rule & non-imp-verb-word.

finite-verb-word := non-perf-verb-word &
  [ SYNSEM.LOCAL [ CAT.HEAD.PERFPART -,
		   CONT [ HOOK.INDEX [ SF prop-cmpl-yn-wh_m_rel ],
			  MSG yes-no-ques_m_rel ] ] ].

non-fin-verb-word := lexeme-to-word-rule & non-imp-verb-word &
  [ SYNSEM.LOCAL [ CAT.ARGUMENT.LOCAL.CAT.CASE non-subj-case,
                   CONT.MSG no-msg_m_rel ] ].

aux-verb-word := finite-verb-word & infl-ltow-rule.

infl-ltow-verb-word := verb-word & infl-ltow-rule.
const-ltow-verb-word := verb-word & const-ltow-rule.

active-verb-word := verb-word.

non-inf-verb-word := verb-word.

pres-verb-word := active-verb-word & non-inf-verb-word & finite-verb-word &
[ SYNSEM.LOCAL.CONT.HOOK.INDEX.E.TENSE present ].

infl-pres-verb-word := infl-ltow-verb-word & pres-verb-word.
const-pres-verb-word := const-ltow-verb-word & pres-verb-word.

pret-verb-word := active-verb-word & non-inf-verb-word & finite-verb-word &
[ SYNSEM.LOCAL.CONT.HOOK.INDEX.E.TENSE pret ].

infl-pret-verb-word := infl-ltow-verb-word & pret-verb-word.
const-pret-verb-word := const-ltow-verb-word & pret-verb-word.

inf-verb-word := const-ltow-rule & non-fin-verb-word & non-perf-verb-word &
[ SYNSEM.LOCAL [ CAT.HEAD.PERFPART -,
		 CONT.HOOK.INDEX [ E.TENSE infin,
				   PERF - ] ] ].

perf-part-verb-word := non-fin-verb-word &
  [ SYNSEM.LOCAL.CAT [ CASE non-subj-case,
		       HEAD.PERFPART + ] ].

infl-perf-part-verb-word := infl-ltow-verb-word & perf-part-verb-word.
const-perf-part-verb-word := const-ltow-verb-word & perf-part-verb-word.

imp-verb-min := verb-word & uni-link &
  [ SYNSEM [ LOCAL [ CAT [ HEAD aux-verb & [ MESS #msg & command_m_rel ] ],
		     CONT [ HOOK.INDEX event & [ E.TENSE no_tense ],
			    MSG #msg ] ],
	     NON-LOCAL.SLASH <> ], 
    ARGS < lexeme >,
    C-CONT [ RELS <!!>,
	     HCONS <!!> ] ].

; imp-verb := imp-verb-min &
;   [ SYNSEM.LOCAL.CAT.ARGUMENT.LOCAL.CONT.HOOK.INDEX ref-ind & [ PNG.PN 2p ],
;     LINK-INPUT + ].

infl-imp-verb := imp-verb & inflecting-lex-rule &
  [ INFLECTED +,
    ARGS < [ INFLECTED - ] > ].

const-imp-verb := imp-verb & constant-lex-rule &
  [ INFLECTED +,
    ARGS < [ INFLECTED - ] > ].

non-wh-word := word-or-lexrule &
  [ SYNSEM.LOCAL.CAT.HEAD.MESS prop_m_rel ].

wh-word := non-gen-word & native-lex-item &
  [ SYNSEM.LOCAL [ CAT.HEAD.MESS wh-question_m_rel ] ].

adv-wh-word := adv-nocomp-word & wh-word &
  [ SYNSEM [ LOCAL [ CAT.HEAD.MOD < [ ] >,
		     CONT [ HOOK.INDEX #ind & event,
			    RELS <!  !>,
			    HCONS <! !> ] ],
	     LKEYS.KEYREL [ ARG0 #ind ] ] ].

def-suffix-det-word := det-word & non-wh-word.

no-def-suffix-det-word := det-word.

wh-det-word := no-def-suffix-det-word & indef-lex-item & wh-word &
  [ SYNSEM [ LOCAL.CAT.HEAD.MOD <>,
	     LKEYS.Q.QREL.PRED _hvilken_q_rel,
	     LINK link ] ].

comm-wh-det-word := wh-det-word & comm-item & sg-item.
neut-wh-det-word := wh-det-word & neut-item & sg-item.
pl-wh-det-word := wh-det-word & pl-item.

indef-art-det-word-min := indef-lex-item & no-def-suffix-det-word &
  [ SYNSEM [ LOCAL [ CAT [ HEAD.MESS prop_m_rel,
			   VAL.SISTER synsem,
			   QUANT + ],
		     CONT.HOOK.INDEX #ind & [ COGN-ST type-id ] ],
	     LKEYS [ Q.QREL.ARG0 #ind,
		     KEYREL [ ARG0 #ind ] ] ] ].

indef-art-det-word := indef-art-det-word-min.

indef-count-det := indef-art-det-word-min & sg-item &
  [ SYNSEM.LKEYS.KEYREL.ARG0.PNG.PN count ].

indef-mass-det := indef-art-det-word-min &
  [ SYNSEM.LKEYS.KEYREL.ARG0.PNG.PN mass ].

1-det-word := indef-art-lex-item & sg-item.
comm-indef-art-det-word := comm-item & indef-art-lex-item & sg-item & 
                           indef-art-det-word.
masc-indef-art-det-word := masc-item & 
                           indef-art-lex-item & indef-art-det-word &
                           sg-item.
fem-indef-art-det-word := fem-item & indef-art-lex-item & 
                          sg-item & indef-art-det-word.
neut-indef-art-det-word := neut-item & sg-item & indef-art-det-word &
                           indef-art-lex-item. ;
pl-indef-art-det-word := pl-item & indef-art-det-word. 
sg-indef-art-det-word := sg-item & indef-art-det-word. 

mass-det-word := indef-lex-item & no-def-suffix-det-word.

def-art-det-word := def-art-lex-item & def-suffix-det-word &
  [ SYNSEM.LOCAL.CAT.VAL.CMP2.MODIFIED xmod ].


comm-def-art-det-word := comm-item & def-art-det-word & sg-item.

neut-def-art-det-word := neut-item & def-art-det-word & sg-item. 

pl-def-art-det-word := pl-item & def-art-det-word. 

alle-det-word := pl-item & quant-word & 
  [ SYNSEM.LKEYS.Q.QREL every_q_relation ].

hver-det-word := sg-item & no-def-suffix-det-word &
  [ SYNSEM.LKEYS.Q.QREL every_q_relation ].

selve-det-word := def-suffix-det-word & def-lex-item &
  [ SYNSEM.LKEYS.Q.QREL.PRED _selve_q_rel ].

dem-det-word := def-suffix-det-word & dem-lex-item.
comm-dem-det-word := comm-item & dem-det-word & sg-item. 
neut-dem-det-word := neut-item & dem-det-word & sg-item.
pl-dem-det-word := pl-item & dem-det-word. 

continuative-item := sign.

continuative-word := continuative-item & keyrel-lex-item &
  [ SYNSEM [ LOCAL [ CONT.HOOK.LTOP #handle,
		     CAT [ HEAD continuative & [ MOD <> ],
			 VAL [ SISTER anti-synsem ],
			 STACK <> ],
		   CONT.RELS <! #relation & [ LBL #handle ] !> ],
	     LKEYS.KEYREL #relation ] ].

continuative-phrase := head-initial & start-item &
  [ SYNSEM [ LOCAL [ CAT #cat,
		     CONT.HOOK.LTOP #handle ],
	     LKEYS.KEYREL.LBL #handle ],
    ARGS < start-word &
	   [ SYNSEM.LOCAL.CAT #cat ],
	   word-or-lexrule &
	   [ SYNSEM.LOCAL [ CAT.HEAD continuative,
			    CONT.HOOK.LTOP #handle ] ] >,
    C-CONT [ RELS <!!>,
	     HCONS <!!> ] ].

;;;;;
;;;;;   BASIC PHRASES
;;;;;

;gap-word := non-gen-word.

bottom-gap-item := sign.

uni-link-min := sign &
  [ SYNSEM.LOCAL.CAT.VAL [ ARGFRAME #1,
			   CMP1.LINK #1,
			   CMP2.LINK #1,
			   CMP3.LINK #1,
			   CMP4.LINK #1,
			   PART #1 ] ].

uni-link := uni-link-min &
  [ SYNSEM.LOCAL.CAT [ HEAD.ELLIPSIS -,
		       INTRANS + ] ].

;;;;;
;;;;;   DETERMINER-NOUN RULE
;;;;;

nominal-phrase-min-min := basic-binary-phrase &
  [ BOUNDARY -,
    START -,
    SYNSEM [ LOCAL.CAT [ HEAD #head & adj-nominal &
			      [ NOM + ],
                         VAL [ ARGFRAME #frame,
			       SISTER #sis2 & [ SAT bool ],
			       CMP2 #arg2,
			       CMP4.MARKED - ], ;
                         CASE #case,
			 COMPARATIVE #grade,
			 STACK #stack ],
	     SAT #sat ],
    ARGS < [ BOUNDARY -,
	     SYNSEM [ LOCAL [ CAT [ HEAD adj-nominal,
				    VAL [ CMP2 #arg2 ],
				    CASE #case,
				    COMPARATIVE #grade,
				    STACK #stack ] ],
		      SAT #sat ] ],
	   word &
	   [ BOUNDARY -,
	     SYNSEM [ FIRST-WORD -,
			LOCAL [ CAT [ HEAD #head & adj-nominal,
				      VAL [ ARGFRAME #frame,
					    CMP2.LINK arg2-,
					    CMP3.LINK arg3-,
					    CMP4 [ LINK arg4-,
						   MARKED - ],
					    SISTER #sis2 ],
				      CASE #case ],
				CONT.HOOK [ INDEX ref-ind ] ],
			NON-LOCAL.SLASH <> ] ] >,
    C-CONT [ HCONS <!!> ] ].

nominal-phrase-min := nominal-phrase-min-min &
  [ SYNSEM.LKEYS [ Q #q ],
    ARGS < [ NEXTWORD #sister,
	     SYNSEM [ LOCAL.CAT.VAL.SISTER synsem,
		      LKEYS [ Q #q ] ] ],
	   [ SYNSEM #sister ]  > ].

; PH 2018-05-08: Unified KEYREL of second daughter with KEYREL of first
; daughter in order to let the relation go down the tree.
nominal-det-phrase := nominal-phrase-min &
  [ SYNSEM [ LOCAL [ CAT.HEAD nominal,
		     CONT.HOOK.INDEX #index ],
	     LKEYS [ KEYREL #keyrel & [ LBL #lbl,
					PRED #pred & atom,
					ARG0 #ind ],
		     ALTKEYREL #altkey ] ],
    ARGS < [ SYNSEM [ LOCAL [ CAT [ HEAD [ CARD-IN bool,
					   CARD-OUT #ci ],
				    VAL.SISTER #sister ],
			      CONT.HOOK.INDEX #index ],
		      LKEYS.KEYREL #keyrel & [ PRED #pred,
					       ARG0 #ind ],
		      MODIFIED notmod-or-rmod ] ],
	   [ SYNSEM #sister & [ LOCAL.CAT.HEAD [ CARD-IN #ci ],
				LKEYS [ KEYREL #keyrel &
					       [ LBL #lbl,
						 PRED #pred,
						 ARG0 #ind ],
					ALTKEYREL #altkey,
					Q.QEQ.LARG #lbl ] ] ] > ].

nominal-phrase := nominal-det-phrase & c-cont-rel-0 &
  [ SYNSEM.LOCAL.CAT.HEAD poss-card-noun ].


det-phrase := nominal-det-phrase &
  [ SYNSEM.LOCAL.CAT.HEAD det,
    ARGS < [ ], [ SYNSEM.LKEYS.Q.QREL #relation ] >,
    C-CONT.RELS <! #relation !> ].

measure-phrase := nominal-phrase-min-min &
  [ SYNSEM [ LOCAL.CAT.VAL.SISTER synsem,
	     LKEYS [ KEYREL #keyrel,
		     Q #q2,
		     ALTKEYREL #altkey ] ],
    ARGS < nominal-phrase &
	   [ SYNSEM.LKEYS [ KEYREL #keyrel & [ ARG0 #arg1 ],
			    Q.QREL #q ] ],
	   [ SYNSEM.LKEYS [ KEYREL #meas & [ PRED meas+,
					     ARG0 #arg0,
					     ARG1 #arg1 ],
			    ALTKEYREL #altkey,
			    Q #q2 & [ QREL.ARG0 #arg0 ] ] ] >,
    C-CONT.RELS <! #q, #meas !> ].

; PH 2018-05-08: Removed KEYREL.PRED generic_entity_rel constraint in
; order to allow for noun relations to go down in "den gode mannen smiler"
nominal-adj-phrase := nominal-phrase-min & 
  [ SYNSEM [ LOCAL [ CAT [ HEAD adj-andre-carddef & [ AGREE.DEFINITENESS #def,
						      CARD-OUT #card-out ],
			   VAL [ SISTER.LOCAL.CONT.HOOK.INDEX #ind ] ],
		     CONT.HOOK [ CONJ-IND #arg0,
				 INDEX #ind ] ],
	     LKEYS #lkeys ],
    ARGS < [ SYNSEM [ LKEYS #lkeys & [ KEYREL [ LBL #lbl,
						ARG0 #ind ] ],
		      LOCAL [ CAT.HEAD [ AGREE.DEFINITENESS #def,
					 CARD-OUT #card-out ],
			      CONT.HOOK.INDEX #ind ] ] ], 
	   [ SYNSEM [ LOCAL.CAT.HEAD.AGREE.DEFINITENESS #def,
		      LKEYS.KEYREL [ LBL #lbl,
				     PRED #pred,
				     ARG0 #arg0,
				     ARG1 #ind ] ] ] >,
    C-CONT.RELS <! [ PRED #pred,
		     ARG0 #arg0 & event,
		     LBL #lbl,
		     ARG1 #ind ] !> ].

;;;;;
;;;;;   CONSTRUCTION TYPES
;;;;;

subconstruction := sign &
  [ OUT cat &
        [ VAL.ARGFRAME #v ],
    IN cat &
        [ VAL.ARGFRAME #v ],
    MEANING relation ].

subconstruction-1-3 := subconstruction &
  [ IN cat &
        [ ARGUMENT.LOCAL.CONT.HOOK.INDEX individual ],
    MEANING relation ].

arg1-sign := subconstruction-1-3 &
  [ SYNSEM.--PHR-KEY arg1-relation,
    OUT.VAL [ CMP1 [ LINK arg1-,
		     LOCAL.CONT.HOOK.INDEX #index ],
              CMP2 #arg2,
              CMP3 #arg3,
              CMP4 #arg4,
	      PART #part ],
    IN [ VAL [ CMP1 #arg & [ LINK arg1+,
			     LOCAL.CONT.HOOK.INDEX #index ],
               CMP2 #arg2,
               CMP3 #arg3,
               CMP4 #arg4,
	       PART #part ],
         ARGUMENT #arg ],
    MEANING #rel,
    SYNSEM.LKEYS.CNSTR #rel & [ ARG1 #index ] ].

arg2-sign := subconstruction-1-3 &
  [ SYNSEM.--PHR-KEY arg2-relation,
    OUT.VAL [ CMP1 #arg1,
              CMP2.LINK arg2-,
              CMP3 #arg3,
              CMP4 #arg4,
	      PART #part ],
    IN [ VAL [ CMP1 #arg1,
	       CMP2 #arg & [ LINK arg2+,
			     LOCAL.CONT.HOOK.INDEX #index ],
	       CMP3 #arg3,
	       CMP4 #arg4,
	       PART #part ],
	 ARGUMENT #arg ],
    MEANING.ARG2 #index ].

arg3-sign := subconstruction-1-3 &
  [ SYNSEM.--PHR-KEY arg3-relation,
    OUT.VAL [ CMP1 #arg1,
              CMP2 #arg2,
              CMP3.LINK arg3-,
              CMP4 #arg4,
	      PART #part ],
    IN [ VAL [ CMP1 #arg1,
               CMP2 #arg2,
               CMP3 #arg & [ LINK arg3+,
			     LOCAL.CONT.HOOK.INDEX #index ],
               CMP4 #arg4,
	       PART #part ],
         ARGUMENT #arg ],
    MEANING.ARG3 #index ].

; arg4-sign := subconstruction &
;   [ SYNSEM.--PHR-KEY arg4-relation,
;     OUT.VAL [ CMP1 #arg1,
;               CMP2 #arg2,
;               CMP3 #arg3,
;               CMP4 [ LINK arg4-,
; 		     LOCAL.CONT.HOOK #hook ],
; 	      PART #part ],
;     IN [ VAL [ CMP1 #arg1,
;                CMP2 #arg2,
;                CMP3 #arg3,
;                CMP4 #arg & [ LINK arg4+,
; 			     LOCAL.CONT.HOOK #hook ],
; 	       PART #part ],
;          ARGUMENT #arg & [ LOCAL.CONT.HOOK.LTOP #handle ] ],
;     MEANING.ARG4 #handle ].


;;; Rule types added for the vpidiom paper (2014-04-15; ph)

; PH 2017-08-25: Removed PN link between CMP1 and second daughter.
; Did not account for "Jeg gikk konkurs"
idiom-struc := binary-phrase &
  [ START -,
    LINK-INPUT -,
    SYNSEM [ LOCAL [ CAT [ HEAD #head & compl-verb,
			   VAL [ CMP1 #cmp1 & [ LINK arg1- ],
				 PART #part,
				 ARGFRAME #argframe ],
			   ARGUMENT #arg,
			   STACK #stack,
			   VBL #vbl ],
		     CONT #cont,
		     TOPIC #topic ],
	     NON-LOCAL #nl,
	     LKEYS #lkeys ],
    ARGS < [ SYNSEM [ LOCAL [ CAT [ HEAD #head,
				    VAL [ CMP1 #cmp1,
					  PART #part,
					  ARGFRAME #argframe ],
				    ARGUMENT #arg,
				    STACK #stack,
				    VBL #vbl ],
			      CONT #cont,
			      TOPIC #topic ],
		      NON-LOCAL #nl,
		      LKEYS #lkeys ],
	     BOUNDARY - ], 
           [ SYNSEM [ LOCAL [ CAT.HEAD.AGREE.DEFINITENESS indef ],
		      LKEYS [ KEYREL.PRED #argframe,
			      Q.QREL.PRED anti-quant_m_rel ] ] ] >,
    BOUNDARY - ].

arg2-idiom-struc := idiom-struc &
  [ SYNSEM [ LOCAL [ CAT [ VAL [ CMP2 [ LINK arg2-,
					LOCAL #local ],
				 CMP3 #cmp3,
				 CMP4 #arg4 & [ MARKED - ] ] ] ] ],
    ARGS < [ SYNSEM.LOCAL.CAT.VAL [ CMP2 [ LINK #idiomform & arg2+ & idiomform,
					   LOCAL #local ],
				    CMP3 #cmp3,
				    CMP4 #arg4 ] ], 
	   [ SYNSEM [ LOCAL.CAT.HEAD noun-refl,
	              LKEYS.KEYREL.PRED #idiomform ] ] > ].

arg3-idiom-struc := idiom-struc &
  [ SYNSEM [ LOCAL [ CAT [ VAL [ CMP2 #arg2 & [ LINK arg2+ ],
				 CMP3 [ LINK arg3-,
					LOCAL #local ],
				 CMP4 #arg4 ] ] ] ],
    ARGS < [ SYNSEM.LOCAL.CAT.VAL [ CMP2 #arg2,
				    CMP3 [ LINK #idiomform & arg3+ & idiomform,
					   LOCAL #local ],
				    CMP4 #arg4 ] ], 
	   [ SYNSEM [ LOCAL.CAT.HEAD noun-refl,
		      LKEYS.KEYREL.PRED #idiomform ] ] > ].

; PH 2020-06-23: Removed the CMP2.LINK arg2- constraint in order to allow for
; Hun får med seg isen
arg4-idiom-struc := idiom-struc &
  [ SYNSEM [ LOCAL [ CAT [ VAL [ CMP2 #cmp2,
				 CMP3 #cmp3,
				 CMP4 [ LINK arg4-,
					MARKED -,
					LOCAL #local ] ] ] ] ],
    ARGS < [ SYNSEM.LOCAL.CAT.VAL [ CMP2 #cmp2,
				    CMP3 #cmp3,
				      CMP4 [ LINK #idiomform & arg4+ & idiomform,
					     MARKED +,
					     LOCAL #local ] ] ], 
           [ SYNSEM [ LOCAL.CAT.HEAD noun-refl,
		      LINK #idiomform ] ] > ].


arg4-sign := subconstruction &
  [ SYNSEM.--PHR-KEY arg4-relation,
    OUT.VAL [ CMP1 #arg1,
              CMP2 #arg2,
              CMP3 #arg3,
              CMP4 [ LINK arg4-,
		     LOCAL.CONT.HOOK #hook ],
	      PART #part ],
    IN [ VAL [ CMP1 #arg1,
               CMP2 #arg2,
               CMP3 #arg3,
               CMP4 #arg & [ LINK arg4+,
			     LOCAL.CONT.HOOK #hook ],
	       PART #part ],
         ARGUMENT #arg & [ LOCAL.CONT.HOOK.INDEX #index ] ],
    MEANING.ARG4 #index ].

arg4-emb-selected-phrase := arg4-val-min & val-embedded &
  [ SYNSEM.LOCAL.CAT.STACK.FIRST [ LOCAL.CAT #out & [ HEAD adj-compl-nominal-verb,
					       VAL.CMP4.LOCAL #loc ],
				   NON-LOCAL #nl ],
    ARGS < [ SYNSEM [ LOCAL.CAT #in & [ VAL.CMP4 [ LOCAL #loc & [ CONT.HOOK.INDEX #index ]
,
					   MARKED + ] ],
		      NON-LOCAL #nl,
		      LKEYS.KEYREL.ARG4 #index ] ],
	   [  ] >,
    IN #in,
    OUT #out ].

arg4-emb-sel-phrase := arg4-emb-selected-phrase &
  [ ARGS < [ SYNSEM.LOCAL.CAT.VAL.CMP4.LINK 4np ], [] > ].

arg4-emb-sel-np-phrase := arg4-emb-sel-phrase & non-pred-val-emb & nom-embedded &
  [ ARGS < [], [ SYNSEM [ LOCAL.CAT.HEAD nominal ] ] > ].

arg4-emb-sel-adj-phrase := arg4-emb-sel-phrase & adj-embedded-val &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX #ind,
    ARGS < [ SYNSEM.LKEYS.KEYREL.ARG4 #ind ], [ SYNSEM [ LOCAL.CAT.HEAD adj,
							 LKEYS.Q.QREL.PRED quant_m_rel ] ] > ].


; arg4-emb-sel-np-phrase := arg4-emb-selected-phrase &
;   [ SYNSEM.LKEYS #keyrel,
;     ARGS < [ SYNSEM.LOCAL.CAT.VAL.CMP4.LINK 4np ],
; 	   [ SYNSEM [ LOCAL.CAT.HEAD nominal,
; 		      LKEYS #keyrel ] ] > ].


arg4-emb-pred-phrase := arg4-val-min & val-embedded &
  [ LINK-INPUT -,
    BOUNDARY -,
    SYNSEM [ LOCAL.CAT [ VAL.CMP4.LINK arg4-,
			 STACK.FIRST [ LOCAL.CAT #out & [ HEAD compl-verb,
					     VAL.CMP4.LOCAL #loc ],
				     NON-LOCAL #nl ] ],
	     NON-LOCAL.SLASH <> ],
    ARGS < [ SYNSEM [ LOCAL.CAT #in & [ VAL.CMP4 [ LINK arg4+,
						   LKEYS.KEYREL.ARG1 #arg1,
						   LOCAL #loc,
						   MARKED - ] ],
		      NON-LOCAL #nl,
		      LKEYS.KEYREL #rel & [ ARG4 #ind ] ] ],
	   adj-word-min &
	   [ SYNSEM [ LOCAL #loc & [ CAT.VAL.SISTER.LKEYS.KEYREL.ARG0.COGN-ST type-id,
			      CONT.HOOK.INDEX individual ],
		      LKEYS.KEYREL [ ARG0 #ind & event,
				     ARG1 #arg1 ] ] ] >,
    IN #in,
    OUT #out,
    MEANING #rel ].

arg4-cp-phrase := arg4-val-min & compl-phrase &
  [ ARGS.FIRST.SYNSEM.LOCAL.CAT.VAL.CMP4 [ LINK 4cp,
					   LOCAL.CAT.HEAD subcompl ] ].

arg4-emb-sel-cp-phrase := arg4-emb-selected-phrase & arg4-cp-phrase.

arg4-np-phrase := arg4-val-min &
  [ ARGS.FIRST.SYNSEM.LOCAL.CAT.VAL.CMP4 [ LINK 4np,
					   LOCAL.CAT.HEAD nominal ] ].

;arg4-emb-np-phrase := arg4-emb-pred-phrase & arg4-np-phrase.

arg4-ap-phrase := arg4-val-min &
  [ SYNSEM.LOCAL.CAT.VAL.SISTER anti-synsem,
    ARGS < [ SYNSEM [ LOCAL.CAT [ HEAD.AGREE.DEFINITENESS def,
				  VAL.CMP4 [ LOCAL [ CAT.HEAD adj ],
					     LINK 4ap ] ] ] ],
	   [ SYNSEM.LKEYS.KEYREL #rel ] >,
    C-CONT [ RELS <! #rel !>,
	     HCONS <!!> ] ].

; PH 2016-05-11: Added anti-quant_m_rel constraint in order to prevent
; predicatives from undergoing the gen-ent-scope-rule.
arg4-emb-ap-phrase := arg4-emb-pred-phrase & arg4-ap-phrase &
  [ SYNSEM.LKEYS.Q.QREL.PRED anti-quant_m_rel ].

arg4-ap1-phrase := arg4-emb-ap-phrase &
  [ ARGS < [ SYNSEM.LKEYS.KEYREL [ PRED arg2-,
				   ARG1 #arg1 ] ],
	   [ SYNSEM.LKEYS.KEYREL [ ARG1 #arg1 ] ] > ].

arg4-ap2-phrase := arg4-emb-ap-phrase &
  [ ARGS < [ SYNSEM.LKEYS.KEYREL [ PRED 2np,
				   ARG2 #arg2 ] ],
	   [ SYNSEM.LKEYS.KEYREL [ ARG1 #arg2 ] ] > ].


;;;;;
;;;;;   VALENCE PHRASES/IRULES
;;;;;

val-or-mod-sign := headed-phrase-or-lexrule & c-parameter &
  [ CONJ #conj,
    BOUNDARY -,
    SYNSEM [ LOCAL [ CAT [ CASE #case2,
			   STACK #1,
			   AAIF #case,
			   C #c ],
		     TOPIC #topic,
		     CONT.MSG predsort ],
	     LKEYS #lk,
	     LKEYS.CNSTR #phrkey ],
    HD-DTR [ CONJ #conj,
	     SYNSEM [ LOCAL [ CAT [ STACK #1,
				    CASE #case2,
				    AAIF #case,
				    C #c ],
			      TOPIC #topic,
			      CONT.MSG predsort ],
		      LKEYS #lk,
		      LKEYS.CNSTR #phrkey ],
	     LINK-INPUT - ],
    LINK-INPUT - ].

val-min-min := val-or-mod-sign &
  [ BOUNDARY -,
    SYNSEM [ LOCAL [ CAT [ VAL.ARGFRAME #v,
                         VBL #verbal ],
                     CONT.MSG message_m_rel ],
             MODIFIED xmod ],
    HD-DTR [ BOUNDARY -,
	     SYNSEM [ LOCAL [ CAT [ VBL #verbal,
				    VAL.ARGFRAME #v,
				    ARGUMENT [ SAT +,
					       LINK #v,
					       LOCAL [ CAT [ QUANT bool ],
						       CONT.HOOK.INDEX #parg ] ] ],
			      CONT.HOOK.PARG #parg ],
		      MODIFIED xmod ] ] ].

val-min := val-min-min &
  [ SYNSEM.LOCAL.CAT.ARGUMENT.LOCAL.CAT.CASE non-subj-case ].

; PH 2017-09-08: Took out the link between LTOP and CNSTR.LBL in order to
; allow for these not to be linked in case of auxiliaries where the
; LTOP comes from the auxiliary and the KEYREL comes from the main verb.
basic-val := val-min & subconstruction &
  [ SYNSEM [ LOCAL [ CAT #out & [ CASE case,
				  VBL #vbl,
				  VAL.PART #part ],
                     CONT [ HOOK.LTOP handle,
                            MSG #msg ] ],
             LKEYS.CNSTR #c-rel,
             PHR + ],
    ARGS.FIRST [ SYNSEM [ LOCAL [ CAT #in & [ VAL.PART #part,
					      ARGUMENT.LKEYS.Q.QREL.PRED quant_m_rel,
					      VBL #vbl ],
				  CONT.MSG #msg ],
			  LKEYS.CNSTR #c-rel ] ],
    MEANING #c-rel & [ LBL handle ],
    IN #in,
    OUT #out ].

binary-valence-phrase-min := binary-nexus-phrase & head-initial & 
                         binary-headed-gap-phrase & comp-copy-phrase &
  [ START -,
    SYNSEM phr-synsem &
	  [ LOCAL.CAT.C-COGN-ST #cs ],
    HD-DTR.SYNSEM.LOCAL.CAT.ARGUMENT #arg,
    NH-DTR.SYNSEM #arg & [ CLITIC -,
			   LOCAL.CONT.HOOK.INDEX.COGN-ST #cs ] ].

binary-valence-phrase := binary-valence-phrase-min.

extr-phrase := head-compositional & val-or-mod-sign &
  [ CONJ no-conj,
    SYNSEM phr-synsem &
	   [ FIRST-WORD #fw,
	     LOCAL.CAT.HEAD [ MOD list,
			      RESTRICTED bool ],
	     NON-LOCAL.SLASH <>,
	     LOCAL.NEG-OUT #neg,
	     LKEYS #lkeys ],
    HD-DTR.SYNSEM [ FIRST-WORD #fw,
		    EXTR +,
		    NON-LOCAL.SLASH <[]>,
		    LOCAL.NEG-OUT #neg,
		    MODIFIED notmod,
		    LKEYS #lkeys ],
    LINK-INPUT - ].

unary-extr-phrase := extr-phrase & head-only & unary-phrase.

; PH 2017-03-31: Removed HD-DTR ARGUMENT non-canonical constraint.
; PH 2016-02-04: Changed CASE link path from CASE to CASE.SU in order
; to get VP coordination:
; Jeg våknet og ble gitt en sjokolade.
valence-extr-phrase-min := extr-phrase &
  [ HD-DTR [ SYNSEM [ LOCAL.CAT.ARGUMENT [ LOCAL [ CAT [ HEAD #head,
						       CASE.SU #case,
						       VAL #val,
						       QUANT #q ],
						 AGR #agr,
						 CONT #cont ] ],
		    NON-LOCAL.SLASH < [ CAT [ HEAD #head,
					      CASE.SU #case,
					      VAL #val,
					      QUANT #q ],
					AGR #agr,
					CONT #cont ] > ] ] ].

valence-extr-phrase := valence-extr-phrase-min & unary-extr-phrase &
  [ HD-DTR #first & [ SYNSEM [ LOCAL.CAT.C -,
		    NON-LOCAL.SLASH < [ CONT.HOOK.INDEX event-or-ref-index,
					CAT.CASE case,
					EXTR-LINK #link ] >,
		    LKEYS [ KEYREL #rel & [ PRED #link ],
			    CNSTR #rel ] ] ],
    ARGS.FIRST #first,
    C-CONT [ RELS <! !>,
	     HCONS <!!> ] ].

bin-val-extr-phrase := valence-extr-phrase-min & head-initial &
  [ NH-DTR float-quant-word ].

valence-word := inflecting-lex-rule & non-gen-word & keyrel-lex-item & 
		basic-val & gap-unary &
  [ HD-DTR #2 & 
	   [ SYNSEM.LOCAL.CAT.ARGUMENT.LOCAL.CONT.HOOK [ LTOP #hndl,
							 INDEX #ind & ref-ind ],
	     NEEDS-AFFIX bool ],
    C-CONT [ RELS <! [ LBL #hndl,
		       ARG0 #ind ], 
		   pronoun-q-relation &
		   [ ARG0 #ind,
		     RSTR #harg ] !>,
	     HCONS <! [ HARG #harg ] !> ],
    INFLECTED #1 & +,
    DTR #2,
    INFLECTED #1 ].

embedded-phrase-min-min := phrase &
  [ SYNSEM [ LOCAL.CAT [ STACK < [ LOCAL [ CAT [ HEAD #head,
						 VAL.PART #part,
						 QUANT #quant ],
					   CONT [ HOOK #hook,
						  MSG #msg ] ],
				   LKEYS #lkeys ] . #stack > ] ],
    ARGS < [ SYNSEM [ LOCAL [ CAT [ HEAD #head,
				    VAL.PART #part,
				    STACK #stack,
				    QUANT #quant ],
			      CONT [ HOOK #hook,
				     MSG #msg ] ],
		      LKEYS #lkeys ] ], ... > ].

embedded-phrase-min := embedded-phrase-min-min &
  [ START - ].
	     

reg-binary-emb-phrase := embedded-phrase-min &
  [ SYNSEM.LOCAL [ CAT [ HEAD #head,
			 VAL valence,
			 CASE #case,
			 ARGUMENT #arg,
			 VBL #vbl,
			 COMPARATIVE #cmp,
			 QUANT #q,
			 AAIF #aaif,
			 STACK < [ LOCAL.CAT.VAL #val2 ] , ... > ],
		   CONT [ HOOK #hook,
			  MSG #msg ] ], ;
    ARGS < [ SYNSEM.LOCAL.CAT.VAL #val2 ], 
	   [ SYNSEM.LOCAL [ CAT [ HEAD #head,
				  VAL [ ARGFRAME #1,
					CMP1.LINK #1,
					CMP2.LINK #1,
					CMP3.LINK #1,
					CMP4.LINK #1,
					PART #1 ],
				  CASE #case,
				  ARGUMENT #arg,
				  VBL #vbl,
				  COMPARATIVE #cmp,
				  QUANT #q,
				  AAIF #aaif,
				  STACK < > ],
			    CONT [ HOOK #hook,
				   MSG #msg ] ] ] > ].

; PH 2019-01-31: Removed the STACK AAIF - constraint in order to allow
; for sentence adverbials after nominals: "at han ikke smilte"
embedded-phrase := embedded-phrase-min &
  [ SYNSEM.LOCAL.CAT [ STACK < [ LOCAL.CAT.AAIF bool ], ... > ] ].

c-parameter := phrase &
  [ ARGS < [ SYNSEM.LOCAL.CAT.C - ], ... > ].

; Abstracting out the case value of the argument of the element on the stack
val-emb-stack-arg := phrase &
  [ SYNSEM.LOCAL.CAT.STACK.FIRST.LOCAL.CAT.ARGUMENT.LOCAL.CAT.CASE non-subj-case ].
; DEBUG 2013-11-24: removed link between STACK.NON-LOCAL and 
; ARGS.FIRST.NON-LOCAL
neg-embedded-phrase := embedded-phrase-min &
    [ SYNSEM.LOCAL [ CAT.STACK < [ LOCAL.NEG-OUT #neg-in ], ... >,
		     NEG-OUT #negout ],
      ARGS < [ SYNSEM.LOCAL.NEG-OUT #neg-in ], 
	     [ SYNSEM.LOCAL [ NEG-IN #neg-in,
			      NEG-OUT #negout ] ] > ].


val-embedded := binary-phrase & subconstruction &
		c-parameter & val-emb-stack-arg & neg-embedded-phrase &
  [ CONJ no-conj,
    LINK-INPUT -,
    SYNSEM [ LOCAL [ CAT [ HEAD #head,
			   VAL #val,
			   CASE #case,
			   STACK < [ LOCAL [ CAT #out & 
						 [ VBL #m,
						   ARGUMENT.LOCAL.CAT.CASE case,
						   C #c ],
					     CONT.HOOK #cont,
					     AGR #agr,
					     TOPIC #top ],
				     LKEYS #lkeys ] . #rest >,
			   QUANT #quant,
			   COMPARATIVE #com ],
		     CONT.HOOK.LTOP #ltop ],
	     MODIFIED xmod ],
    ARGS < [ CONJ no-conj,
	     SYNSEM [ LOCAL [ CAT #in & [ HEAD adj-adv-compl-noun-prep-verb,
					  VAL.ARGFRAME #link,
					  ARGUMENT #arg,
					  VBL #m,
					  STACK #rest,
					  C #c ],
			      CONT.HOOK #cont,
			      AGR #agr,
			      TOPIC #top ],
		      LKEYS #lkeys & [ KEYREL #rel,
				       CNSTR #rel ] ],
	     BOUNDARY -,
	     LINK-INPUT - ], 
	   word & 
	   [ SYNSEM #arg & [ LOCAL [ CAT [ HEAD #head,
					   VAL #val,
					   QUANT #quant,
					   CASE #case,
					   COMPARATIVE #com ],
				     CONT.HOOK [ LTOP #ltop,
						 INDEX event-or-ref-index ] ],
			     LINK #link ] ] >,
    IN #in,
    OUT #out,
    MEANING #rel ].

; PH 2017-08-18: added link to SISTER.INDEX in order to get correct semantics
; for "Jon beundrer en dyr vase."
nom-embedded-val-min := val-embedded &
  [ SYNSEM [ LOCAL.CAT [ HEAD adj-nominal,
			 STACK.FIRST.NON-LOCAL #nl,
			 QUANT #q ],
	     NON-LOCAL.SLASH <> ],
    ARGS < [ SYNSEM [ LOCAL.CAT.ARGUMENT [ LINK nom+,
					   LOCAL.CAT.QUANT #q ],
		      NON-LOCAL #nl ] ],
	   [ ] > ].

; PH 2019-03-20: The generator does not work if the CARG of the KEYREL
; is unified wiht the CARG of the relation in C-CONT.
nom-embedded := embedded-phrase & uni-link &
  [ SYNSEM [ LOCAL.CAT.HEAD nominal,
	     LKEYS #lk & [ KEYREL #rel & [ LBL #larg,
				    PRED #pred & atom,
				    ARG0 #arg0 & [ COGN-ST #cn ] ],
			   Q.QREL [ PRED quant_m_rel,
				    ARG0 #arg0,
				    RSTR #harg ],
			   ALTKEYREL.ARG0.COGN-ST #cn ] ],
    ARGS < [], [ SYNSEM.LKEYS #lk ] >,
    C-CONT [ RELS <! #rel & [ LBL #larg,
		       PRED #pred,
		       ARG0 #arg0 ] !>,
	     HCONS <! [ HARG #harg,
			LARG #larg ] !> ] ].

comp-embedded := embedded-phrase & uni-link &
  [ SYNSEM [ LOCAL.CAT.HEAD subcompl-infcompl,
	     LKEYS.KEYREL [ LBL #lbl,
			    ARG0 #ind ] ],
    ARGS < [], [ SYNSEM.LKEYS.KEYREL [ LBL #lbl,
				       ARG0 #ind ] ] >,
    C-CONT [ RELS <! !>,
	     HCONS <! !> ] ].

nom-embedded-val := nom-embedded-val-min & nom-embedded.

; PH 2017-08-22: Added a HEAD adj-prep-verb constraint on the first
; daughter in order to restrict the application of the rule.
; PH 2021-11-08: Added quant_m_rel constraint in order to block definite
; adjectives from initiating an argument
adj-embedded-val := nom-embedded-val-min &
  [ SYNSEM [ LOCAL [ CAT [ HEAD adj-andre-carddef,
			   VAL.ARGFRAME adj+ ],
		     CONT.HOOK [ LTOP #lbl,
				 INDEX #ind ] ],
	     LKEYS [ KEYREL #keyrel & [ LBL #lbl,
					ARG0 #ind ],
		     ALTKEYREL [ LBL #lbl,
				 PRED generic_entity_rel,
				 ARG0 #ind ],
		     Q.QREL [ PRED udef_q_rel,
			      ARG0 #ind,
			      RSTR #harg ] ] ],
    ARGS <[ SYNSEM [ LOCAL.CAT.HEAD adj-prep-verb ] ],
	  [ SYNSEM.LKEYS [ KEYREL #adjrel & [ LBL #lbl,
					    ARG0 event,
					    ARG1 #ind ],
			   Q.QREL.PRED quant_m_rel ] ] >,
    C-CONT [ RELS <! #keyrel, #adjrel !>,
	     HCONS <! [ HARG #harg,
			LARG #lbl ] !> ] ].

god_prd := predsort.
_god_a_rel := god_prd & prp- & arg1+ & arg2- & arg3- & arg4- & prt- & adj+ & atom.

forskjellig_prd := predsort.
_forskjellig*fra-cp_rel := forskjellig_prd & arg1- & arg2- & arg3- & 4cp & fra_prp & prt-.
_forskjellig*fra-ip1_rel := forskjellig_prd & arg1- & arg2- & arg3- & 4ip1 & fra_prp & prt-.
_forskjellig*fra-np_rel := forskjellig_prd & arg1- & arg2- & arg3- & 4np & fra_prp & prt-.
_forskjellig_a_rel := forskjellig_prd & prp- & arg1+ & arg2- & arg3- & arg4- & prt- & adj+ & atom.

no-nom-embedded-val := val-embedded &
  [ SYNSEM [ LOCAL.CAT.HEAD adj-adv-compl-prep-sadv-verb,
	     NON-LOCAL #nl ],
    ARGS.FIRST.SYNSEM.NON-LOCAL #nl ].

non-pred-val-emb := val-embedded &
  [ SYNSEM.LKEYS.Q.QREL.PRED quant_m_rel ].

; PH 2016-06-23: Took out HD-DTR...TENSE finite constraint in order to account for
; "Han hevder jeg at bør smile."
arg1-val := basic-val & arg1-sign & subj-val &
  [ SYNSEM.LOCAL.CAT [ HEAD compl-verb,
		       ARGUMENT.LOCAL.CAT.CASE non-subj-case,
		       INTRANS + ],
    HD-DTR.SYNSEM.LOCAL [ CAT.VAL [ ARGFRAME #a1,
				    CMP1 [ LINK #a1 & arg1+,
					   LOCAL [ CAT [ CASE arg1-su-case ] ] ] ] ] ].

c-cont-rel-0 := phrase &
  [ C-CONT [ RELS <! !>,
	     HCONS <!!> ] ].

; DEBUG 2013-11-21- removed link ARGS.FIRST.ARG.LOCAL and ARGS.FIRST.TOPIC 
subj-val := phrase &
  [ SYNSEM.LOCAL.CAT [ ARGUMENT.LOCAL.CAT.CASE non-subj-case,
		       INTRANS + ],
    ARGS.FIRST.SYNSEM.LOCAL [ CAT [ HEAD compl-verb &
					 [ SU-IND #ind ],
				    ARGUMENT [ LOCAL local-min &
						     [ CAT.CASE subj-case,
						       CONT.HOOK.INDEX #ind ],
					       LKEYS.Q.QREL.PRED non-bare_q ] ],
			      TOPIC local-min ] ].

; DEBUG 2013-11-22: Took out the constraint
; SYNSEM.LOCAL.CAT.VBL.LOCAL.CONT.HOOK.INDEX.E.TENSE infin
subj-extr := subj-val & valence-extr-phrase &
  [ SYNSEM.LOCAL.CAT.VBL.LOCAL.CONT.HOOK.INDEX.E.TENSE tense ].

non-subj-val := phrase &
  [ ARGS.FIRST.SYNSEM.LOCAL.CAT [ ARGUMENT.LOCAL.CAT.CASE non-subj-case,
				  VBL anti-synsem ] ].

non-subj-extr := non-subj-val & valence-extr-phrase.

arg1-phrase := arg1-val & binary-valence-phrase & c-cont-rel-0.
arg1-extr-phrase := arg1-val & subj-extr &
  [ ARGS < [ SYNSEM [ NON-LOCAL.SLASH < [ EXTR-LINK #link ] >,
		      LOCAL.CAT.ARGUMENT.LINK #link ] ] > ].
1np-extr-phrase := arg1-extr-phrase &
  [ ARGS < [ SYNSEM [ LOCAL.CAT.ARGUMENT.LINK 1np,
		      NON-LOCAL.SLASH < [ CAT.HEAD adj-nominal &
						   [ NOM + ] ] > ] ] > ].
1cp-extr-phrase := arg1-extr-phrase &
  [ ARGS < [ SYNSEM [ LOCAL.CAT.ARGUMENT.LINK 1cp,
		      NON-LOCAL.SLASH < [ CAT.HEAD atfull ] > ] ] > ].
arg1-quant-extr-phrase := arg1-val & bin-val-extr-phrase & c-cont-rel-0.
arg1-word := arg1-val & valence-word.

arg1-emb-phrase := arg1-sign & non-pred-val-emb & subj-val & nom-embedded-val-min & 
  [ SYNSEM.LOCAL.CAT [ HEAD adj-nominal,
		       STACK.FIRST.LOCAL.CAT.INTRANS #intrans ],
    ARGS < [ SYNSEM.LOCAL.CAT [ ARGUMENT.LOCAL.CAT.CASE subj-case,
				INTRANS #intrans ] ],
	   [ SYNSEM.LOCAL.CAT.CASE subj-case ] >].

arg1-emb-nom-phrase := arg1-emb-phrase & nom-embedded-val.
arg1-emb-adj-phrase := arg1-emb-phrase & adj-embedded-val &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX #ind,
    ARGS < [ SYNSEM.LKEYS.KEYREL.ARG1 #ind ], [] > ].

arg1-3m-word := arg1-word &
  [ HD-DTR.SYNSEM.LOCAL.CAT.ARGUMENT.LOCAL.CONT.HOOK.INDEX.PNG [ PN 3sg,
								 GEN masc ],
    C-CONT.RELS.LIST.FIRST.PRED "han_pron_rel" ].

arg1-3f-word := arg1-word &
  [ HD-DTR.SYNSEM.LOCAL.CAT.ARGUMENT.LOCAL.CONT.HOOK.INDEX.PNG [ PN 3sg,
								 GEN fem ],
    C-CONT.RELS.LIST.FIRST.PRED "hun_pron_rel" ].

; PH 2016-05-12: Added ARG2 QREL quant_m_rel constraint in order to avoid
; indefinite adjectives as arguments.
arg2-val-min := arg2-sign &
  [ ARGS.FIRST.SYNSEM.LOCAL.CAT.VAL.CMP2 [ LOCAL.CAT [ HEAD adj-subcompl-infcompl-noun-prep,
						       CASE arg2-case ],
					   LKEYS.Q.QREL.PRED quant_m_rel ] ].
arg2-non-su-val := non-subj-val & arg2-val-min &
  [ ARGS < [ SYNSEM.LOCAL.CAT.VAL.CMP3.LINK arg3- ], ... > ].

arg2-val := arg2-val-min &
  [ SYNSEM.LOCAL.CAT [ HEAD adv-compl-prep-verb,
		       VAL.CMP2.LOCAL #loc ],
    ARGS.FIRST.SYNSEM.LOCAL.CAT.VAL.CMP2.LOCAL #loc ].

binary-compositional-phrase := basic-binary-phrase &
  [ ARGS < [], [ SYNSEM.LKEYS.KEYREL.PRED atom ] > ].

; PH 2019-02-28: Removed the supertype binary-compositional-phrase in order
; to make the rule work in generation
; ex: Sover mannen?
arg2-emb-phrase := arg2-val-min & non-pred-val-emb &
  [ SYNSEM.LOCAL.CAT [ STACK.FIRST.LOCAL.CAT [ HEAD compl-prep-verb,
					       VAL.CMP2.LOCAL #loc ],
		       VAL.CMP4.MARKED - ],
    ARGS < [ SYNSEM.LOCAL.CAT [ VAL.CMP2.LOCAL #loc ] ],
	   [ ] > ].

wh-min := non-subj-val & val-embedded &
  [ SYNSEM [ LOCAL.CAT [ HEAD adj-adv-nominal,
			 STACK.FIRST.NON-LOCAL #nl,
			 QUANT #q ],
	     NON-LOCAL.SLASH <> ],
    ARGS < [ SYNSEM [ LOCAL.CAT.ARGUMENT [ LOCAL.CAT.QUANT #q ],
		      NON-LOCAL #nl,
		      MODIFIED notmod ] ], [ ] > ].

wh-phrase := wh-min &
  [ SYNSEM.LOCAL.CAT.HEAD adv-nominal,
    ARGS < [], wh-word & [ SYNSEM.LKEYS.KEYREL #rel ] >,
    C-CONT [ RELS <! #rel !>,
	     HCONS <!!> ] ].

wh-mod-struc := wh-min &
  [ SYNSEM.LOCAL.CAT.HEAD #head & adj,
    ARGS < [], [ SYNSEM.LOCAL.CAT [ HEAD #head & [ AGREE.DEFINITENESS indef ],
				    VAL.SISTER.LKEYS.KEYREL.ARG0.COGN-ST type-id ] ] > ].

arg2-wh-min := wh-min & arg2-sign &
  [ ARGS < [ SYNSEM [ LOCAL.CAT.ARGUMENT [ LINK 2wh ],
		      LKEYS.KEYREL.ARG2 #arg2 ] ],
	   [ SYNSEM.LKEYS.KEYREL.ARG0 #arg2 ] > ].

arg2-wh-phrase := wh-phrase & arg2-wh-min.
arg2-wh-mod-struc := wh-mod-struc & arg2-wh-min.

arg4-wh-min := wh-min & arg4-sign &
  [ ARGS < [ SYNSEM [ LOCAL.CAT.ARGUMENT [ MARKED + ],
		      LKEYS.KEYREL [ PRED 4wh,
				     ARG4 #arg4 ] ] ],
	   [ SYNSEM.LKEYS.KEYREL #rel & [ ARG0 #arg4 ] ] >,
    C-CONT [ RELS <! #rel !>,
	     HCONS <!!> ] ].

arg4-wh-phrase := wh-phrase & arg4-wh-min.
arg4-wh-mod-struc := wh-mod-struc & arg4-wh-min.

arg2-nom-phrase := arg2-val-min & nom-embedded-val-min &
  [ ARGS.FIRST.SYNSEM.LOCAL.CAT.ARGUMENT.LINK 2np ].

arg2-emb-su-phrase := subj-val & arg2-emb-phrase.
arg2-emb-nom-su-phrase := arg2-emb-su-phrase & arg2-nom-phrase & nom-embedded-val.

arg2-emb-adj-phrase := adj-embedded-val &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX #ind,
    ARGS < [ SYNSEM.LKEYS.KEYREL.ARG2 #ind ], [] > ].

arg2-emb-adj-su-phrase := arg2-emb-su-phrase & arg2-nom-phrase & arg2-emb-adj-phrase.

arg2-emb-no-nom-su-phrase := no-nom-embedded-val & arg2-emb-su-phrase.
arg2-emb-non-su-phrase := arg2-non-su-val & arg2-emb-phrase &
  [ ARGS.REST.FIRST.SYNSEM.LOCAL.CAT.CASE non-subj-case ].
arg2-emb-nom-non-su-phrase := arg2-emb-non-su-phrase & arg2-nom-phrase & nom-embedded-val.
arg2-emb-adj-non-su-phrase := arg2-emb-non-su-phrase & arg2-nom-phrase & arg2-emb-adj-phrase &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX #ind,
    ARGS < [ SYNSEM.LKEYS.KEYREL.ARG2 #ind ], [] > ].


arg2-emb-non-nom-non-su-phrase := no-nom-embedded-val & arg2-emb-non-su-phrase.

arg2-phrase := arg2-val & binary-valence-phrase & c-cont-rel-0 & basic-val & 
  [ SYNSEM.LOCAL.CAT.VAL.CMP2.LOCAL.CAT.HEAD adj-adv-nominal-prep ].
; arg2-emb-det-phrase := arg2-val-min & det-val-embedded &
;   [ SYNSEM.LOCAL.CAT.HEAD det ].
; arg2-emb-no-det-phrase := arg2-val-min & no-det-val-embedded &
;   [ SYNSEM.LOCAL.CAT.HEAD adj-poss-card-noun-refl ].
arg2-extr-phrase := basic-val & arg2-val & valence-extr-phrase &
  [ HD-DTR.SYNSEM.LOCAL.CAT.VAL.CMP4.SAT bool ].

arg2-extr-su-phrase := subj-extr & arg2-extr-phrase &
  [ ARGS.FIRST.SYNSEM.LOCAL.CAT.ARGUMENT [ LINK 2np,
					   LOCAL.CAT.HEAD adj-nominal &
						[ NOM + ] ] ].
arg2-extr-non-su-phrase := arg2-non-su-val & arg2-extr-phrase & non-subj-extr &
  [ ARGS < [ SYNSEM [ LOCAL.CAT.VAL.CMP4.LINK arg4-,
		      LKEYS.KEYREL.PRED #link,
		      NON-LOCAL.SLASH < [ EXTR-LINK #link ] > ] ] > ].
arg2-extr-nom-non-su-phrase := arg2-extr-non-su-phrase &
  [ ARGS < [ SYNSEM.LOCAL.CAT.ARGUMENT [ LINK 2np,
					 LOCAL.CAT.HEAD adj-nominal &
					      [ NOM + ] ] ] > ].
arg2-extr-compl-non-su-phrase := arg2-extr-non-su-phrase &
  [ ARGS < [ SYNSEM [ LOCAL.CAT.ARGUMENT.LOCAL.CAT.HEAD subcompl,
		      NON-LOCAL.SLASH < [ CONT.HOOK.INDEX #ind ] >,
		      LKEYS.KEYREL [ PRED comp+,
				     ARG2 #ind ] ] ] > ].
arg2-extr-inq-non-su-phrase := arg2-extr-non-su-phrase &
  [ ARGS < [ SYNSEM [ NON-LOCAL.SLASH < [ CONT.HOOK.INDEX #ind ] >,
		      LKEYS.KEYREL [ PRED 2inq,
				     ARG2 #ind ] ] ] > ].

arg2-word := arg2-val & valence-word.
arg2-3m-word := arg2-word &
  [ HD-DTR.SYNSEM.LOCAL.CAT.ARGUMENT.LOCAL.CONT.HOOK.INDEX.PNG [ PN 3sg,
								 GEN masc ],
    C-CONT.RELS.LIST.FIRST.PRED "han_pron_rel" ].

arg2-3f-word := arg2-word &
  [ HD-DTR.SYNSEM.LOCAL.CAT.ARGUMENT.LOCAL.CONT.HOOK.INDEX.PNG [ PN 3sg,
								 GEN fem ],
    C-CONT.RELS.LIST.FIRST.PRED "hun_pron_rel" ].

arg3-val := arg3-sign &
  [ ARGS.FIRST.SYNSEM [ LOCAL.CAT [ HEAD compl-verb,
				    VAL [ ARGFRAME arg2+,
					  CMP2.LINK arg2+,
					  CMP3 [ LINK 3np,
						 LOCAL.CAT [ HEAD adj-nominal &
								  [ NOM + ]] ] ],
				    ARGUMENT.LKEYS.Q.QREL.PRED non-bare_q ],
			LKEYS.CNSTR.ARG3 ref-ind &
				  [ PNG.PN count ] ] ].

arg3-phrase := arg3-val & binary-valence-phrase & c-cont-rel-0 & 
                basic-val.
arg3-emb-phrase := arg3-val & non-pred-val-emb & nom-embedded-val-min &
  [ SYNSEM.LOCAL.CAT [ HEAD adj-nominal,
		       STACK < [ LOCAL.CAT.VAL.CMP3.LOCAL.CONT.HOOK.INDEX #ind ], ... > ],
    ARGS < [ SYNSEM.LOCAL.CAT.VAL.CMP3.LOCAL.CONT.HOOK.INDEX #ind ], [] > ].

arg3-extr-phrase := basic-val & arg3-val & valence-extr-phrase.

arg3-emb-su-phrase := subj-val & arg3-emb-phrase & nom-embedded-val.
arg3-emb-non-su-phrase := non-subj-val & arg3-emb-phrase & nom-embedded-val.

arg3-emb-adj-phrase := adj-embedded-val &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX #ind,
    ARGS < [ SYNSEM.LKEYS.KEYREL.ARG3 #ind ], [] > ].

arg3-emb-adj-su-phrase := subj-val & arg3-emb-phrase & arg3-emb-adj-phrase.
arg3-emb-adj-non-su-phrase := non-subj-val & arg3-emb-phrase & arg3-emb-adj-phrase.

arg3-extr-su-phrase := subj-extr & arg3-extr-phrase.
arg3-extr-non-su-phrase := arg3-extr-phrase & non-subj-extr.

arg3-ellipsis-phrase := arg3-sign & head-only & basic-val &
  [ SYNSEM [ LOCAL.CAT.HEAD.ELLIPSIS +,
	     LKEYS.KEYREL.PRED #pred,
	     NON-LOCAL #nl ],
    ARGS <  [ SYNSEM [ LOCAL.CAT.HEAD.ELLIPSIS +,
		      LKEYS.KEYREL.PRED #pred & refl,
		      NON-LOCAL #nl ] ] > ].

arg3-word := arg3-val & valence-word.
arg3-3m-word := arg3-word &
  [ HD-DTR.SYNSEM.LOCAL.CAT.ARGUMENT.LOCAL.CONT.HOOK.INDEX.PNG [ PN 3sg,
								 GEN masc ],
    C-CONT.RELS.LIST.FIRST.PRED "han_pron_rel" ].

arg3-3f-word := arg3-word &
  [ HD-DTR.SYNSEM.LOCAL.CAT.ARGUMENT.LOCAL.CONT.HOOK.INDEX.PNG [ PN 3sg,
								 GEN fem ],
    C-CONT.RELS.LIST.FIRST.PRED "hun_pron_rel" ].

arg3-3n-word := arg3-word &
  [ HD-DTR.SYNSEM.LOCAL.CAT.ARGUMENT.LOCAL.CONT.HOOK.INDEX.PNG [ PN 3sg,
								 GEN neut ],
    C-CONT.RELS.LIST.FIRST.PRED "den_pron_rel" ].

; PH 2013-02-27: Abstracting out the VBL value of the arg4 valence type.
arg4-vbl := phrase &
  [ ARGS.FIRST.SYNSEM.LOCAL.CAT.VBL anti-synsem ].

arg4-val-min := arg4-sign & arg4-vbl &
  [ SYNSEM.LOCAL.CAT.VAL.CMP4.LINK arg4-,
    ARGS.FIRST.SYNSEM.LOCAL.CAT [ VAL [ CMP2.LOCAL.CONT.HOOK.INDEX individual,
					CMP4.LOCAL [ CAT [ HEAD head &
								[ PREDICATIVE + ],
							   CASE arg4-case ],
						     CONT.HOOK.XARG individual ] ],
				  ARGUMENT.LOCAL.CAT.CASE non-subj-case,
				  VBL synsem-min ] ].

arg4-val := arg4-val-min & basic-val &
  [ SYNSEM.LOCAL.CAT [ HEAD compl-verb,
                       VAL.CMP4.SAT + ] ].

; PH Took out the arg2- constraint in order to account for "Vi la til grunn
; en mengde data."
; DEBUG 2013-11-23: Took out the SYNSEM.LKEYS.Q.QREL.PRED anti-quant_m_rel 
; constraint.
arg4-emb-phrase := arg4-val-min & no-nom-embedded-val &
  [ SYNSEM [ LOCAL.CAT.STACK < [ MODIFIED xmod,
				 LOCAL.CAT [ HEAD compl-verb,
					     VAL.CMP4 [ SAT +,
							LKEYS #lk ] ],
				 NON-LOCAL.SLASH <> ], ... >,
	     LKEYS.Q.QREL.PRED anti-quant_m_rel ],
    ARGS.FIRST.SYNSEM.LOCAL.CAT.VAL [ CMP2 [ LINK arg2-,
					     LOCAL.CONT.HOOK.INDEX #ind ],
				  CMP4 [ LOCAL [ CAT [ HEAD adj-adv-nominal-prep,
						       VAL.CMP2.LINK link ],
						 CONT.HOOK.XARG #ind ],
					 LKEYS #lk ],
				  PART prt- ] ].

;; 
;; This rule is made for PPs that are selected by the verb. It combines the
;; head projection with the preposition and enters the head projection onto
;; the STACK. The mother becomes an unsaturated preposition with the head
;; projection on the STACK. The main motivation behind this rule is to allow
;; for extraction from PP complements. This is now posssible since the rule
;; that combines the object of the preposition with the preposition is 
;; dominating the filler.                                       (17-dec-09; ph)
;;
arg4-embedded-phrase := arg4-sign & embedded-phrase-min & 
		        gap-binary & 
		        c-cont-rel-0 & basic-predicate-phrase &
  [ CONJ no-conj,
    LINK-INPUT -,
    SYNSEM [ LOCAL [ CAT [ HEAD prep,
                           VAL [ CMP2.LINK arg2+,
				 CMP3.LINK arg3-,
				 CMP4.LINK arg4- ],
                           STACK < [ LOCAL [ CAT #out & 
						 [ VBL anti-synsem,
				        ARGUMENT.LOCAL.CAT.CASE non-subj-case ],
					     CONT.MSG #msg ] ] . #stack > ] ],
             MODIFIED xmod,
	     LKEYS [ CNSTR #keyrel,
		     KEYREL #keyrel ] ],
    ARGS < [ SYNSEM [ LOCAL [ CAT #in & 
				  [ HEAD compl-verb,
				    VAL [ CMP2.LOCAL.CONT.HOOK.INDEX #ind,
					  CMP4.LOCAL #local & [ CAT [ HEAD prep,
								      VAL.CMP2.LINK arg2+ ],
								CONT.HOOK [ XARG #ind,
									    INDEX event-or-ref-index ] ],
					  PART prt- ],
				    VBL anti-synsem,
				    ARGUMENT.LOCAL.CAT.CASE non-subj-case,
				    STACK #stack ],
			      CONT.MSG #msg ],
		      LKEYS.CNSTR #rel ] ], 
           [ SYNSEM.LOCAL #local ] >,
    MEANING #rel,
    OUT #out,
    IN #in ].

non-emb-subconstr := binary-nexus-phrase & head-initial & 
                     binary-headed-gap-phrase & 
  [ SYNSEM.LKEYS.KEYREL.PRED #pred,
    ARGS < [ SYNSEM.LKEYS.KEYREL.PRED #pred ], 
	   [ SYNSEM.LKEYS.KEYREL.PRED #pred ] > ].

part-prep-phrase := val-min &
  [ SYNSEM phr-synsem &
	   [ LOCAL [ CAT [ C -,
			   HEAD adj-compl-nominal-verb,
			   STACK #stack,
			   VAL [ CMP1 #1,
				 CMP2 #2,
				 CMP3 #3,
				 SISTER #sister ],
			   VBL #vbl & anti-synsem,
			   QUANT #quant ],
		     CONT [ HOOK #hook,
			    MSG #msg ] ],
	     --PHR-KEY no-msg,
	     NON-LOCAL #nl,
	     LKEYS #lkeys ],
    ARGS < [ SYNSEM [ FIRST-WORD +,
		      LOCAL [ CAT [ C -,
				    HEAD adj-compl-nominal-verb,
				    STACK #stack,
				    VAL [ CMP1 #1,
					  CMP2 #2,
					  CMP3 #3,
					  SISTER #sister ],
				    VBL #vbl,
				    QUANT #quant ],
			      CONT [ HOOK #hook,
				     MSG #msg ] ],
		      NON-LOCAL #nl,
		      LKEYS #lkeys ] ], ... >,
    C-CONT [ RELS <!!>,
	     HCONS <!!> ] ].

part-prep-binary := part-prep-phrase & non-emb-subconstr &
  [ ARGS < [ SYNSEM.LKEYS.KEYREL.PRED #pred ], func-word & [ SYNSEM.LKEYS.KEYREL.PRED #pred ] > ].

part-prep-ellipsis := part-prep-phrase & unary-phrase &
  [ SYNSEM [ LOCAL.CAT.HEAD.ELLIPSIS +,
	     LKEYS.KEYREL.PRED #pred ],
    ARGS < [ SYNSEM [ LOCAL.CAT.HEAD.ELLIPSIS +,
		      LKEYS.KEYREL.PRED #pred ] ] > ].

part-struc-min := part-prep-phrase & 
  [ SYNSEM.LOCAL.CAT [ HEAD #head & compl-verb,
		       VAL.PART prt- ],
    ARGS < [ SYNSEM [ LOCAL.CAT [ HEAD #head,
				  VAL.PART #part & prt+ ],
		      LKEYS.KEYREL.PRED #part ] ], ... > ].

part-struc := part-struc-min & 
  [ SYNSEM.LOCAL.CAT.VAL.CMP4 #4,
    ARGS < [ SYNSEM.LOCAL.CAT.VAL.CMP4 #4 ], ... > ].

part-binary := part-struc & part-prep-binary &
  [ SYNSEM.LOCAL.CAT.VAL.CMP4.MARKED -,
    ARGS < [], [ SYNSEM.LOCAL.CAT.HEAD part ] > ].

part-ellipsis-phrase := part-struc & part-prep-ellipsis &
  [ SYNSEM.LOCAL.CAT.VAL.CMP4.MARKED -,
    SYNSEM.LOCAL.CAT [ HEAD aux-verb,
		       VAL.CMP2.LINK arg2- ] ].

; PH 2017-09-14: Removed the ARGS..CMP2.LINK arg2- constraint in order to
; allow for direct objects after the PP object:
; Abrams overlot til Browne å bjeffe.
prepsel-struc-min := part-prep-phrase & 
  [ SYNSEM.LOCAL.CAT [ ARGUMENT #arg,
		       VAL [ CMP4 #arg & [ LINK #prepsel,
					   MARKED + ] ] ],
    ARGS < [ SYNSEM [ LOCAL.CAT.VAL [ CMP4 [ LINK #prepsel & prp+,
					     MARKED - ] ],
		      LKEYS.KEYREL.PRED #prepsel ] ], ... > ].

prepsel-struc := prepsel-struc-min &
  [ SYNSEM.LOCAL.CAT.VAL.PART prt-,
    ARGS < [ SYNSEM.LOCAL.CAT.VAL.PART prt- ], ... >].

prepsel-binary := prepsel-struc & part-prep-binary & 
  [ ARGS < [], [ SYNSEM.LOCAL.CAT.HEAD prep ] > ].

prepsel-ellipsis-phrase := prepsel-struc & part-prep-ellipsis.

; PH 2022-03-09: Rule for ground objects:
; Han dekket på bordet
ground-obj-struc := prepsel-struc-min & part-struc-min & part-prep-binary &
  [ ARGS < [], part-word > ].

arg4-extr-phrase := non-subj-extr & arg4-val &
  [ HD-DTR.SYNSEM [ LOCAL.CAT.VAL.CMP2.LINK arg2-,
		    NON-LOCAL.SLASH < [ CAT.CASE arg4-case ] > ] ].

arg4-extr-pobj-struc := arg4-extr-phrase &
  [ ARGS < [ SYNSEM.LOCAL.CAT.VAL.CMP4.MARKED + ] > ].

arg4-extr-cp-struc := arg4-extr-pobj-struc &
  [ ARGS.FIRST.SYNSEM.LOCAL.CAT.VAL.CMP4 [ LINK 4cp,
					   LOCAL.CAT.HEAD subcompl ] ].
arg4-extr-np-struc := arg4-extr-pobj-struc &
  [ ARGS.FIRST.SYNSEM.LOCAL.CAT.VAL.CMP4 [ LINK 4np,
					   LOCAL.CAT.HEAD nominal ] ].

arg4-extr-ap-struc := arg4-extr-phrase &
  [ ARGS < [ SYNSEM [ LOCAL.CAT.VAL.CMP4.MARKED -,
		      NON-LOCAL.SLASH < [ CAT [ HEAD adj & [ NOM -,
							     AGREE.GENDER #gen ],
						VAL.SISTER synsem ],
					  CONT.HOOK.INDEX #arg4,
					  EXTR-REL.ARG1 #arg1 ] >,
		      LKEYS.KEYREL [ PRED 4ap & 1np,
				     ARG1 #arg1 & [ PNG.GEN #gen ],
				     ARG4 #arg4 ] ] ] > ].


;;;;;
;;;;;   PRESENTATION AND CLEFTING
;;;;;

basic-pres-min := val-min &
  [ SYNSEM [ FIRST-WORD +,
	     PHR +,
	     LOCAL [ CAT [ HEAD compl-verb &
				[ SU-IND expl-ind ],
			   VAL #val,
			   VBL #verbal ] ],
	     LKEYS #lk ],
    ARGS < [ SYNSEM [ LOCAL.CAT [ VAL #val,
				  CASE subj-case,
				  ARGUMENT.LOCAL [ CAT [ HEAD noun,
							 CASE subj-case ] ],
				  VBL #verbal ],
		      LKEYS #lk ],
	     BOUNDARY - ], ... >,
    C-CONT [ RELS <!!>,
	     HCONS <!!> ] ].

basic-pres := basic-pres-min &
  [ SYNSEM.LOCAL.CAT.VAL.CMP2.LOCAL.CONT.HOOK.INDEX.COGN-ST type-id ].
basic-cleft := basic-pres-min &
  [ SYNSEM.LOCAL.CAT.VAL [ ARGFRAME _være_2_rel,
			   CMP2.LOCAL.CONT.HOOK.INDEX.COGN-ST in-foc ] ].

binary-expl-phrase := val-min & head-initial & phrasal & binary-headed-gap-phrase &
  [ START -,
    SYNSEM [ LOCAL [ CONT [ MSG #msg2,
			    HOOK.INDEX.SF #msg ],
		     CAT.VBL.LOCAL.CONT.HOOK.INDEX.SF #msg ] ],
    HD-DTR.SYNSEM.LOCAL.CONT.MSG #msg2,
    NH-DTR expletive-noun-phrase ].

expl-subj-struc := basic-pres & binary-expl-phrase.
cleft-subj-struc := basic-cleft & binary-expl-phrase.

expl-obj-struc := binary-expl-phrase &
  [ SYNSEM [ PHR +,
	     LOCAL [ CAT [ HEAD compl-verb,
			   VAL [ CMP1 #cmp1,
				 CMP2.LINK arg2-,
				 CMP3 #cmp3,
				 CMP4 #cmp4 ],
			   VBL #verbal ] ],
	     LKEYS #lk ],
    ARGS < [ SYNSEM [ LOCAL.CAT [ VAL [ CMP1 #cmp1 & [ LINK arg1-],
					CMP2.LINK 2expl,
					CMP3 #cmp3 & [ LINK arg3-],
					CMP4 #cmp4 & [ LINK 4ap,
						       LOCAL.CONT.HOOK.INDEX.PNG [ PN sg,
									       GEN neut ] ] ],
				  CASE non-subj-case,
				  VBL #verbal ],
		      LKEYS #lk & [ KEYREL.PRED 1np ] ],
	     BOUNDARY - ], [] >,
    C-CONT [ RELS <!!>,
	     HCONS <!!> ] ].

extr-pres-min := valence-extr-phrase-min & unary-extr-phrase &
  [ CONJ no-conj,
    SYNSEM [ FIRST-WORD +,
	     LOCAL [ CAT.HEAD aux-verb,
                     CONT [ HOOK.INDEX.SF prop_m_rel,
                            MSG prop_m_rel ] ],
             NON-LOCAL.SLASH <> ],
    ARGS < [ SYNSEM.LOCAL.CAT.ARGUMENT.LOCAL.CONT.HOOK.INDEX expl-ind ] >,
    C-CONT [ RELS <!!>,
	     HCONS <!!> ] ].

extr-pres-phrase := extr-pres-min & basic-pres.
extr-cleft-phrase := extr-pres-min & basic-cleft.

;;;;;
;;;;;   PASSIVE
;;;;;

passive-phrase-min := binary-phrase & arg1-sign &
  [ SYNSEM [ LOCAL [ CAT #out & [ HEAD.SU-IND #arg2 ],
		     CONT.HOOK.LTOP #lbl ],
	     LKEYS.KEYREL #rel & [ LBL #lbl,
				   PRED #pred,
				   ARG0 #arg1 & event ] ],
    IN #in,
    OUT #out,
    ARGS < [ SYNSEM.LOCAL.CAT #in & [ VAL.ARGFRAME #pred ] ], 
	   [ ALTS.PASSIVE +,
	     SYNSEM.LKEYS.KEYREL.LBL #lbl ] >,
    C-CONT [ RELS.LIST.FIRST arg12-relation &
			     [ LBL #lbl,
			       PRED "parg_d_rel",
			       ARG0 event,
			       ARG1 #arg1,
			       ARG2 #arg2 ],
	     HCONS <! !> ],
    MEANING #rel ].

passive-phrase-main := passive-phrase-min &
  [ SYNSEM.LKEYS.KEYREL #rel & [ PRED #pred,
				 ARG0 #arg0 ],
    C-CONT.RELS <! [], #rel !>,
    ARGS < [], [ SYNSEM [ LOCAL.CAT.HEAD mainverb,
			  LKEYS.KEYREL [ PRED #pred,
					 ARG0 #arg0  ] ] ] > ].

passive-phrase-aux := passive-phrase-min &
  [ C-CONT.RELS <! [] !>,
    ARGS < [], [ SYNSEM.LOCAL.CAT.HEAD aux ] > ].

s-pass-word := verb-word-min & inflecting-lex-rule &
  [ SYNSEM [ FIRST-WORD -,
	     LOCAL.CONT.HOOK.INDEX.PERF - ],
    ALTS.PASSIVE +,
    C-CONT [ HCONS <!!>,
	     RELS <!!> ],
    ARGS < main-verb-lxm &
	   [ SYNSEM.LOCAL.CAT.HEAD.PERFPART - ]> ].

s-pass-inf-pres := s-pass-word &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.E.TENSE infin-pres ].

s-pass-pret := s-pass-word &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.E.TENSE pret ].

; DEBUG 2013-11-26: removed the norm-lex-item supertype
pass-aux-lxm := basic-non-modal-aux-lxm &
  [ ALTS.PASSIVE +,
    SYNSEM.LOCAL [ CAT.VBL.LOCAL [ CAT.HEAD mainverb &
					    [ PERFPART + ],
				   CONT.HOOK.INDEX #event ],
		   CONT [ HOOK.INDEX #event & [ PERF bool ],
			  RELS <!!>,
			  HCONS <!!> ] ] ].

; complex-pass-phrase := verbal-phrase-min &
;  [ SYNSEM.LOCAL.CAT.VAL [ ARGFRAME arg1+ & arg2+,
; 			  CMP1.LOCAL.CONT.HOOK.INDEX expl-ind ],
;    ARGS < [ ], 
; 	   word-or-lexrule &
; 	   [ SYNSEM.LOCAL [ CAT.HEAD verb,
; 			    CONT.HOOK.INDEX.E.TENSE perf ] ] > ].




complex-pass-phrase := gap-binary &
  [ LINK-INPUT -,
    BOUNDARY -,
    SYNSEM [ FIRST-WORD +,
	     LOCAL [ CAT [ HEAD #head & [ MESS #mess ],
			   VAL [ ARGFRAME #argframe & arg1+ & arg2+,
				 CMP1 #arg1 & 
					  [ LOCAL.CONT.HOOK.INDEX expl-ind ],
				 CMP2 #arg2 &
					  [ LINK #link2,
					    LOCAL [ CAT [ HEAD #head2,
							  VAL #val2 ],
						    CONT #cont2 ] ],
				 CMP3 #arg3,
				 CMP4 #arg4,
				 PART #part ],
			   CASE #case,
			   STACK #stack,
			   ARGUMENT #arg & 
			       [ LOCAL.CAT.CASE non-subj-case ],
			   VBL #verbal2 ],
		     CONT [ MSG #msg,
			    HOOK [ LTOP #ltop,
				   INDEX #ind ] ] ] ],
    ARGS < phrase & 
	   [ BOUNDARY -,
	     SYNSEM [ LOCAL [ CAT [ HEAD compl-verb &
					 [ COMPL-PASS +,
					   MESS #mess ],
				    VAL [ ARGFRAME #argframe,
					  CMP2 [ LINK #link2,
					       LOCAL [ CAT [ HEAD #head2,
							     VAL #val2,
							     CASE subj-case ],
						       CONT #cont2 ] ] ],
				    CASE #case,
				    VBL anti-synsem,
				    ARGUMENT #arg,
				    STACK #stack ],
			      CONT [ HOOK [ LTOP #ltop,
					    INDEX #lind ],
				     MSG #msg ] ] ] ],
	   word-or-lexrule &
	   [ INFLECTED +,
	     SYNSEM synsem & 
		       [ LOCAL [ CAT [ HEAD #head & verb & 
					    [ MESS prop_m_rel ],
				       VBL #verbal2,
				       VAL  [ ARGFRAME #argframe,
					      CMP1 #arg1,
					      CMP2 #arg2 & 
						  [ LOCAL.CAT.HEAD compl-noun ],
					      CMP3 #arg3,
					      CMP4 #arg4,
					      PART #part ] ],
				 CONT.HOOK [ INDEX #rind & [ E.TENSE perf ],
					     LTOP #ltop ] ] ] ] >,
	   C-CONT.RELS <! [ PRED cmplx-pass_rel,
			    LBL #ltop,
			    C-ARG event & #ind,
			    L-INDEX #lind,
			    R-INDEX #rind ] !> ].


;;;;;
;;;;;   IMPERATIVE
;;;;;

imp-verb := arg1-sign &
               bottom-gap-item & word & lex-rule &
  [ INFLECTED +,
    SYNSEM [ LOCAL [ CAT #out & [ HEAD #head & aux-verb & [ MESS command_m_rel ],
                                  ARGUMENT.LOCAL.CAT.CASE non-subj-case ],
                     CONT.HOOK #hook & [ INDEX #index2 & [ E.TENSE imp ] ] ],
             NON-LOCAL #non-local,
	     LKEYS [ KEYREL #rel,
		     CNSTR #rel ],
             FIRST-WORD -,
	     --PHR-KEY arg1-relation ],
    ARGS < [ INFLECTED -,
	     SYNSEM [ LOCAL [ CAT #in & [ HEAD #head,
					  VAL [ ARGFRAME #1,
						CMP1.LINK #1,
						CMP2.LINK #1,
						CMP3.LINK #1,
						CMP4.LINK #1 ] ],
			      CONT.HOOK #hook ],
		      NON-LOCAL #non-local,
		      LKEYS [ KEYREL #rel,
			      CNSTR #rel ],
		      --PHR-KEY no-msg ] ] >,
    C-CONT [ RELS <! pron-relation & [ LBL #larg,
				       ARG0 #index & ref-ind & 
					   [ PNG.PN 2p ] ],
		   pronoun-q-relation &
		   [ PRED pronoun_q_rel,
		     ARG0 #index,
		     RSTR #harg ] !>,
	     HCONS <! [ HARG #harg,
			LARG #larg ] !> ],
    MEANING #rel & [ ARG0 #index2,
		     ARG1 #index ],
    IN #in,
    OUT #out ].


interj-word := word & keyrel-lex-item &
  [ BOUNDARY +,
    SYNSEM [ LOCAL [ CAT [ HEAD interj,
			   VAL [ CMP1.LINK arg1-,
				 CMP2.LINK arg2-,
				 CMP4.LINK arg4- ] ],
		     CONT [ HCONS <!!>,
			    RELS <! #keyrel !> ] ],
             NON-LOCAL.SLASH <>,
	     LKEYS.KEYREL #keyrel & [ ARG0 event ] ] ].

interj-phrase := start-item & binary-phrase & uni-link & start-head & clause &
  [ CONJ no-conj,
    SYNSEM [ FIRST-WORD +,
	     LOCAL [ CAT [ HEAD.ELLIPSIS -,
			   STACK <>,
			   C +,
			   VBL synsem ],
		     CONT [ HOOK.INDEX #1 & event,
			    HCONS <! !> ],
		     TOPIC no-topic ],
	     NON-LOCAL.SLASH <>,
	     LKEYS.KEYREL #keyrel & [ ARG0 #1 ] ],
    LINK-INPUT -,
    C-CONT [ RELS <!!>,
	     HCONS <!!> ],
    ARGS < start-word, interj-word & [ SYNSEM.LKEYS.KEYREL #keyrel ] > ].

;infl-imp-verb := imperative-word & inflecting-lex-rule.

verb_basic := norm-lex-item & word &
  [ SYNSEM.LOCAL.CAT.VAL.ARGFRAME arg1+ ].

verb_imp_word := arg1-sign & verb_basic &
             no-slash & non-gen-word & val-or-mod-sign & keyrel-lex-item &
  [ SYNSEM.LOCAL [ CAT #out & [ HEAD verb & [ MESS command_m_rel ],
				ARGUMENT.LOCAL.CAT.CASE non-subj-case,
				VBL anti-synsem ],
		   CONT [ HOOK [ INDEX event & [ E.TENSE no_tense ] ],
			  MSG command_m_rel,
			  RELS <! #rel &
				[ ARG1 #ind ], 
				[ PRED pron_rel,
				  LBL #lbl,
				  ARG0 #ind & ref-ind & [ PNG.PN 2p ] ], pronoun-q-relation & [ ARG0 #ind,
												RSTR #harg ] !> ,
			  HCONS <! [ HARG #harg,
				     LARG #lbl ] !> ] ],
    IN [ ARGUMENT.LOCAL.CAT.CASE subj-case ],
    OUT #out,
    MEANING #rel ].

;;;;;
;;;;;   SUBORDINATE STRUCTURES
;;;;;

basic-complementizer-sign := uni-link &
  [ SYNSEM [ LOCAL [ CAT.C -,
		     CONT.HOOK.INDEX #ind & event-or-ref-index ],
	     LKEYS.KEYREL.ARG0 #ind ] ].

subord-rel-compl-sign-min := basic-complementizer-sign & 
                         non-pass-verbal-item &
  [ SYNSEM.LOCAL [ CAT [ HEAD complementizer,
			 VBL.LOCAL [ CAT [ HEAD adj-compl-nominal-verb,
					   CASE subj-case ],
				     CONT.HOOK.INDEX.E.TENSE finite ] ],
		   TOPIC.CAT.CASE case ] ].

subord-rel-compl-sign := subord-rel-compl-sign-min &
  [ SYNSEM.LOCAL.CAT.ARGUMENT.LOCAL.CAT.CASE subj-case ].

complementizer-sign := subord-rel-compl-sign &
  [ SYNSEM.LOCAL.CAT [ HEAD complementizer,
		       VBL synsem & 
			    [ LOCAL.CONT.HOOK.INDEX.E.TENSE finite ] ] ].

complementizer-word := complementizer-sign & norm-lex-item & keyrel-lex-item &
  [ SYNSEM [ FIRST-WORD -,
	     LOCAL [ CONT [ RELS <! #relation &
				       [ PRED "subord_rel",
					 ARG0 event ] !>,
			    HCONS <! !> ] ],
	     LKEYS.KEYREL #relation,
             NON-LOCAL.SLASH <> ] ].

; complementizer-word := complementizer-sign & norm-lex-item &
;   [ SYNSEM [ LOCAL [ CAT [ VBL.LOCAL.CONT.HOOK [ LTOP #lbl,
; 						   INDEX #index ] ],
;                      CONT [ RELS <! [ LBL #lbl,
; 				      ARG0 #index ] !>,
; 			    HCONS <! !> ] ],
;              NON-LOCAL.SLASH <>,
; 	     LKEYS.KEYREL.PRED comp+ ] ].

compl-first-arg-vbl := phrase &
  [ ARGS.FIRST.SYNSEM.LOCAL.CAT.VBL anti-synsem ].

; PH 2016-01-22: Removed link between VBL.INDEX and INDEX in order to parse
; "Jon hevder at hun har sovet."
compl-phrase-min := complementizer-sign & compl-first-arg-vbl &
                    embedded-phrase & subconstruction &
  [ CONJ no-conj,
    SYNSEM [ LOCAL [ CAT [ HEAD.CATEGORY #c,
			   VAL [ ARGFRAME #pred,
				 CMP4.MARKED - ],
			   STACK < [ LOCAL [ CAT #out & [ CASE non-subj-case,
							  VBL #verbal ],
					     CONT.MSG #msg,
					     AGR #agr,
					     TOPIC #topic ],
				     LKEYS.CNSTR #rel,
				     NON-LOCAL.SLASH <> ], ... >,
			   VBL synsem & [ LOCAL.CONT.HOOK.INDEX event ],
			   C - ],
                   CONT [ HOOK.INDEX event,
                          MSG #msg ],
		   NEG-OUT #negout ],
	     LKEYS [ CNSTR #keyrel,
		     KEYREL #keyrel & [ PRED #pred ] ] ],
    ARGS < [ SYNSEM [ LOCAL [ CAT #in & [ VBL #verbal,
					  CONJ-CAT #c,
					  VAL.PART prt- ],
			      CONT [ HOOK.LTOP #lbl,
				     MSG #msg ],
			      AGR #agr,
			      TOPIC #topic,
			      NEG-OUT #negout ],
		      LKEYS.CNSTR #rel & [ LBL #lbl ] ] ], ... >,
    MEANING #rel,
    IN #in,
    OUT #out ].

compl-phrase := compl-phrase-min.

; PH 2013-01-31: replaced the ARGS.FIRST.HEAD compl-som-verb
; constraint with compl-verb in order to prevent too many parses with
; som
unary-compl-phrase := compl-phrase & unary-phrase & gap-unary & arg2-sign &
  [ SYNSEM [ LOCAL [ CAT [ HEAD subcompl-omcompl,
			   STACK < [ LOCAL [ CAT [ VAL [ CMP1.LINK arg1-,
				       	  CMP2.LOCAL.CAT.HEAD subcompl ],
				          C-COGN-ST activ-or-less ] ] ], ... > ],
		     CONT.HOOK [ LTOP #ltop,
				 INDEX #index & event ] ],
	     LKEYS.KEYREL.LBL #ltop,
	     --PHR-KEY arg2-relation ],
    ARGS < [ SYNSEM [ LOCAL [ CAT [ HEAD compl-verb,
				    VAL.CMP2 [ LINK 2cp,
					       LOCAL.CAT.HEAD atnull ],
				    ARGUMENT.LOCAL.CAT.CASE non-subj-case,
				    VBL anti-synsem,
				    C - ],
			      CONT.HOOK.LTOP #lbl ],
		      LKEYS.KEYREL [ LBL #lbl,
				     ARG2 #index ]] ] >,
    C-CONT [ RELS <! [ PRED "subord_rel",
		       LBL #ltop,
		       ARG0 #index ] !>,
	     HCONS <!!> ] ].

; Extracting out the arg1 link feature
stack-cmp1-link := phrase &
[ SYNSEM.LOCAL.CAT.STACK < [ LOCAL.CAT.VAL.CMP1.LINK arg1- ], ... > ].

binary-compl-phrase := compl-phrase & head-final & stack-cmp1-link &
  [ SYNSEM [ LOCAL [ CAT [ HEAD subcompl-omcompl,
		   STACK < [ LOCAL.CAT [ C-COGN-ST type-id ],
				     NON-LOCAL.SLASH <> ], ... > ] ],
             NON-LOCAL #sl,
	     LKEYS.KEYREL [ LBL #ltop,
			    ARG0 #event ] ],
    ARGS < [ SYNSEM [ LOCAL.CAT [ HEAD  adj-adv-compl-noun-prep-verb,
				  ARGUMENT.LOCAL.CAT.CASE non-subj-case ],
                      NON-LOCAL #sl ] ],
           complementizer-word &
	   [ SYNSEM.LKEYS.KEYREL [ LBL #ltop,
				   ARG0 #event ] ] >,
    C-CONT [ RELS <! !>,
	     HCONS <! !> ] ].

mod-compl-phrase := compl-phrase & head-final & stack-cmp1-link &
  [ SYNSEM [ LOCAL [ CAT [ HEAD subcompl,
			   STACK < [ LOCAL.CAT [ C-COGN-ST type-id ],
				     NON-LOCAL.SLASH <> ], ... > ],
		     CONT.HOOK [ INDEX #comp & event ] ],
             NON-LOCAL #sl,
	     COMP-IND index ],
    ARGS < [ SYNSEM [ LOCAL [ CAT [ HEAD adj-adv,
				  ARGUMENT.LOCAL.CAT.CASE non-subj-case ] ],
                      NON-LOCAL #sl,
		      COMP-IND #comp ] ],
           complementizer-word >,
    C-CONT [ RELS <! !>,
	     HCONS <! !> ] ].

binary-compl2-min := binary-compl-phrase & arg2-sign &
  [ SYNSEM [ LOCAL [ CAT.VBL.LOCAL.CONT.HOOK.INDEX #index ],
             --PHR-KEY arg2-rel-min ],
    ARGS < [ SYNSEM [ LOCAL.CAT [ VAL [ ARGFRAME #pred,
					CMP2 [ LINK #pred,
					       LOCAL.CAT.HEAD subcompl ] ] ],
                      LKEYS.KEYREL.ARG2 #index ] ],
           [ SYNSEM.LINK #pred ] > ].

binary-compl2-phrase := binary-compl2-min &
  [ ARGS.FIRST.SYNSEM.LOCAL.CAT.HEAD adj-adv-compl-prep-verb ].
binary-compl2-noun-phrase := binary-compl2-min &
  [ ARGS.FIRST.SYNSEM [ LOCAL.CAT [ HEAD noun,
				    VAL.CMP2.LINK #pred & arg3- & arg4- & prt- & atom ],
			LKEYS.KEYREL.PRED #pred ] ].

binary-compl4-phrase := binary-compl-phrase & arg4-sign &
  [ SYNSEM [ LOCAL [ CONT.HOOK [ INDEX event & #index ] ] ],
    ARGS < [ SYNSEM [ LOCAL.CAT [ VAL [ ARGFRAME #pred,
					CMP4 [ LINK #pred,
					       LOCAL.CAT.HEAD subcompl,
					       MARKED + ] ] ],
                      LKEYS.KEYREL.ARG4 #index ] ],
           [ SYNSEM.LINK #pred ] > ].

wh2-struc := embedded-phrase & arg2-val-min & binary-phrase &
  [ CONJ no-conj,
    SYNSEM [ LOCAL.CAT [ STACK < [ LOCAL [ CAT #out,
					   TOPIC #topic ],
				   NON-LOCAL.SLASH <>,
				   LKEYS #lkeys ], ... >,
			 VBL synsem,
			 C - ],
	     NON-LOCAL.SLASH < [ CAT [ HEAD adj-adv-nominal,
				       CASE #case ],
				 EXTR-REL #relation ] > ],
    ARGS < [ SYNSEM [ LOCAL [ CAT #in & [ HEAD compl-verb,
					  VBL anti-synsem,
					  VAL.PART prt- ],
			      TOPIC #topic ],
		      LKEYS #lkeys & [ KEYREL #rel & [ PRED wh+,
						       ARG2 #index ],
				       CNSTR #rel ] ] ],
	   func-wh-word &
	   [ SYNSEM [ LOCAL.CAT.CASE #case,
		      LKEYS.KEYREL #relation &
				     [ ARG0 #index ] ] ]>,
    IN #in,
    OUT #out,
    MEANING #rel,
    C-CONT [ RELS <! !>,
	     HCONS <!!> ] ].
  

zero-cop-input := sign.

pop-phrase-min-min := phrase & zero-cop-input &
  [ START -,
    SYNSEM phr-synsem &
	   [ FIRST-WORD #fw,
	     --PHR-KEY no-msg,
	     LOCAL.CAT.VAL.CMP4.MARKED -,
	     LOCAL.NEG-OUT #neg,
	     LEX - ],
    ARGS < [ SYNSEM [ FIRST-WORD #fw,
		      LOCAL [ CAT [ HEAD head,
				    VAL [ CMP1.LINK arg1-,
					  CMP2.LINK arg2-,
					  CMP3.LINK arg3-,
					  CMP4.LINK arg4-,
					  PART prt- ],
				    STACK < [], ... >,
				    ARGUMENT anti-synsem ],
			      NEG-OUT #neg ],
		      MODIFIED notmod-or-rmod ] ], ... >,
    BOUNDARY -,
    LINK-INPUT - ].

pop-phrase-min := pop-phrase-min-min &
  [ SYNSEM [ LOCAL [ CAT #cat & [ STACK #2 ],
		     CONT [ HOOK #hook,
			    MSG #msg ],
		     AGR #agr,
		     TOPIC #top,
		     NEG-OUT #negout ],
	     LKEYS #lkeys,
	     MODIFIED #mod ],
    ARGS < [ SYNSEM [ LOCAL [ CAT.STACK < [ LOCAL [ CAT #cat,
						    CONT [ HOOK #hook,
							   MSG #msg ],
						    AGR #agr,
						    TOPIC #top,
						    NEG-OUT #negout ],
					    LKEYS #lkeys,
					    MODIFIED #mod ] . #2 >,
			      CONT.HOOK.INDEX #index ],
		      LKEYS.KEYREL.ARG0 #index ] ], ... > ].

pop-phrase := pop-phrase-min-min &
  [ SYNSEM.LOCAL.CAT.VBL #vbl,
    CONJ no-conj,
    ARGS.FIRST [ CONJ no-pre-conj,
		 SYNSEM.LOCAL.CAT [ STACK.FIRST.LOCAL.CAT.VBL #vbl ] ] ].

; DEBUG 2013-11-24: Added the ARGS.FIRST.SLASH <> constraint
; PH 2021-11-12: added CASE constraint in order to avoid spurious
; ambiguity with extr-sadv-rule, which may otherwise apply both before
; and after non-subjects.
pop-nominal-phrase := pop-phrase & unary-phrase & pop-phrase-min &
  [ SYNSEM [ LOCAL.CAT.CASE #case,
	     NON-LOCAL #nl ],
    ARGS < [ SYNSEM [ LOCAL [ CAT [ HEAD adj-nominal &
					 [ NOM + ],
				    CASE #case,
				    STACK < [ NON-LOCAL #nl ], ... >] ],
		      NON-LOCAL.SLASH <>,
		      LKEYS [ KEYREL #rel,
			      ALTKEYREL #rel,
			      Q.QREL #qrel ] ] ] >,
    C-CONT [ RELS <! #qrel !>,
	     HCONS <!!> ] ].

; PH 2016-05-12: Added ARGS...QREL.PRED anti-quant_m_rel constraint in
; order to block application to adjectives with determiners.
; "Jeg er den pene."
; PH 2016-05-11: Changed ARGS SISTER value from synsem to synsem-min in 
; order to pop from predicative adjective phrases.
pop-no-nominal-min := pop-phrase & pop-phrase-min &
  [ SYNSEM [ LOCAL.CAT.VAL.SISTER anti-synsem,
	     NON-LOCAL #nl ],
    ARGS < [ SYNSEM [ LINK nom-,
		      LOCAL.CAT [ HEAD.NOM -,
				  VBL anti-synsem,
				  VAL.SISTER synsem-min,
				  STACK < [ NON-LOCAL #nl ], ... > ],
		      NON-LOCAL.SLASH <>,
		      LKEYS.Q.QREL.PRED anti-quant_m_rel ] ] , ... >,
    C-CONT [ RELS <!!>,
	     HCONS <!!> ] ].

pop-no-nominal-phrase := pop-no-nominal-min & unary-phrase &
  [ ARGS < [ ] > ].

pop-no-nominal-comma-phrase := pop-no-nominal-min & binary-phrase &
  [ ARGS < [ SYNSEM.LOCAL.CAT.HEAD complementizer ], comma-word > ].

;; Phrase for ending parentheticals
pop-par-phrase := pop-phrase & gap-binary &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX #arg1,
    ARGS < phrase-or-lexrule & 
	   [ SYNSEM [ LOCAL [ CAT [ VAL [ CMP1.LINK arg1-,
					  CMP2.LINK arg2-,
					  CMP3.LINK arg3-,
					  CMP4.LINK arg4- ],
				    ARGUMENT.LOCAL.CAT.CASE non-subj-case,
				    STACK < [ LOCAL.CAT.HEAD start ], ... > ],
			      CONT.HOOK.INDEX #arg2 ],
		      NON-LOCAL.SLASH <> ],
	     BOUNDARY -,
	     CONJ no-conj,
	     BRACKET #bracket ], 
	   popping-mark &
	   [ BRACKET #bracket ] >,
    C-CONT [ RELS <! [ PRED "appos_rel",
		       ARG0 event,
		       ARG1 #arg1,
		       ARG2 #arg2 ] !>,
	     HCONS <!!> ] ].

;; Jon, jeg hentet ham, sover.
pop-s-par-phrase := pop-par-phrase & pop-phrase-min &
  [ ARGS < [ SYNSEM.LOCAL.CAT.HEAD verb ], [] > ].

;; Jon, en mann, sover.
pop-xp-par-phrase := pop-par-phrase & 
  [ SYNSEM.LOCAL [ CAT #cat & [ STACK #2,
				HEAD #head,
				QUANT #quant & + ],
		   CONT.HOOK #hook ],
    ARGS < [ SYNSEM [ SAT +,
                      LOCAL.CAT [ HEAD adj-adv-card-cond-compl-nominal-prep,
				  VAL.SISTER anti-synsem,
				  QUANT #quant,
				  STACK < [ LOCAL.CAT.HEAD start ], [ LOCAL [ CAT #cat & [ HEAD #head ],
									      CONT.HOOK #hook ] ] . #2 > ] ] ], [] > ].

; PH 2013-01-31: Removed the ARGS.SISTER anti-synsem constraint in order to 
; allow the rule to apply to determiners and cardinals
rel-phrase := embedded-phrase & subord-rel-compl-sign & 
  [ CONJ no-conj,
    SYNSEM [ LOCAL [ CAT [ HEAD relcompl,
			   STACK < [ LOCAL.CAT [ VAL.SISTER anti-synsem,
						 CASE #case,
						 QUANT #q ],
				     MODIFIED rmod,
				     FIRST-WORD #fw & + ], ... >,
			   C - ],
		     CONT.HOOK.INDEX #0 ],
	     NON-LOCAL.SLASH < [ CAT.HEAD [ MOD #mod ],
				 CONT.HOOK.INDEX #index ] >,
	     LKEYS.KEYREL.LBL #lbl ],
    ARGS < [ SYNSEM [ LOCAL [ CAT [ HEAD adj-adv-nominal & [ MOD #mod ],
				    CASE #case,
				    QUANT #q ],
                              CONT.HOOK.INDEX #index ],
                      NON-LOCAL.SLASH <>,
		      LKEYS.KEYREL.LBL #lbl,
		      FIRST-WORD #fw ] ], ... >,
    C-CONT [ RELS <!  [ PRED "rel-clause_rel",
			ARG0 #0 ] !>,
	     HCONS <!!> ] ].

; PH 2006-12-02: Constrained the daughter to have SISTER value anti-synsem 
unary-rel-min := rel-phrase & unary-phrase &
  [ SYNSEM.FIRST-WORD +,
    SYNSEM [ MODIFIED notmod,
	     LOCAL [ CAT [ HEAD [ RESTRICTED +,
				  MOD < [ LOCAL.CAT.HEAD adj-adv-nominal ] > ],
                           CASE subj-case,
			   STACK < [ LOCAL.CAT.VAL.CMP2.LINK arg2-,
				     NON-LOCAL.SLASH <> ], ... >,
			   VBL synsem ],
		     CONT.HOOK [ INDEX event ] ],
	     EXTR - ],
    ARGS < [ SYNSEM [ LOCAL.CAT [ STACK.FIRST.LOCAL.CAT.HEAD compl-verb ],
		      FIRST-WORD +,
		      MODIFIED notmod,
                      SAT - ] ] > ].

; PH 2016-09-16: Constrained slashed elemets MOD list to be empty in order
; to avoid that nominal phrases
; are extracted as adjuncts. "[alle mine to] hunder bjeffer _"
; PH 2016-09-14: Linked SLASH.HEAD with ARGS.FIRST.HEAD.
unary-rel-phrase := unary-rel-min &
  [ SYNSEM [ NON-LOCAL.SLASH < [ CAT.HEAD #head & [ MOD <> ] ] >,
	     LKEYS.KEYREL.ARG0.RESTR + ],
    ARGS < [ SYNSEM [ LOCAL.CAT [ HEAD #head & card-commnoun-det-quant,
				  QUANT + ],
		      LKEYS.Q.QREL.PRED non-bare_q ] ] > ].

wh-rel-phrase := unary-rel-min &
  [ SYNSEM.NON-LOCAL.SLASH < [ CAT [ HEAD #head & adj-adv & [ NOM - ],
				     VAL.SISTER #sis & synsem ],
			       EXTR-REL [ PRED restr_rel_rel,
					  ARG1 #png ] ] >,
    ARGS < wh-min &
	   [ SYNSEM [ LOCAL.CAT [ HEAD #head,
				  VAL.SISTER #sis ],
		      LKEYS [ KEYREL.ARG1 #png,
			      Q.QREL.PRED anti-quant_m_rel ] ] ]> ].

binary-rel-phrase := rel-phrase & binary-phrase &
  [ SYNSEM phr-synsem &
	   [ LOCAL [ CAT [ HEAD [ RESTRICTED + ],
                           STACK < [ SAT #sat,
                                     NON-LOCAL.SLASH <> ], ... >,
			   VBL synsem ],
		     CONT.HOOK [ LTOP #lbl2,
                                 INDEX event & [ RESTR #restr ] ] ],
	     NON-LOCAL.SLASH < [ CAT.HEAD noun-pn ] > ],
    ARGS < [ SYNSEM [ SAT #sat,
                      LOCAL [ CAT [ QUANT + ] ],
                      MODIFIED notmod-or-rmod ] ],
           rel-compl-sign &
           [ SYNSEM [ LOCAL.CAT.VBL.LOCAL.CONT.HOOK [ LTOP #lbl2,
						      INDEX [ E.TENSE finite ] ],
		      LKEYS.KEYREL.ARG0.RESTR #restr ] ] >].

arg0 := arg1- & arg2- & arg3- & arg4- & prt-.
rel-compl-sign := subord-rel-compl-sign &
  [ SYNSEM [ LOCAL [ CAT [ HEAD relcompl & 
                              [ MOD < [ LOCAL [ CAT [ HEAD nominal & 
                                                        [ AGREE #agr ] ],
                                                CONT.HOOK [ INDEX #1 ] ],
                                        LEX + ] > ],
                           VBL anti-synsem & 
				[ LOCAL [ CONT.HOOK [ INDEX.E.TENSE finite ] ] ],
			   VAL [ CMP1.LINK arg1-,
                                 CMP2.LINK arg2-,
                                 CMP3.LINK arg3-,
                                 CMP4.LINK arg4- ] ],
                     CONT [ RELS <! !>,
			    HCONS <!!> ] ],
	     NON-LOCAL.SLASH < [ CAT [ HEAD nominal & 
                                               [ AGREE #agr ] ],
                                    CONT.HOOK [ INDEX #1 ] ] > ] ].

rel-compl-word := rel-compl-sign & norm-lex-item & mod-word & keyrel-lex-item &
  [ SYNSEM.LKEYS.KEYREL [ PRED "rel-clause_rel",
			  ARG0.RESTR + ] ].

nonrestr-rel-compl-word := rel-compl-sign & norm-lex-item & mod-word & keyrel-lex-item &
  [ SYNSEM.LKEYS.KEYREL.ARG0.RESTR - ].

basic-predicate-phrase := binary-phrase &
  [ SYNSEM.LOCAL.AGR #agr,
    ARGS < [ SYNSEM.LOCAL.AGR #agr ], [ SYNSEM.LOCAL.AGR #agr ] > ].

; PH 2014-01-28: New type for words that has the same c-structure mother as
; the previous word, hence no stacking or embedding.
in-const-struct := phrase &
  [ SYNSEM phr-synsem &
    	   [ LOCAL [ CAT [ HEAD #head,
                           STACK #stack ] ] ],
    ARGS < [ BOUNDARY -,
	     SYNSEM [ LOCAL [ CAT [ HEAD #head,
                                    STACK #stack ] ] ] ], ... > ]. 

; PH 2020-05-20: Added ELLREL.PRED arg1+ & arg2+ in order to constrain rule.
ellipsis-phrase := in-const-struct & unary-phrase &
  [ SYNSEM [ LOCAL [ CAT [ C -,
			   HEAD #head & aux-verb & [ ELLIPSIS + ],
			   VBL anti-synsem,
			   VAL #val & [ ARGFRAME #ellpred ],
			   ARGUMENT #arg & [ LOCAL.CAT.CASE subj-case ] ],
		     TOPIC #topic,
		     CONT [ HOOK #hook,
			    MSG #msg ],
		     AGR #agr ],
	     NON-LOCAL #nl & [ SLASH < [] > ],
	     LKEYS #lkeys ],
    ARGS < [ SYNSEM [ LOCAL [ CAT [ HEAD #head & [ ELLIPSIS + ],
				    C +,
				    VBL synsem,
				    ARGUMENT #arg,
				    VAL #val,
				    INTRANS - ],
			      TOPIC #topic,
			      CONT [ HOOK #hook & [ LTOP #ltop ],
				     MSG #msg ],
			      AGR #agr ],
		      NON-LOCAL #nl,
		      LKEYS #lkeys & [ KEYREL #keyrel,
				       CNSTR #keyrel,
				       ELLREL #keyrel & [ LBL #ltop,
							  PRED #ellpred & arg1+ & arg2+ ] ] ] ] >,
    C-CONT [ RELS <! #keyrel !>,
	     HCONS <!!> ],
    BOUNDARY -,
    LINK-INPUT - ].


ellipsis-vp-phrase := ellipsis-phrase &
  [ SYNSEM.LKEYS.ELLREL.PRED arg1+ & arg2+ & arg3+,
    ARGS < coord-vp-phrase > ].

ellipsis-s-phrase := ellipsis-phrase &
  [ ARGS < pop-phrase-min > ].

; DEBUG 2013-11-22: Removed the LKEYS - ARGS.REST.FIRST.LKEYS link
; PH 2017-07-03: Removed MESS and MSG links in the mother (they used to be linked to the second daughter)
verbal-phrase-min :=  basic-predicate-phrase & in-const-struct &
		      comp-copy-phrase &
  [ START -,
    SYNSEM [ LOCAL [ CAT [ HEAD [ COMPL-PASS #cp,
				  CATEGORY #c,
				  ELLIPSIS - ],
                           VBL #sel2,
			   ARGUMENT [ LOCAL.CAT.CASE case ],
			   INTRANS #intrans ],
                     TOPIC #topic,
                     CONT [ HOOK [ INDEX [ SF #sf ] ] ],
		     AGR #agr,
		     NEG-OUT #negout ],
             MODIFIED xmod,
             NON-LOCAL #list,
             LEX -,
             PHR +,
	     LKEYS [ CNSTR #cnstr,
		     KEYREL #cnstr,
	     ALTKEYREL #altkeyrel ] ],
    ARGS < [ SYNSEM [ FIRST-WORD +,
		      LOCAL [ CAT [ HEAD compl-verb & 
					 [ AGREE #agree ],
                                    ARGUMENT [ LOCAL.CAT.CASE case ],
				    VBL #sel,
				    CONJ-CAT #c,
				    INTRANS #intrans ],
                              TOPIC #topic,
			      CONT [ HOOK [ INDEX.SF #sf,
					    XARG #xarg,
					    PARG #parg ] ],
			      AGR #agr,
			      NEG-OUT #negout ],
		      NON-LOCAL #list,
		      LKEYS [ CNSTR #cnstr,
			      KEYREL #cnstr,
			      ALTKEYREL #altkeyrel ] ],
	     LINK-INPUT -,
	     CONJ no-pre-conj ],
	   phrase-or-lexrule &
	   [ BOUNDARY -,
	     SYNSEM #sel &
		    [ LOCAL [ CAT [ HEAD aux-verb &
					 [ AGREE #agree,
					   COMPL-PASS #cp,
					   MESS #msg ],
				    VBL #sel2,
				    ARGUMENT synsem-min ],
			      CONT [ HOOK [ XARG #xarg,
						    PARG #parg ],
				     MSG #msg ],
			      AGR #agr ],
		      NON-LOCAL.SLASH <> ] ] >,
    BOUNDARY -,
    LINK-INPUT - ]. 

verbal-phrase-nonpass := verbal-phrase-min &
  [ SYNSEM.LOCAL.CAT.VAL #val,
    ARGS < [ SYNSEM.LOCAL.CAT.VAL #val ], [ ALTS.PASSIVE -,
					    SYNSEM.LOCAL.CAT.VAL #val ] > ].

verbal-phrase-main := verbal-phrase-min &
  [ ARGS < [ SYNSEM.LKEYS [ KEYREL #rel & [ LBL #lbl,
					    PRED #pred & vbl+ ],
			    CNSTR #rel ] ], 
	   [ SYNSEM [ LOCAL.CAT.HEAD mainverb,
		      LKEYS.KEYREL [ LBL #lbl,
				     PRED #pred,
				     ARG0 #ind ] ] ] >,
    C-CONT [ RELS <! #rel & [ ARG0 #ind & event & [ E.TENSE fin-infin ] ] !>,
	     HCONS <!!> ] ].

verbal-phrase-aux := verbal-phrase-min &
  [ SYNSEM [ LOCAL [ CAT.VBL.LOCAL.MODAL #modal1,
		     CONT.HOOK.LTOP handle ],
	     LKEYS.KEYREL [ LBL handle ] ],
    ARGS < [ SYNSEM.LOCAL.MODAL #modal2 ],
	   [ SYNSEM [ LOCAL [ MODAL #modal2,
			      CAT [ HEAD aux,
				    VBL.LOCAL.MODAL #modal1 ] ],
		      LKEYS.KEYREL [ LBL handle ] ] ] >,
    C-CONT [ RELS <! !>,
	     HCONS <! !>] ].

verbal-phrase-min2 := verbal-phrase-min &
  [ ARGS < [ SYNSEM.LOCAL [ CAT.HEAD aux-compl ] ], 
	   word-or-lexrule &
 	   [] > ].


verbal-imp-phrase := verbal-phrase-min2 & arg1-sign &
  [ SYNSEM [ LOCAL [ CAT #out & [ ARGUMENT.LOCAL.CAT.CASE non-subj-case,
				  AAIF - ],
		     CONT.HOOK [ LTOP #ltop,
				 INDEX.SF command_m_rel ] ],
	     LKEYS.KEYREL.LBL #ltop ],
    IN #in,
    OUT #out,
    ARGS < [ START +,
	     SYNSEM [ LOCAL.CAT #in & [ C +,
				      VAL.ARGFRAME #pred ] ] ], 
	   imp-verb & [ SYNSEM.LKEYS.KEYREL [ LBL #ltop,
					      PRED #pred ] ] >,
    C-CONT.HCONS <!!> ].

verbal-imp-main-phrase := verbal-imp-phrase &
  [ ARGS < [ SYNSEM.LKEYS [ KEYREL #rel & [ PRED #pred ],
			    CNSTR #rel ] ], 
	   [ SYNSEM [ LOCAL.CAT.HEAD mainverb,
		      LKEYS.KEYREL [ PRED #pred,
				     ARG0 #ind ] ],
	     MEANING.ARG1 #arg1 ] >,
    C-CONT.RELS <! #rel & [ ARG0 #ind & event,
			    ARG1 #arg1 ] !> ].

verbal-imp-aux-phrase := verbal-imp-phrase &
  [ ARGS < [], [ SYNSEM.LOCAL.CAT.HEAD aux ] >,
    C-CONT.RELS <! !> ].

verbal-phrase-min3 := verbal-phrase-min2 &
  [ CONJ no-conj,
    SYNSEM.LOCAL.CAT [ HEAD aux-compl,
		       ARGUMENT #arg,
		       C - ],
    ARGS < [ SYNSEM.LOCAL.CAT.ARGUMENT #arg ], 
	   [ ] > ].

verbal-c-min := verbal-phrase-min2 &
  [ SYNSEM.LOCAL [ CAT [ C -,
			 ARGUMENT.LOCAL.CAT.CASE subj-case,
			 AAIF + ],
		   CONT.HOOK #hook ],
    ARGS < [ SYNSEM.LOCAL.CAT.C + ],
	   [ SYNSEM.LOCAL [ CAT.HEAD.PERFPART -,
			    CONT.HOOK #hook & [ INDEX.E.TENSE finite ] ] ] > ].

verbal-v-min := verbal-phrase-min &
  [ SYNSEM.LOCAL [ CAT.C -,
		   CONT.HOOK #hook & [ LTOP #ltop,
				       INDEX.E #e ] ],
    ARGS < [ SYNSEM.LOCAL [ CAT.C -,
			    CONT.HOOK #hook & [ LTOP #ltop,
					INDEX.E #e ] ] ],
	   [ ] > ].


verbal-c-phrase := verbal-c-min & verbal-phrase-main & verbal-phrase-nonpass & verbal-phrase-min3 &
  [ SYNSEM [ LOCAL.CONT.HOOK.LTOP #ltop,
	     LKEYS.KEYREL.LBL #ltop ] ].

aux-c-phrase := verbal-c-min & verbal-phrase-aux & verbal-phrase-nonpass &
  [ SYNSEM.LOCAL.CAT.VBL.LOCAL [ CAT.HEAD.PERFPART #bool,
				 CONT.HOOK.INDEX.PERF #bool ] ].

verbal-min := verbal-phrase-min &
  [ SYNSEM.LOCAL.CAT [ ARGUMENT.LOCAL.CAT.CASE non-subj-case,
		       AAIF - ],
    ARGS < [ SYNSEM.LOCAL.CAT [ ARGUMENT.LOCAL.CAT.CASE non-subj-case,
				C - ] ],[]> ].

verbal-phrase := verbal-phrase-min3 & verbal-phrase-main & verbal-phrase-nonpass & verbal-min & verbal-v-min &
  [ C-CONT.HCONS <!!> ].

verbal-pass-min := verbal-phrase-min & passive-phrase-min.

verbal-pass-phrase := verbal-pass-min & verbal-min & verbal-v-min & passive-phrase-main &
  [ C-CONT.HCONS <!!> ].

verbal-c-pass-phrase := verbal-pass-min & verbal-c-min & passive-phrase-main &
  [ SYNSEM [ LOCAL.CONT.HOOK [ LTOP #ltop,
			       INDEX #index ],
	     LKEYS.KEYREL [ LBL #ltop,
			    ARG0 #index ] ] ].

verbal-c-pass-aux-phrase := verbal-pass-min & verbal-c-min & passive-phrase-aux &
  [ SYNSEM.LOCAL.CAT.VBL.LOCAL [ CAT.HEAD.PERFPART +,
				 CONT.HOOK.INDEX.PERF - ] ].

verbal-pass-aux-phrase := verbal-pass-min & verbal-min & passive-phrase-aux & verbal-v-min.

aux-phrase := verbal-phrase-min3 & verbal-phrase-aux & 
	      verbal-phrase-nonpass & verbal-v-min &
  [ SYNSEM.LOCAL.CAT [ ARGUMENT.LOCAL.CAT.CASE non-subj-case,
		       AAIF - ],
    ARGS < [ SYNSEM.LOCAL.CAT.C - ],[]> ].

; conj-verbal-phrase := verbal-phrase-min2 &
;   [ SYNSEM.LOCAL.CAT [ HEAD aux,
; 		       CASE subj-case,
; 		       ARGUMENT.LOCAL.CAT.CASE subj-case ],
;     ARGS < coord-filler-phrase &
; 	   [ SYNSEM.LOCAL.CAT.ARGUMENT.LOCAL.CAT.CASE non-subj-case ], 
; 	   [ ] > ].


non-pass-verbal-item := verbal-item &
  [ SYNSEM.LOCAL.CAT.VAL valence ].

at-om-compl-word := complementizer-word & non-gen-word &
  [ LINK-INPUT - ].

; at-om-compl-word := complementizer-word & non-gen-word &
;   [ LINK-INPUT -,
;     SYNSEM.LOCAL [ CAT.HEAD [ KEYS.KEY #pred ],
;                    CONT.RELS <! [ PRED #pred ] !> ] ].

at-complementizer-word := complementizer-word & non-gen-word &
  [ SYNSEM [ LINK comp+,
	     LOCAL.CAT.HEAD.MOD <> ] ].

; at-complementizer-word := complementizer-word & non-gen-word &
;   [ SYNSEM.LOCAL [ CAT.HEAD.MOD <>,
; 		   CONT.RELS <! [ PRED at-det-at-c ] !> ] ].

cond-complementizer-word-mini := complementizer-word & non-gen-word.

om-complementizer-word := at-om-compl-word & cond-complementizer-word-mini & wh-word &
  [ SYNSEM.LINK wh+ ].

cond-complementizer-word-min := cond-complementizer-word-mini & 
  [ SYNSEM.LOCAL [ CAT [ HEAD cadv &
			      [ MOD < [ LOCAL.CAT.HEAD compl-verb ] > ],
			 STACK <> ] ] ].

cond-complementizer-word := cond-complementizer-word-min &
  [ SYNSEM.LOCAL.CAT.HEAD.MESS prop_m_rel ].

wh-complementizer-word := cond-complementizer-word-min &
  [ SYNSEM.LOCAL.CAT.HEAD.MESS wh-question_m_rel ].

inf-phrase := embedded-phrase & subconstruction &
  [ CONJ no-conj,
    SYNSEM [ FIRST-WORD #fw,
	     LOCAL.CAT [ HEAD infcompl,
			 VAL.CMP4.MARKED -,
			 STACK < [ LOCAL.CAT #out & 
					     [ CASE non-subj-case,
					       AAIF -,
					       ARGUMENT.LOCAL.CAT.CASE non-subj-case ],
				   NON-LOCAL.SLASH <> ], ... >,
			 VBL.LOCAL.CONT.HOOK.INDEX.E.TENSE infin,
			 ARGUMENT.LOCAL.CAT.CASE non-subj-case ] ],
    MEANING #rel,
    IN #in,
    OUT #out,
    ARGS < [ SYNSEM [ FIRST-WORD #fw,
		      LOCAL.CAT #in & [ VBL anti-synsem ],
		      LKEYS.CNSTR #rel ] ], ... > ].

; ERROR: the link between LKEYS.CNSTR and ARGS.REST.FIRST.LKEYS.CNSTR
; results in an error in ACE, bur not LFG, when I parse
; "Jeg liker å smile". Conflict in CTO/CFROM (ph; 2016-02-12)

binary-inf-phrase-min := inf-phrase & binary-phrase & 
  [ SYNSEM [ LOCAL [ CAT [ HEAD infcompl,
                           STACK < [ LOCAL [ CAT #out & 
						 [ HEAD #head,
						   VAL [ CMP1.LINK arg1- ],
						   VBL #verbal,
						   C-COGN-ST type-id ],
					     CONT [ HOOK #hook,
						    MSG #msg ],
					     TOPIC #topic ],
				     LKEYS.CNSTR #rel ] . #rest >,
			   VAL #val,
                           ARGUMENT.LOCAL.CAT.CASE non-subj-case,
			   VBL synsem & 
				[ LOCAL #loc & [ CAT.HEAD.PERFPART -,
						 CONT.HOOK.INDEX #index  &
								   [ PERF - ] ],
				  LKEYS.CNSTR #rel2 ] ],
		     CONT.HOOK [ LTOP #lbl2,
                                 INDEX event ] ],
             NON-LOCAL #sl,
	     LKEYS.CNSTR #rel2 ],
    OUT #out,
    IN #cat,
    ARGS < [ SYNSEM [ FIRST-WORD +,
		      LOCAL [ CAT #cat & 
                                  [ HEAD #head & adj-adv-compl-noun-prep-verb,
                                    STACK #rest,
				    VAL [ CMP2.LOCAL [ CAT.HEAD infcompl ],
					  PART prt- ],
				    VBL #verbal,
				    CASE case ],
			      CONT [ HOOK #hook & [ LTOP #lbl ],
				     MSG #msg ],
			      TOPIC #topic ],
		      NON-LOCAL #sl,
		      LKEYS.CNSTR #rel & [ LBL #lbl ] ] ],
	   inf-word &
	   [ SYNSEM [ LOCAL [ CAT [ HEAD infcompl,
				    VAL #val,
				    VBL synsem & [ LOCAL #loc ] ],
			      CONT.HOOK [ LTOP #lbl2,
					  INDEX #index ] ],
		      LKEYS [ KEYREL [ LBL #lbl2,
				       ARG0 #index ],
			      CNSTR relation ] ] ] >,
    C-CONT [ RELS <! !> ],
    LINK-INPUT + ].

binary-inf-phrase := binary-inf-phrase-min &
  [ ARGS < [ SYNSEM.LOCAL.CAT.HEAD adj-compl-nominal-verb ], [] > ].

binary-1inf-phrase := binary-inf-phrase &
  [ ARGS < [ SYNSEM [ LOCAL.CAT.VAL [ CMP1.LOCAL #cmp,
				      CMP3.LINK arg3- ],
		      LKEYS.CNSTR.ARG1 #index ] ],
	   [ SYNSEM.LOCAL #cmp & [ CONT.HOOK.INDEX #index ] ] > ].

binary-2inf-phrase := binary-inf-phrase-min &
  [ ARGS < [ SYNSEM [ LOCAL.CAT.VAL [ CMP2.LOCAL #cmp2,
				      CMP3.LINK arg3- ],
		      LKEYS.CNSTR.ARG2 #index ] ],
	   [ SYNSEM.LOCAL #cmp2 & [ CONT.HOOK.INDEX #index ] ] > ].

binary-4inf-phrase := binary-inf-phrase &
  [ ARGS < [ SYNSEM [ LOCAL.CAT.VAL [ CMP4.LOCAL #cmp4 ],
		      LKEYS.KEYREL.ARG4 #index ] ],
	   [ SYNSEM.LOCAL #cmp4 & [ CONT.HOOK.INDEX #index ] ] > ].

extr-inf-phrase := subconstruction &
  [ SYNSEM.LOCAL [ CAT #out & [ HEAD subcompl-infcompl-verb &
				     [ MESS prop_m_rel ],
				STACK #stack,
				ARGUMENT.LOCAL.CONT.HOOK.INDEX #index ],
		   TOPIC [ CAT #cat,
			   CONT #cont,
			   EXTR-REL #relation ] ],
    ARGS < [ SYNSEM [ LOCAL.CAT #in & [ STACK #stack ],
		      NON-LOCAL.SLASH < local-min &
					[ CAT #cat & [ HEAD infcompl ],
					  CONT #cont & [ HOOK.XARG #index ],
					  EXTR-REL #relation ] > ,
		      LKEYS.KEYREL #rel ] ] >,
    BOUNDARY -,
    IN #in,
    OUT #out,
    MEANING #rel ].

extr-2inf-phrase := extr-inf-phrase & arg2-val-min &
  [ ARGS < [ SYNSEM [ LOCAL.CAT.VAL.CMP4.LINK arg4-,
		      NON-LOCAL.SLASH < [ CONT.HOOK.INDEX #event ] > ,
		      LKEYS.KEYREL.ARG2 #event ] ] > ].

extr-4inf-phrase := extr-inf-phrase & arg4-val-min &
  [ ARGS < [ SYNSEM [ NON-LOCAL.SLASH < [ CONT.HOOK.INDEX #event ] > ,
		      LKEYS.KEYREL.ARG4 #event ] ] > ].

ip-phrase := arg2-sign &
  [ ARGS.FIRST.SYNSEM [ LOCAL.CAT [ HEAD.SU-IND #ind,
				    VAL.CMP2.LOCAL.CONT.HOOK.XARG #ind ],
			LKEYS.KEYREL.PRED rais ] ].

2ip-phrase := arg2-sign &
  [ SYNSEM.LOCAL.CAT.ARGUMENT.LOCAL.CONT.HOOK.INDEX #ind,
    ARGS.FIRST.SYNSEM [ LKEYS.KEYREL.PRED 2ip,
			LOCAL.CAT [ HEAD prep,
				    VAL.CMP1.LOCAL.CONT.HOOK.INDEX #ind ] ] ].

2ip1-phrase := arg2-sign &
  [ SYNSEM.LOCAL.CAT.ARGUMENT.LOCAL.CONT.HOOK.INDEX #ind,
    ARGS.FIRST.SYNSEM [ LKEYS.KEYREL.PRED 2ip1,
			LOCAL.CAT.VAL.CMP1.LOCAL.CONT.HOOK.INDEX #ind ] ].

2ip3-phrase := arg2-sign &
  [ SYNSEM.LOCAL.CAT.ARGUMENT.LOCAL.CONT.HOOK.INDEX #ind,
    ARGS.FIRST.SYNSEM [ LKEYS.KEYREL.PRED 2ip3,
			LOCAL.CAT.VAL.CMP3.LOCAL.CONT.HOOK.INDEX #ind ] ].

2ip4-phrase := arg2-sign &
  [ SYNSEM.LOCAL.CAT.ARGUMENT.LOCAL.CONT.HOOK.INDEX #ind,
    ARGS.FIRST.SYNSEM [ LKEYS.KEYREL.PRED 2ip4,
			LOCAL.CAT.VAL.CMP4.LOCAL.CONT.HOOK.INDEX #ind ] ].

4ip1-phrase := arg4-sign &
  [ SYNSEM.LOCAL.CAT.ARGUMENT.LOCAL.CONT.HOOK.INDEX #ind,
    ARGS.FIRST.SYNSEM [ LKEYS.KEYREL [ PRED 4ip1,
				       ARG1 #ind ],
			LOCAL.CAT.VAL [ CMP1.LOCAL.CONT.HOOK.INDEX #ind,
					CMP4.MARKED + ] ] ].

4ip2-phrase := arg4-sign &
  [ SYNSEM.LOCAL.CAT.ARGUMENT.LOCAL.CONT.HOOK.INDEX #ind,
    ARGS.FIRST.SYNSEM [ LKEYS.KEYREL.PRED 4ip2,
			LOCAL.CAT.VAL [ CMP2.LOCAL.CONT.HOOK.INDEX #ind,
					CMP4.MARKED + ] ] ].

binary-ip-phrase := ip-phrase & binary-inf-phrase.
binary-2ip-phrase := 2ip-phrase & binary-2inf-phrase &
  [ SYNSEM.LKEYS.KEYREL.ARG0 #index,
    ARGS < [ SYNSEM.LKEYS.KEYREL.ARG2 #index ], [] > ].
binary-2ip1-phrase := 2ip1-phrase & binary-2inf-phrase & binary-inf-phrase.
binary-2ip3-phrase := 2ip3-phrase & binary-2inf-phrase & binary-inf-phrase.
binary-2ip4-phrase := 2ip4-phrase & binary-2inf-phrase & binary-inf-phrase.
extr-2ip1-phrase := 2ip1-phrase & non-subj-extr & extr-2inf-phrase.
extr-2ip3-phrase := 2ip3-phrase & non-subj-extr & extr-2inf-phrase.
extr-2ip4-phrase := 2ip4-phrase & non-subj-extr & extr-2inf-phrase.

binary-4ip1-phrase := 4ip1-phrase & binary-4inf-phrase.
binary-4ip2-phrase := 4ip2-phrase & binary-4inf-phrase.
extr-4ip1-phrase := 4ip1-phrase & non-subj-extr & extr-4inf-phrase.
extr-4ip2-phrase := 4ip2-phrase & non-subj-extr & extr-4inf-phrase.

1ip-phrase := arg1-sign &
  [ ARGS.FIRST.SYNSEM.LKEYS.KEYREL.PRED 1ip ].
binary-1ip-phrase := 1ip-phrase & binary-1inf-phrase & subj-val.
extr-1ip-phrase := 1ip-phrase & extr-inf-phrase & subj-extr & arg1-val.


; PH 2016-05-26: Took out the STACK AAIF link to ARGS.FIRST AAIF in order to
; account for "Jeg lar deg ikke beundre Kari"
unary-inf-phrase := basic-unary-phrase & arg2-sign & inf-phrase &
  [ SYNSEM [ LOCAL [ CAT [ HEAD infcompl,
                           CASE non-subj-case,
                           STACK < [ LOCAL [ CAT #out & ;
						 [ HEAD #head,
						   VAL [ CMP1.LINK arg1-,
							 CMP2.LINK arg2- ],
						   AAIF bool,
						   CASE case,
						   C-COGN-ST activ-or-less ],
					     CONT [ HOOK #hook,
						    MSG #msg ],
					     TOPIC #topic ] ] .#rest >,
			   VAL [ ARGFRAME #1,
				 CMP1.LINK #1,
				 CMP2.LINK #1,
				 CMP3.LINK #1,
				 CMP4 [ LINK #1,
					MARKED - ],
				 PART #1 ],
			   ARGUMENT.LOCAL [ CONT.HOOK.INDEX #xarg,
					    CAT.CASE non-subj-case ],
			   VBL synsem & 
				[ LOCAL.CONT.HOOK [ LTOP handle,
						    INDEX [ E.TENSE infin ] ] ] ],
		     CONT.HOOK [ INDEX event ] ],
	     NON-LOCAL #sl,
	     --PHR-KEY arg2-rel-min ],
    OUT #out,
    IN #cat,
    MEANING #rel,
    ARGS < phrase &
	   [ SYNSEM [ LOCAL [ CAT #cat & 
				  [ HEAD #head & subcompl-infcompl-verb,
				    STACK #rest & 0-1-list,
				    VAL [ ARGFRAME arg2+ & arg1+,
					  CMP1.LINK arg1-,
					  CMP3 [ LINK arg3-,
                                                 LOCAL.CONT.HOOK.INDEX #xarg ],
					  CMP2 [ SAT -,
						 LINK 2vp,
						 LOCAL [ CAT [ HEAD infcompl,
							       VBL.LOCAL.CONT.HOOK.INDEX.E.TENSE infin ],
						    CONT.HOOK.XARG #xarg ] ] ],
				    AAIF bool,
				    VBL anti-synsem ],
			      CONT [ HOOK #hook & [ LTOP #lbl2 ],
				     MSG #msg ],
			      TOPIC #topic ],
		      NON-LOCAL #sl,
		      LKEYS.CNSTR #rel & [ LBL #lbl2 ] ] ] >,
    C-CONT [ RELS <! !>,
	     HCONS <!!> ],
    LINK-INPUT + ].

unexpr-subj := head-only & subconstruction & gap-unary & phrasal &
  [ SYNSEM [ LOCAL [ CAT #out & 
			 [ VAL.PART #part,
			   STACK #st,
			   VBL #verbal,
			   CASE #c,
			   AAIF #ca,
			   AAIF #fc,
			   ARGUMENT.LOCAL [ CAT.CASE non-subj-case,
					CONT.HOOK.INDEX event-or-ref-index ] ],
		     CONT [ HOOK #hook & [ LTOP #lbl,
					   INDEX #event,
					   XARG #ind ],
			    MSG #msg ] ],
	     LKEYS.KEYREL #rel,
	     FIRST-WORD #fw ],
    ARGS < [ SYNSEM [ LOCAL [ CAT #in & [ HEAD infcompl-verb,
					VAL.PART #part,
					STACK #st,
					CASE #c,
					AAIF #ca,
					AAIF #fc,
					ARGUMENT.LOCAL.CONT.HOOK.INDEX #ind,
					VBL #verbal ],
			    CONT [ HOOK #hook,
				   MSG #msg ] ],
		      LKEYS [ KEYREL #rel & [ LBL #lbl,
					      ARG0 #event ],
			      CNSTR #rel ],
		      FIRST-WORD #fw & + ],
	     LINK-INPUT +,
	     INFLECTED + ] >,
    C-CONT [ HCONS <!!>,
	     RELS <! !> ],
    IN #in,
    OUT #out,
    MEANING #rel,
    BOUNDARY -,
    LINK-INPUT -,
    INFLECTED + ].

pres-unexpr-phrase := unexpr-subj & 
  [ SYNSEM [ LOCAL [ CAT [ HEAD [ SU-IND #ind & expl-ind ],
			   VAL #val & 
				[ CMP1.LINK arg1-,
				  CMP2.LOCAL.CONT.HOOK.INDEX.COGN-ST type-id ],
			   ARGUMENT.LOCAL.CAT.CASE non-subj-case,
			   VBL #verbal ],
		     CONT.HOOK.XARG #ind ],
	     LKEYS #lk ],
    ARGS < inf-phrase & [ SYNSEM [ LOCAL.CAT [ VAL #val,
				  ARGUMENT.LOCAL [ CAT [ HEAD noun ],
						   CONT.HOOK.INDEX #ind ],
				  VBL #verbal ],
		      LKEYS #lk ] ] > ].

unexpr-ind-subj := unexpr-subj &
  [ ARGS < [ SYNSEM.LOCAL.CAT.ARGUMENT.LOCAL.CONT.HOOK.INDEX individual ] > ].
arg1-unexpr := unexpr-ind-subj & arg1-sign.
arg2-unexpr := unexpr-ind-subj & arg2-sign.
arg3-unexpr := unexpr-ind-subj & arg3-sign.

inf-min := non-gen-word & non-pass-verbal-item & basic-complementizer-sign & keyrel-lex-item &
  [ SYNSEM [ LOCAL [ CAT [ HEAD infcompl,
                           ARGUMENT.LOCAL.CAT.CASE non-subj-case,
                           VBL synsem & 
				[ LOCAL.CONT.HOOK.INDEX.E.TENSE infin ] ],
		     CONT [ HOOK [ INDEX event & [ E.TENSE tense ] ],
			    RELS <!  !> ] ],
	     NON-LOCAL.SLASH <> ] ].

basic-inf := subconstruction & inf-min &
  [ SYNSEM [ LOCAL [ CONT [ HOOK [ LTOP #lbl,
				   XARG event-or-ref-index ] ] ],
	     LKEYS.CNSTR relation & [ LBL #lbl ] ],
    IN.ARGUMENT.LOCAL.CAT.CASE subj-case,
    MEANING relation ].

inf-word-min := inf-min &
  [ SYNSEM [ FIRST-WORD -,
	     LOCAL.CONT [ RELS <! !>,
			  HCONS <!!> ] ],
    LINK-INPUT + ].

inf-word := inf-word-min.
inf-word2 := inf-word-min.

pres-inf := inf-min &
  [ SYNSEM [ FIRST-WORD -,
	     LOCAL [ CAT.VAL.CMP2.LOCAL.CONT.HOOK.INDEX.COGN-ST type-id,
		     CONT [ HOOK.XARG expl-ind,
			    RELS <! !> ] ] ],
    LINK-INPUT - ].

arg1-inf := basic-inf & arg1-sign.
arg2-inf := basic-inf & arg2-sign.
arg3-inf := basic-inf & arg3-sign.


;;;;;
;;;;;   HEAD FILLER PHRASE
;;;;;
; PH 2016-03-16; linking KEYREL to EXTR-REL in order to grab all the
; features in the KEYREL with the filler rule in case the filler is a
; proper noun. The filler rule has issues with character posistions 
; specified on the relation in certain contexts.
; PH 2016-01-26; Made a link between LKEYS.KEYREL.PRED and
; ARGS.REST.FIRST.LKEYS.KEYREL.PRED in order for nouns to get their
; PRED value visible higher up. The relation will be filled in by the
; popping rule.
emb-filler-phrase := nextword-phrase &
  [ SYNSEM phr-synsem &
	   [ LOCAL [ CAT [ HEAD #head &
				[ MESS #mess,
				  ELLIPSIS - ],
			   VAL valence & [ CMP4.MARKED - ],
			   QUANT #q & bool,
			   ARGUMENT #arg,
			   VBL #vbl,
			   COMPARATIVE #cmp,
			   AAIF #aaif,
			   C #c,
			   STACK < [ LOCAL [ CAT [ HEAD aux-verb &
							[ ELLIPSIS #ell,
							  MESS prop-wh_m_rel ],
						   VAL #val2,
						   ARGUMENT.LOCAL.CAT.CASE case,
						   VBL #vbl2 & 
							[ LOCAL.CAT.ARGUMENT.LOCAL.CAT.CASE subj-case ],
						   C +,
						   CASE #case,
						   INTRANS #intrans ],
					     TOPIC #local,
					     CONT [ HOOK.INDEX [ SF #mess & 
								    prop-wh_m_rel,
								 E.TENSE finite ] ],
					     NEG-OUT #negout ],
				     NON-LOCAL [ SLASH < [ CAT [ HEAD #head,
							       CASE case & 
								    [ SU #su ],
							       VAL valence,
							       QUANT #q ],
							   AGR #agr,
							   CONT.HOOK #hook,
							   TOPIC #local,
							   EXTR-REL #rel,
							   EXTR-LINK #link ] > ] ] > ],
		     CONT.HOOK #hook ],
	     LKEYS [ KEYREL relation,
		     ALTKEYREL #altkeyrel,
		     Q #qitems ],
	     NON-LOCAL.SLASH <> ],
    ARGS < [ START +,
	     SYNSEM [ LOCAL.CAT [ HEAD.ELLIPSIS #ell,
				  VAL #val2,
				  VBL #vbl2,
				  INTRANS #intrans ] ] ],
	   word &
	   [ SYNSEM [ LINK #link,
		      LOCAL #local & 
			    [ CAT [ HEAD head,
				    VAL valence,
				    QUANT #q,
				    ARGUMENT #arg,
				    VBL #vbl,
				    COMPARATIVE #cmp,
				    AAIF #aaif,
				    C #c,
				    CASE #case & [ SU #su ],
				    INTRANS #intrans ],
			      AGR #agr,
			      EXTR-REL #rel & [ PRED #pred ],
			      NEG-IN prop-wh_m_rel,
			      NEG-OUT #negout ],
		      LKEYS [ KEYREL relation & [ PRED #pred ],
			      ALTKEYREL #altkeyrel,
			      Q #qitems ] ],
	     LINK-INPUT #bool ] >,
    LINK-INPUT #bool ].


emb-fill-nom-phrase := emb-filler-phrase &
  [ SYNSEM [ LOCAL.CAT [ HEAD adj-nominal &
			      [ NOM + ],
			 STACK < [ NON-LOCAL [ SLASH < [ CAT [ HEAD #head,
							       CASE case & 
								    [ SU #case ],
							       VAL #val,
							       QUANT #q ],
							 AGR #agr,
							 CONT.HOOK #hook,
							 TOPIC #local ] > ] ] > ],
	     LKEYS #lkeys ],
    ARGS < [ ],
	   [ SYNSEM [ LOCAL #local & 
			    [ CAT [ HEAD #head,
				    VAL #val,
				    QUANT #q,
				    CASE case & [ SU #case ] ],
			      AGR #agr,
			      CONT.HOOK #hook ],
		      LKEYS #lkeys,
		      SAT + ] ] >,
    C-CONT [ RELS <! !>,
	     HCONS <! !> ] ].

emb-fill-no-nom-phrase := emb-filler-phrase &
  [ SYNSEM.LOCAL.CAT [ HEAD #head & adj-adv-prep-sadv,
		       VAL.SISTER anti-synsem,
		       STACK < [ NON-LOCAL.SLASH < [ CAT.HEAD #head ] > ] > ],
    ARGS <[],[SYNSEM.LOCAL.CAT.HEAD #head ]> ].

filler-input := sign.

coord-filler-phrase :=  uni-link & basic-binary-phrase &
  [ SYNSEM [ LOCAL [ CAT [ HEAD aux,
			   STACK <>,
			   VBL synsem & [ LOCAL.CONT.HOOK #hook ],
			   ARGUMENT.LOCAL.CAT.CASE non-subj-case ],
                     TOPIC #local,
                     CONT [ HOOK #hook & [ INDEX.SF #mess & prop-wh_m_rel ],
                            MSG #mess ] ],
             NON-LOCAL [ SLASH < #local > ],
             --PHR-KEY no-msg ],
    ARGS < filler-input &
	   [ SYNSEM.LOCAL.CONT.HOOK #hook ], 
	   [ SYNSEM [ SAT +,
                      LOCAL #local & 
                            [ CAT [ HEAD adj-adv-card-cond-compl-noun-prep &
                                         [ MESS #mess ],
                                    STACK <>,
				    VBL anti-synsem ],
			      CONT.HOOK.INDEX event-or-ref-index ],
		      NON-LOCAL.SLASH <> ],
	     BOUNDARY - ] >,
    C-CONT [ RELS <! !>,
	     HCONS <!!> ],
    LINK-INPUT - ].


;;;;;
;;;;;   FORCE PHRASES
;;;;;

neg-link := phrase &
  [ ARGS.FIRST.SYNSEM.LOCAL.CAT.VAL [ CMP1.LINK arg1-,
				      CMP2.LINK arg2-,
				      CMP3.LINK arg3-,
				      CMP4.LINK arg4-,
				      PART prt- ] ].

force-phrase-min := clause & basic-unary-phrase & neg-link &
  [ SYNSEM [ LOCAL [ CAT [ HEAD #1 & aux-verb & [ MOD <>,
                                             CATEGORY verb-cat ],
			   INTRANS #intrans,
			   VAL [ CMP1.LINK arg1-,
                                 CMP2.LINK arg2-,
                                 CMP3.LINK arg3-,
                                 CMP4.LINK arg4-,
				 PART prt- ],
                           STACK <> ],
                     CONT [ HOOK [ LTOP #harg,
				   INDEX #ind & [ SF #msg ] ],
			    RELS #rels,
                            MSG #msg ] ],
             NON-LOCAL.SLASH <>,
	     LKEYS.KEYREL #keyrel,
             PHR +,
             SAT + ],
    LINK-INPUT -,
    C-CONT [ RELS <! !>,
	     HCONS <! qeq & [ HARG #harg,
			      LARG #larg ] !>],
    ARGS < phrase-or-lexrule & 
           [ SYNSEM [ FIRST-WORD +,
		      LOCAL [ CAT [ HEAD #1,
				    INTRANS #intrans,
                                    ARGUMENT anti-synsem & [ LOCAL.CAT.CASE non-subj-case ] ],
                                CONT [ HOOK [ LTOP #larg,
					      INDEX #ind ],
				       RELS #rels,
				       MSG #msg ] ],
		      NON-LOCAL.SLASH <>,
		      LKEYS.KEYREL #keyrel ],
	     BOUNDARY -,
	     CONJ no-conj ] >,
    BOUNDARY + ].

force-phrase := force-phrase-min &
  [ ARGS < [ SYNSEM.LOCAL.CAT [ VBL anti-synsem,
				STACK <> ] ] > ].

main-phrase := force-phrase &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.SF prop-wh_m_rel & #mess,
    PUNCT no-punct-or-period,
    ARGS < [ SYNSEM.LOCAL.TOPIC local & [ CAT.HEAD.MESS #mess ] ] >].

yes-no-phrase := interrogative-clause & force-phrase & gap-unary &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.SF yes-no-ques_m_rel,
    ARGS < [ SYNSEM [ LOCAL [ CAT [ VBL anti-synsem,
				    HEAD.MESS yes-no-ques_m_rel ],
			      TOPIC no-topic ],
		      MODIFIED notmod-or-rmod ] ] >,
    PUNCT no-punct-or-quest-mark  ].

imperative-phrase := imperative-clause & force-phrase-min & gap-unary &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.SF command_m_rel,
    C-CONT.RELS <! !>,
    ARGS < [ SYNSEM [ LOCAL.CAT [ VBL anti-synsem,
				  STACK <>,
				  HEAD.MESS command_m_rel ],
		      MODIFIED notmod-or-rmod ] ] >,
    PUNCT no-punct-or-exclam-mark ].

cond-subord-phrase-min := clause & 
  [ SYNSEM [ LOCAL [ CAT [ HEAD cond & [ MOD < [ LOCAL.CAT.HEAD aux-verb ] > ],
                           VAL #val,
                           STACK #stack ],
                     CONT [ HOOK.INDEX.SF basic-message_m_rel,
                            MSG basic-message_m_rel ] ],
             NON-LOCAL.SLASH <>,
	     PHR +,
             SAT + ],
    C-CONT [ RELS <! !>,
	     HCONS <!!> ],
    ARGS < [ CONJ no-conj,
	     SYNSEM [ LOCAL [ CAT [ HEAD aux-verb,
				    VAL #val & [ CMP1.LINK arg1-,
						 CMP2.LINK arg2-,
						 CMP3.LINK arg3-,
						 CMP4.LINK arg4- ],
				    VBL anti-synsem,
				    STACK #stack & 
			    < [ LOCAL.CAT.HEAD start ] > ],
			      CONT.MSG yes-no-ques_m_rel ],
		      NON-LOCAL.SLASH <>,
		      MODIFIED notmod-or-rmod ],
	     BOUNDARY - ], ... >,
    BOUNDARY - ].

; Removed the LKEYS - ARGS.REST.FIRST.LKEYS link in order to avoid getting 
; the keyrel of complementizers as the keyrel of the subordinate clause. 
;                                                              (2016-01-16; ph)
; FIXME: The slashed item should have the index of the filler. (2015-02-24; ph)
cond-embedded-phrase := embedded-phrase &
  [ SYNSEM [ LOCAL [ CAT [ STACK < [ LOCAL [ CAT [ HEAD subcompl-infcompl-verb,
						   CASE #case,
						   MC #luk,
						   ARGUMENT #arg,
						   C-COGN-ST #cc,
						   STACK #stack,
						   COMPARATIVE #cmp ] ],
				     NON-LOCAL.SLASH < [ CAT #cat,
							 CONT [ MSG #msg ] ] > ] > ] ],
	     MODIFIED xmod ],
    ARGS < [ SYNSEM synsem & [ LOCAL [ CAT [ CASE #case,
					     MC #luk,
					     ARGUMENT #arg,
					     C-COGN-ST #cc,
					     STACK #stack,
					     COMPARATIVE #cmp ],
				       CONT.MSG #msg ] ],
	     BOUNDARY - ], 
	   [ SYNSEM [ LOCAL [ CAT #cat ] ] ] > ].

filler-phrase := emb-filler-phrase & cond-embedded-phrase & 
			     binary-phrase & comp-copy-phrase.

sem-filler-phrase := filler-phrase & 
  [ SYNSEM [ LOCAL [ CAT [ VAL #valence,
			   STACK < [ NON-LOCAL.SLASH < [ CAT.VAL #valence,
							 CONT.HOOK.INDEX #index,
							 EXTR-REL #rel ] > ] > ],
		     CONT.HOOK.INDEX #index ],
	     LKEYS.KEYREL #rel ],
    ARGS < [], [ SYNSEM [ LOCAL [ CAT.VAL #valence ],
			  LKEYS.KEYREL #rel ] ] > ].

cadv-filler-phrase := filler-phrase & uni-link &
  [ SYNSEM [ LOCAL.CAT [ HEAD cadv,
			 VBL synsem ], ;
	     LKEYS.KEYREL.ARG0 #arg2 ],
    ARGS < [], [ SYNSEM [ LOCAL.EXTR-REL #rel & [ ARG2 #arg2 ],
			  LKEYS.KEYREL #rel & [ PRED cadv+ ] ] ] >,
    C-CONT [ RELS <! #rel !>,
	     HCONS <!!> ] ].

; PH 2019-02-28: Removed ARGS.REST.FIRST.KEYREL.PRED arg3- & arg4- & prp+
; constraint in order to make generation work.
; ex: Alene smiler mannen.
adv-filler-phrase := sem-filler-phrase &
  [ SYNSEM [ LOCAL.CAT [ HEAD adv-prep-sadv,
		       VAL [ CMP2.LINK #link,
			     CMP3.LINK #link,
			     CMP4.LINK #link ],
		       VBL anti-synsem ],
	     LKEYS [ KEYREL #keyrel & [ PRED #link,
					ARG0 #arg0 ],
		     Q.QREL.PRED anti-quant_m_rel ] ],
    ARGS < [], [ SYNSEM.LKEYS.KEYREL [ PRED #link,
				       ARG0 #arg0 ] ] >,
    C-CONT [ RELS <! #keyrel !>,
	     HCONS <!!> ] ].

; PH 2016-09-07: Added QREL.PRED quant_m_rel constraint in order to
; avoid definite adjectives without a determiner: *Snille mannen brauter.
; PH 2016-09-05: Took out the ARGS.REST.FIRST.SYNSEM.LINK nom+ constraint
; in order to allow for infinitival phrases as fillers.
nom-filler-phrase := sem-filler-phrase & nom-embedded &
  [ SYNSEM [ LOCAL.CAT [ HEAD atfull-infcompl-noun,
			 VAL.SISTER #sis ],
	     LKEYS.Q.QREL #pred ],
    ARGS < [], [ SYNSEM [ LOCAL.CAT.VAL.SISTER #sis,
			  LKEYS.Q.QREL #pred ] ] > ].

comp-filler-phrase := filler-phrase & comp-embedded.

expl-filler-phrase := nextword-phrase &
  [ START -,
    LINK-INPUT -,
    SYNSEM [ LOCAL [ CAT #cat,
		     CONT #cont,
		     AGR #agr,
		     MODAL #modal,
		     TOPIC #topic ],
	     NON-LOCAL [ SLASH < #non-local > ],
	     LKEYS #lkeys ],
    ARGS <[ START +,
	    SYNSEM [ LOCAL [ CAT #cat,
			     CONT #cont,
			     AGR #agr,
			     MODAL #modal ],
		     NON-LOCAL [ SLASH <> ],
		     LKEYS #lkeys ] ],
	  expletive-noun-phrase &
	  [ SYNSEM.LOCAL #non-local & [ TOPIC #topic & local ] ] >,
    C-CONT [ RELS <!!>,
	     HCONS <!!> ] ].

; expl-filler-phrase := sem-filler-phrase & neg-embedded-phrase &
;   [ SYNSEM.LOCAL.CAT.HEAD.NOM +,
;     ARGS <[], expletive-noun-phrase >,
;     C-CONT [ RELS <!!>,
; 	     HCONS <!!> ] ].

adj-mod-filler-phrase := filler-phrase &
  [ SYNSEM [ LOCAL [ CAT [ HEAD adj-andre,
			   STACK < [ NON-LOCAL.SLASH < [] > ] >,
			   VAL.SISTER #sister & [ LOCAL.CONT.HOOK [ LTOP #lbl,
								    INDEX #ind ] ] ],
		     CONT.HOOK [ LTOP #lbl,
				 INDEX #ind ] ],
	     LKEYS [ KEYREL #keyrel & [ LBL #lbl,
				     ARG0 #ind ],
		     ALTKEYREL.PRED generic_entity_rel,	     
		     Q.QREL indef-relation &
			    [ ARG0 #ind,
			      RSTR #harg ] ] ],
    ARGS < [ START + ], [ SYNSEM [ LOCAL.CAT.VAL [ ARGFRAME adj+,
						   SISTER #sister ],
				   LKEYS.KEYREL [ LBL #lbl,
					 PRED #pred,
					 ARG0 #arg0,
					 ARG1 #ind ] ] ] >,
    C-CONT [ RELS <! [ PRED #pred,
		       ARG0 #arg0 & event,
		       LBL #lbl,
		       ARG1 #ind ], #keyrel  !>,
	     HCONS <! [ HARG #harg,
			LARG #lbl ] !> ] ].

adj-filler-phrase := sem-filler-phrase &
  [ SYNSEM [ LOCAL.CAT [ HEAD adj,
			 STACK < [ NON-LOCAL.SLASH < [ EXTR-REL #rel ] > ] > ],
	     LKEYS.Q.QREL.PRED anti-quant_m_rel ],
    ARGS < [], [ SYNSEM [ LINK 4ap,
			  LKEYS.KEYREL #rel & [ ARG0 event ] ] ] >,
    C-CONT [ RELS <! #rel !>,
	     HCONS <!!> ] ].

unary-cond-filler-phrase := binary-phrase & emb-filler-phrase & uni-link &
  [ SYNSEM [ LOCAL [ CAT [ HEAD cadv,
			   VAL #val,
			   VBL #vbl,
			   ARGUMENT [ LOCAL.CAT.CASE subj-case ],
			   C -,
			   AAIF +,
			   STACK < [ NON-LOCAL.SLASH < [ CAT.HEAD cadv ] > ] > ] ],
	     NON-LOCAL.SLASH <>,
             LEX -,
             PHR +,
	     LKEYS.KEYREL #cnstr ],
    ARGS < start-word, 
	   verb-word &
	   [ SYNSEM [ LOCAL [ CAT [ VAL #val,
				    VBL #vbl ] ],
		      LKEYS.KEYREL #cnstr ] ]  >,
    C-CONT [ RELS <! #cnstr !>,
	     HCONS <!!> ] ].

;;;;;
;;;;;   LEXICAL PHRASES
;;;;;

noun-phrase-min := phrase & norm-lex-item & non-gen-word & keyrel-lex-item &
  [ SYNSEM [ LOCAL [ CAT [ HEAD nominal & [ MOD null,
					    AGREE.DEFINITENESS definiteness,
					    NOM + ],
                           VAL.SISTER anti-synsem ] ],
             NON-LOCAL.SLASH <>,
	     FIRST-WORD - ],
    C-CONT.RELS <!!>,
    LINK-INPUT - ].

noun-phrase2 := noun-phrase-min &
  [ SYNSEM.LOCAL.CAT.HEAD.AGREE.DEFINITENESS def ].

non-pronoun :=  lex-item.

noun-phrase := noun-phrase2 & non-pronoun.

no-link-item := sign &
  [ SYNSEM.LOCAL.CAT.VAL.ARGFRAME no-link ].

;proper-noun := phrase & continuative-item.
;last-pn := proper-noun.

; uk-noun-phrase := noun-phrase-min & continuative-item &
;   [ STEM.FIRST #string,
;     SYNSEM.LKEYS.KEYREL.PRED #string,
;     ARGS <> ].

; PH 2016-03-16; linking KEYREL to EXTR-REL in order to grab all the
; features in the KEYREL with the filler rule. The filler rule has
; issues with character posistions specified on the relation in certain
; contexts.
proper-noun-phrase-min := noun-phrase & def-lex-item & non-wh-word & 
                      non-down-entailing &
  [ SYNSEM  [ LOCAL [ CAT [ HEAD proper-noun,
			    VAL.ARGFRAME no-link ],
                      CONT [ HOOK.INDEX.COGN-ST uniq-id,
			     RELS <!!>,
			     HCONS <!!> ],
		      EXTR-REL #keyrel ],
              LKEYS [ KEYREL #keyrel & named-relation,
		      ALTKEYREL #keyrel,
		      Q.QREL proper-q-relation ] ] ].

proper-noun-phrase := proper-noun-phrase-min.
;gen-proper-noun-phrase := proper-noun-phrase-min & generic-lex-item.

multiple-pn-phrase := binary-phrase & continuative-item &
  [ START -,
    SYNSEM [ NON-LOCAL #nl,
	     FIRST-WORD #f ],
    SYNSEM [ SAT +,
	     LOCAL [ CAT #cat & [ HEAD proper-noun & [ FIRST-PN + ],
				  VAL.ARGFRAME no-link ],
		     CONT.HOOK [ LTOP #ltop,
				 INDEX #2 ] ] ],
    ARGS < [ SYNSEM [ FIRST-WORD #f,
		      NON-LOCAL #nl ],
	     SYNSEM [ SAT +,
		      LOCAL [ CAT #cat,
			      CONT.HOOK [ LTOP #1,
					  INDEX #2 ] ] ] ], 
           word-or-lexrule & 
	   [ SYNSEM [ SAT +,
		      LOCAL [ CAT.HEAD proper-noun & [ FIRST-PN - ],
			      CONT.HOOK [ LTOP #3,
					  INDEX #2 ] ] ] ] >,
    C-CONT [ RELS <! multiple-pn-relation & [ LBL #ltop,
					      ARG0 #2,
					      FIRST-NAME #1,
					      LAST-NAME #3 ] !>,
	     HCONS <!!> ] ].

pn-noun-phrase := binary-phrase & continuative-item &
  [ START -,
    SYNSEM [ FIRST-WORD #f,
	     SAT +,
	     LOCAL [ CAT #cat & [ HEAD proper-noun & [ FIRST-PN + ],
				  VAL.ARGFRAME no-link ],
		     CONT.HOOK [ LTOP #ltop,
				 INDEX #2 ] ],
	     NON-LOCAL #nl ],
    ARGS < [ SYNSEM.FIRST-WORD #f,
	     SYNSEM [ SAT +,
		      LOCAL [ CAT #cat & [ VAL.SISTER.SAT + ],
			      CONT.HOOK [ LTOP #1 ] ],
		      NON-LOCAL #nl ] ], 
	   word-or-lexrule &
	   [ INFLECTED +,
	     SYNSEM [ LOCAL [ CAT.HEAD noun & [ AGREE.DEFINITENESS indef ],
			      CONT.HOOK [ LTOP #3,
					  INDEX #2 & [ PNG.PN sg ] ] ] ],
	     ARGS < [], ... >] >,
    C-CONT [ RELS <! multiple-pn-relation & [ LBL #ltop,
					    ARG0 #2,
                                            FIRST-NAME #1,
                                            LAST-NAME #3 ] !>,
	     HCONS <!!> ] ].


pn-word := proper-noun-phrase & 3sg-item & continuative-item.

sg-comm-pn := proper-noun-phrase & comm-item & 3sg-item.
sg-neut-pn := proper-noun-phrase & neut-item & 3sg-item.

pl-pn := proper-noun-phrase & pl-item.


; PH 05-May-2007: Added this rule to account for "landet Norge", "mannen Per 
; Ola"
category-pn-phrase := binary-phrase & reg-binary-emb-phrase &
  [ START -,
    SYNSEM [ SAT +,
	     LOCAL [ CONT.HOOK [ LTOP #1 ] ] ],
    ARGS < [ INFLECTED +,
	     SYNSEM [ SAT +,
		      LOCAL [ CAT [ HEAD noun & [ AGREE.DEFINITENESS def ],
				    QUANT - ],
			      CONT.HOOK.INDEX.PNG.PN sg ] ] ], 
           [ INFLECTED +,
	     SYNSEM [ SAT +,
		      LOCAL [ CAT.HEAD proper-noun & 
				       [ FIRST-PN + ],
			      CONT.HOOK.LTOP #2 ] ] ] >,
    C-CONT [ RELS <! multiple-pn-relation & [ LBL handle,
                                            FIRST-NAME #1,
                                            LAST-NAME #2 ] !>,
	     HCONS <!!> ] ].

wh-thing-or-pers-word := noun-phrase & wh-word &
  [ SYNSEM.LOCAL [ CAT [ HEAD noun & [ MOD <> ],
			 QUANT + ],
		   CONT [ RELS <!!>,
			  HCONS <!!> ] ] ].

comm-item := nominal-item &
  [ SYNSEM.LOCAL.CAT.HEAD.AGREE.GENDER comm ].

masc-item := comm-item &
  [ SYNSEM.LOCAL [ CAT.HEAD.AGREE.GENDER masc ] ].

fem-item := comm-item &
  [ SYNSEM.LOCAL [ CAT.HEAD.AGREE.GENDER fem ] ].

neut-item := nominal-item &
  [ SYNSEM.LOCAL.CAT.HEAD.AGREE.GENDER neut ].

def-lex-item := nominal-item &
  [ SYNSEM.LOCAL [ CAT.HEAD.AGREE.DEFINITENESS def,
		   CONT.HOOK.INDEX.COGN-ST uniq-or-more ] ].

indef-lex-item := nominal-item &
  [ SYNSEM.LOCAL [ CAT.HEAD.AGREE.DEFINITENESS indef,
		   CONT.HOOK.INDEX.COGN-ST type-id ] ].

sg-mass-item := nominal-item & 
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.PN mass-or-sg ].

sg-item := nominal-item & 
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.PN sg ].

pl-item := nominal-item &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.PN pl].

3sg-item := nominal-item &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.PN 3sg ].

1sg-item := nominal-item &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.PN 1sg ].

1pl-item := nominal-item &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.PN 1pl ].

2sg-item := nominal-item &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.PN 2sg ].

2pl-item := nominal-item &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.PN 2pl ].

3pl-item := nominal-item &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.PN 3pl ].

pron-min := lex-item.

pron-word-min := noun-phrase2 & non-wh-word & pron-min &
  [ SYNSEM.LOCAL [ CAT [ HEAD pron &
			      [ NOM + ],
			 QUANT +,
			 CASE case ],
		   CONT.HOOK.INDEX.COGN-ST uniq-or-more ] ].

pron-word := pron-word-min &
  [ SYNSEM [ LOCAL [ CAT.HEAD.AGREE.GENDER #gend,
		     CONT [ RELS <! !>,
			    HCONS <! !> ] ],
	     LKEYS [ KEYREL pronoun-relation & [ ARG0 [ PRONTYPE std_pron,
								  PNG.GEN #gend ] ],
		     Q.QREL pronoun-q-relation ] ] ].

3sg-pron := pron-word & 3sg-item & non-down-entailing.
general-pron := pron-word & 3sg-item & non-down-entailing.
comm-pron := 3sg-pron & comm-item.
masc-pron := 3sg-pron & masc-item.
fem-pron := 3sg-pron & fem-item.
neut-pron := 3sg-pron & neut-item.
1sg-pron := pron-word & 1sg-item & comm-item.
1pl-pron := pron-word & 1pl-item.
2sg-pron := pron-word & 2sg-item.
2pl-pron := pron-word & 2pl-item.

noe-pron := nominal-item & phrase &
  [ SYNSEM [ FIRST-WORD -,
	     LOCAL [ CAT [ HEAD det & [ MOD < [ LOCAL.CAT.HEAD compl-verb ] > ],
			 VAL [ SISTER anti-synsem & [ SAT + ],
			       CMP2.LINK arg2- ],
			 COMPARATIVE -,
			 STACK <> ],
		   CONT [ HOOK [ INDEX #index,
				 LTOP #hndl ],
			  RELS <! noun-relation &
				[ ARG0 #index,
				  LBL #hndl ] !> ] ] ] ].

sg-poss := poss-word-min & 
  [ LEXREL <! [ ARG2.PNG.PN sg] !> ].

pl-poss := poss-word-min &
  [ LEXREL <! [ ARG2.PNG.PN pl] !> ].

poss-sg := poss-word-min &
  [ LEXREL <! [ ARG1.PNG.PN 3sg] !> ].

poss-pl := poss-word-min &
  [ LEXREL <! [ ARG1.PNG.PN 3pl] !> ].

poss-comm := poss-word-min &
  [ LEXREL <! [ ARG1.PNG.GEN comm] !> ].

poss-masc := poss-word-min &
  [ LEXREL <! [ ARG1.PNG.GEN masc] !> ].

poss-neut := poss-word-min &
  [ LEXREL <! [ ARG1.PNG.GEN neut] !> ].

poss-fem := poss-word-min &
  [ LEXREL <! [ ARG1.PNG.GEN fem] !> ].

masc-poss := poss-word-min &
  [ LEXREL <! [ ARG2.PNG.GEN masc] !> ].

neut-poss := poss-word-min &
  [ LEXREL <! [ ARG2.PNG.GEN neut] !> ].

fem-poss := poss-word-min &
  [ LEXREL <! [ ARG2.PNG.GEN fem] !> ].

1-poss := poss-word-min &
  [ LEXREL <! [ ARG2.PNG.PN 1p] !> ].

2-poss := poss-word-min &
  [ LEXREL <! [ ARG2.PNG.PN 2p] !> ].

3-poss := poss-word-min &
  [ LEXREL <! [ ARG2.PNG.PN 3p] !> ].

masc-1sg-poss := poss-sg & sg-poss & poss-masc & 1-poss & non-wh-word & poss-word.
fem-1sg-poss := poss-sg & sg-poss & poss-fem & 1-poss & non-wh-word & poss-word.
neut-1sg-poss := poss-sg & sg-poss & poss-neut & 1-poss & non-wh-word & poss-word.
pl-1sg-poss := sg-poss & 1-poss & poss-pl & non-wh-word & poss-word.

masc-2sg-poss := poss-sg & sg-poss & poss-masc & 2-poss & non-wh-word & poss-word.
fem-2sg-poss := poss-sg & sg-poss & poss-fem & 2-poss & non-wh-word & poss-word.
neut-2sg-poss := poss-sg & sg-poss & poss-neut & 2-poss & non-wh-word & poss-word.
pl-2sg-poss := sg-poss & 2-poss & poss-pl & non-wh-word & poss-word.

comm-1pl-poss := poss-sg & pl-poss & poss-comm & 1-poss & non-wh-word & poss-word.
neut-1pl-poss := poss-sg & pl-poss & poss-neut & 1-poss & non-wh-word & poss-word.
pl-1pl-poss := poss-pl & pl-poss & 1-poss & non-wh-word & poss-word.

2-3pl-poss := pl-poss & non-wh-word & poss-word &
  [ LEXREL <! [ ARG2.PNG.PN 2pl-or-3pl] !> ].

3masc-poss := masc-poss & sg-poss & 3-poss & non-wh-word & poss-word.
3fem-poss := fem-poss & sg-poss & 3-poss & non-wh-word & poss-word.
3neut-poss := fem-poss & sg-poss & 3-poss & non-wh-word & poss-word.

wh-poss-word := poss-word & wh-word &
  [ SYNSEM.LOCAL.CAT.HEAD.MESS wh-question_m_rel ].

wh-masc-poss-word := wh-poss-word & poss-sg & poss-masc & 3-poss.
wh-fem-poss-word := wh-poss-word & poss-sg & poss-masc & 3-poss.
wh-neut-poss-word := wh-poss-word & poss-sg & poss-masc & 3-poss.
wh-pl-poss-word := wh-poss-word & poss-pl & 3-poss.

; tmt fix: took out ARGS <> constraint (2012-08-14; ph)
refl-phrase-min := nominal-item &
  [ SYNSEM [ LOCAL [ CAT [ VAL [ CMP2.LINK arg2-,
                                 CMP4.LINK arg4- ],
                           CASE non-subj-case ] ] ] ].


refl-poss-word := poss-word-min & refl-phrase-min &
  [ SYNSEM [ LOCAL [ CAT [ HEAD poss,
			   CASE non-subj-case ] ],
	     LKEYS.ALTKEYREL [ PRED generic_entity_rel ] ] ].

refl-3-poss-affix := refl-poss-word & 3-poss & non-wh-word &
  [ SYNSEM  [ CLITIC +,
              LOCAL.CAT.VAL.SISTER anti-synsem ] ].

; PH 04-may-2007: "si" and "sitt"
; PH 13-jul-2006: "sin" and "sine"
refl-3sg-neut-poss := poss-neut & poss-sg & 3-poss & non-wh-word & refl-poss-word.
refl-3sg-masc-poss := poss-masc & poss-sg & 3-poss & non-wh-word & refl-poss-word.
refl-3sg-fem-poss := poss-fem & poss-sg & 3-poss & non-wh-word & refl-poss-word.
refl-3pl-poss := poss-pl & 3-poss & non-wh-word & refl-poss-word.

refl-phrase := refl-phrase-min & noun-phrase &
  [ SYNSEM [ LOCAL [ CAT.HEAD refl-pron,
		     CONT.RELS.LIST.FIRST #keyrel ],
	     MODIFIED lmod,
	     LKEYS [ ALTKEYREL #keyrel,
		     Q.QREL pronoun-q-relation ] ] ].

heavy-refl-phrase := refl-phrase &
  [ SYNSEM.LOCAL [ CAT [ HEAD refl-pron-heavy,
			 QUANT - ],
                   CONT [ RELS <! !>,
			  HCONS <!!>] ] ].


;;;;;
;;;;;   MODIFIER WORDS
;;;;;

; PH 17-jul-2006: #case accounts for *hunden sin smiler.
mod-word := non-gen-word & native-lex-item &
  [ SYNSEM [ FIRST-WORD -,
	     LOCAL.CAT [ HEAD.MOD < [ LOCAL.CAT.CASE #case ] >,
			 CASE #case ] ] ].

mod-np-word := mod-word & 1rel-lex-item & keyrel-lex-item &
  [ SYNSEM [ SAT +,
             LOCAL [ CAT.HEAD adj &
                            [ MOD < [ LOCAL [ CAT.HEAD nominal,
                                              CONT.HOOK.INDEX #1 ] ] > ],
                     CONT.HOOK.INDEX #1 ] ] ].

super-mod-word-min := mod-word & bottom-gap-item & keyrel-lex-item &
[ SYNSEM [ LOCAL [ CAT [ HEAD adv-prep & 
                   [ MOD < [ LOCAL [ CAT [ HEAD head ] ] ] >,
		      MESS #mess ],
			 VAL [ CMP2 [ LINK link,
				      LOCAL [ CAT [ HEAD head &
							 [ MESS #mess ],
						    VAL.CMP2.LINK arg2- ] ] ],
			       CMP3.LINK arg3-,
			       CMP4.LINK arg4- ] ], 
		   CONT [ HOOK.INDEX event ] ],
	   NON-LOCAL.SLASH <> ] ].

super-mod-word := super-mod-word-min &
[ SYNSEM.LOCAL.CONT.RELS <! !> ].

; PH 2006-12-02: Constrained the element on the MOD list to be notmod instead 
; of notmod-or-rmod.

; PH 18-jul-2006: This type accounts for prepositions with an optional
; complement: 
; Han kastet ballen nedover (bakken)
prep-word-min := super-mod-word-min & non-down-entailing &
  [ SYNSEM [ LOCAL [ CAT [ HEAD prep-min & 
				[ KEYS.KEY predsort,
				  MOD < [ LOCAL.CAT [ HEAD adj-compl-nominal-verb,
						      VAL.CMP2.LINK link ],
					  MODIFIED notmod-or-rmod ] > ] ],
		     CONT [ HOOK [ LTOP #lbl,
				   XARG #ind ],
			    RELS <! !>,
			    HCONS <!!> ] ],
	     LKEYS [ KEYREL #keyrel & [ LBL #lbl,
					ARG1 #ind ],
		     CNSTR #keyrel ] ] ].

; PH 18-jul-2006: These prepositions have non-optional complements:
; Han gikk til skogen
prep-word := prep-word-min &
  [ SYNSEM.LOCAL [ CAT [ HEAD.KEYS.KEY predsort,
			 VAL [ CMP2 [ LOCAL.CAT.HEAD adj-subcompl-infcompl-noun ],
			       CMP3.LINK arg3-,
			       CMP4.LINK arg4-,
			       SISTER anti-synsem ] ],
		   CONT.RELS.LIST.FIRST.PRED predsort ] ].

prep_np_word := prep-word & 
  [ SYNSEM.LOCAL.CAT.VAL.CMP2.LOCAL.CAT.HEAD nominal ].
; inkl. moms
prep-nounmod-word := prep-word &
  [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CAT.HEAD nominal ] > ].

; han sov deler-av turen
prep-verbmod-word := prep-word &
  [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CAT.HEAD verb ] > ].

; naturen rundt (oss) er pen
prep-pp-word := prep-word-min &
  [ SYNSEM.LOCAL.CAT.VAL [ CMP2 [ SAT +,
				  LOCAL.CAT.HEAD subcompl-infcompl-noun ],
			   SISTER anti-synsem ] ].
  
fordi-prep-word := prep-word &
  [ SYNSEM.LOCAL.CAT [ HEAD.MOD < [ LOCAL.CAT.HEAD verb ] >,
                       VAL.CMP2.LOCAL.CAT.HEAD subcompl ] ].

enn-word := func-word &
  [ SYNSEM.LOCAL.CAT.HEAD prep & 
			  [ MOD < [ LOCAL.CAT [ HEAD adj-nominal,
						COMPARATIVE + ] ] > ] ].

som-prep-word := prep-word-min &
  [ SYNSEM.LOCAL.CAT.VAL.CMP2 [ LINK arg2+,
				SAT + ] ].

selv-mod-word := super-mod-word &
  [ SYNSEM.LOCAL.CAT [ HEAD prep & 
                   [ MOD < [ LOCAL.CAT [ HEAD compl-noun-verb,
                               ARGUMENT.LOCAL.CAT.CASE non-subj-case ] ] >,
                     PREDICATIVE - ],
                       VAL.CMP2.LINK arg2- ] ].

mod-mod-word-min := bottom-gap-item & non-gen-word & empty-sign &
  [ SYNSEM.LOCAL [ CAT [ HEAD mod-mod,
			 VAL [ CMP1.LINK arg1-,
			       CMP2.LINK arg2-,
			       CMP3.LINK arg3-,
			       CMP4.LINK arg4- ] ] ] ].

mod-mod-word := mod-mod-word-min &
  [ SYNSEM [ LOCAL.CONT.HOOK.XARG #xarg,
	     COMP-IND #xarg ] ].

mod-mod-non-wh := mod-mod-word-min &
  [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ ] > ].
; bl.a
mod-adj-adv-nominal-prep-word := mod-mod-non-wh & mod-mod-word &
  [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CAT [ HEAD adj-adv-nominal-prep,
                                              VAL.CMP2.LINK link ] ] > ].

; Herr Jon
title-word := mod-mod-non-wh & mod-mod-word &
  [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CAT.HEAD proper-noun ] > ].

; helt på hodet
mod-adj-adv-prep-word := mod-mod-non-wh & mod-mod-word &
  [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CAT [ HEAD adj-adv-prep,
                                              VAL.CMP2.LINK link ] ] > ].

; for grønn
mod-adj-adv-word := mod-adj-adv-prep-word &
  [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CAT.HEAD adj-adv ] > ].

; akkurat nå, akkurat i dag
mod-adv-prep-word := mod-adj-adv-prep-word &
  [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CAT.HEAD adv-prep ] > ].

; godt likt
mod-adj-part-word := mod-mod-non-wh & mod-mod-word &
  [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CAT.HEAD adj & [ PERFPART + ],
                                  LKEYS.KEYREL.ARG0 [ E.TENSE untensed,
						      PERF + ],
				  PHR - ] > ].

; midtveis mellom Beitostølen og Fondsbu
mod-prep-word := mod-adv-prep-word &
  [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CAT.HEAD prep ] > ].

; hvor i skogen
wh-mod-adj-adv-prep-word := mod-mod-word & wh-word &
  [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CAT.HEAD adj-adv-prep ] > ].

; han bare smiler
mod-verb-word := mod-mod-non-wh & mod-mod-word &
  [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL [ CAT.HEAD verb,
                                          CONT.HOOK.INDEX.E.TENSE imp-fin ],
                                  PHR - ] > ].

; Ikke smil!
mod-verb-imp-word := mod-mod-non-wh & mod-mod-word &
  [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL [ CAT.HEAD verb,
                                          CONT.HOOK.INDEX [ E.TENSE imp,
							    PERF - ] ],
                                  PHR - ] > ].

; ca fem hunder / nesten alle
mod-card-quant-word := mod-mod-non-wh & mod-mod-word &
  [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CAT.HEAD card-quant ] > ].

; halv fire / rundt fire
mod-card-word := mod-card-quant-word &
  [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CAT.HEAD card ] > ].

mod-adj-word-min := mod-mod-non-wh & mod-mod-word &
  [ SYNSEM [ SAT #bool,
             LOCAL.CAT.HEAD.MOD < [ PHR -,
                                    LOCAL [ CAT [ VAL.CMP2.LINK arg2- ] ],
                                    SAT #bool ] > ] ].

; veldig snill / svært snill /svært godt likt
mod-adj-pos-word := mod-adj-word-min &
  [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL [ CAT.HEAD adj-adv,
                                        CONT.HOOK.INDEX.GRADE positive ] ] > ].

så-mod-adj-pos-word := mod-mod-word-min &
  [ SYNSEM [ LOCAL [ CAT.HEAD.MOD < [ LOCAL.CAT.HEAD adj ] >,
		     CONT.HOOK.XARG #2 ],
	     LKEYS.KEYREL.ARG2 #2 ] ].

mod-adj-word := mod-adj-word-min &
  [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CAT.HEAD adj ] > ].

; langt penere / svært mye mer privat
mod-adj-comp-word := mod-adj-word-min &
  [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CAT [ HEAD adj-mod-mod,
                                              COMPARATIVE + ] ] > ].

; den kanskje peneste mannen / Jon kanskje kommer
mod-adj-verb-word := mod-mod-non-wh & mod-mod-word &
  [ SYNSEM [ SAT #bool,
             LOCAL.CAT.HEAD.MOD < [ LOCAL.CAT [ HEAD adj-verb,
                                           ARGUMENT.LOCAL.CAT.CASE subj-case ],
                                    SAT #bool ] > ] ].

; jon smiler kanskje ikke
mod-sadv-word := mod-mod-non-wh & mod-mod-word &
  [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CAT.HEAD sadv ] > ].

; en mer privat skog / den minst private skogen
grade-mod-word := mod-mod-non-wh & mod-mod-word &
  [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL [ CAT.HEAD adj,
                                       CONT.HOOK.INDEX.GRADE positive ] ] > ].

mer-enn-mod-word := mod-mod-non-wh & mod-mod-word &
  [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CAT.HEAD verb,
                                  LEX +,
                                  PHR - ] > ].


basic-adv-word := non-gen-word & keyrel-lex-item &
[ SYNSEM [ LOCAL [ CAT [ HEAD.MOD < [ ] >,
                         VAL [ CMP1.LINK arg1-,
                               CMP3.LINK arg3-,
                               CMP4.LINK arg4- ]] ,
                   CONT [ HOOK.INDEX event-or-ref-index ] ],
           NON-LOCAL.SLASH <> ] ].

; adv-word := basic-adv-word & non-gen-word &
; [ SYNSEM.LOCAL.CAT.HEAD adv & 
; 		       [ MOD < [ LOCAL.CAT.HEAD adj-compl-nominal-verb ] > ] ].
adv-word2 := mod-word & keyrel-lex-item &
  [ SYNSEM [ LOCAL [ CAT [ HEAD adv & 
		  [ MOD < [ LOCAL[ CONT.HOOK.INDEX #ind & individual ] ] > ] ],
                   CONT.HOOK [ XARG #ind ] ],
             NON-LOCAL.SLASH <>,
	     LKEYS.KEYREL [ ARG0 event,
			    ARG1 #ind ] ] ].

adv-comp-word-min := super-mod-word & basic-adv-word &
[ SYNSEM.LOCAL [ CAT [ HEAD prep & 
			    [ MOD < [ LOCAL.CAT [ HEAD adj-compl-nominal-verb,
						  VAL.CMP2.LINK arg2- ] ] > ],
		       VAL.CMP2 [ SAT +,
				  LINK arg2+,
				  LOCAL [ CAT.HEAD subcompl-nominal-prep,
					  CONT.HOOK.XARG #xarg ] ] ],
		 CONT.HOOK.XARG #xarg ] ].

adv-comp-word := adv-comp-word-min &
  [ SYNSEM.LOCAL.CAT.VAL.CMP2.LOCAL.CAT.HEAD nominal-prep ].

adv-nocomp-word := adv-word2 &
  [ SYNSEM [ LOCAL [ CAT [ HEAD.MOD < [ ] >,
                           VAL.CMP2.LINK arg2- ],
                     CONT.RELS.LIST.FIRST.ARG0 individual ] ] ].

adv-nocomp-nounmod-word := basic-adv-word & norm-lex-item &
  [ SYNSEM [ LOCAL [ CAT [ HEAD.MOD < [ LOCAL.CONT.HOOK.INDEX individual ] >,
                           VAL.CMP2.LINK arg2- ] ] ] ].

norm-entail-adv-word := adv-nocomp-word & non-down-entailing &
  [ SYNSEM [ LOCAL [ CAT.HEAD.MOD < [  LOCAL [ CAT.HEAD compl-verb,
                                                CONT.HOOK.INDEX event ] ] >,
		     CONT [ RELS <! !>,
			    HCONS <! !> ] ] ] ].

neg-pol-item-adv-word := func-word & neg-pol-item &
  [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CAT.HEAD compl-verb ] > ].

npi-func-word := func-word & neg-pol-item.

; boka ble pent/forsiktig behandlet
; PH 17-jul-2006: Constrain converted adjectives to display COGN-ST type-id on
; XARG in order to prevent "Isen er godt" but allow "Is er godt".
adj-adv-word := adv-nocomp-word & lex-rule &
  [ INFLECTED +,
    SYNSEM [ LOCAL [ CAT.HEAD.MOD < [ LOCAL.CAT [ HEAD adj-compl-verb,
						  VAL [ CMP1.LINK arg1-,
							CMP3.LINK arg3- ] ],
				      SAT #sat ] >,
		     CONT.HOOK [ LTOP #lbl,
				 INDEX #ind & individual,
				 XARG [ COGN-ST type-id ] ] ],
	     SAT #sat,
	     LKEYS.KEYREL #keyrel & [ LBL #lbl,
				      ARG1 #ind ] ],
    ARGS < [ INFLECTED -,
	     SYNSEM [ LOCAL [ CAT.HEAD adj,
			      CONT.HOOK.LTOP #lbl ],
		      LKEYS.KEYREL #keyrel ] ] >,
    C-CONT [ RELS <!!>,
	     HCONS <!!> ] ].

infl-adv-word := adj-adv-word & inflecting-lex-rule.
const-adv-word := adj-adv-word & constant-lex-rule.


; En mann smiler beundrende (present participle as adjective)
; En beundrende mann smiler (present participle as adverb) 
pres-part-word := inflecting-lex-rule & word & keyrel-lex-item &
  [ INFLECTED +,
    SYNSEM [ FIRST-WORD -,
	     LOCAL [ CAT [ HEAD adj-adv &
				[ MOD < [ LOCAL.CAT [ HEAD noun-verb,
						      VAL [ CMP1.LINK arg1-,
							    CMP2.LINK arg2-,
							    CMP3.LINK arg3- ] ],
					  SAT #bool ] > ],
			   VAL [ SISTER synsem & [ LOCAL.CAT.HEAD noun ] ],
			   STACK <>,
			   QUANT - ],
		     CONT.HOOK [ LTOP #lbl ] ],
	     SAT #bool,
	     LKEYS [ KEYREL #keyrel & [ PRED 1np & arg2- & arg3- & arg4- & prt- ],
		     CNSTR #keyrel & [ LBL #lbl,
				       ARG0.E.TENSE prespart ] ] ],
    ARGS < [ INFLECTED -,
             SYNSEM [ LOCAL [ CAT [ HEAD verb ],
			      CONT.HOOK.LTOP #lbl ],
		      LKEYS.KEYREL #keyrel ] ] >,
    C-CONT [ RELS <!!>,
	     HCONS <!!> ] ].

;;;;;
;;;;;   MODIFIER PHRASES
;;;;;

non-extr-phrase := phrase &
  [ SYNSEM.EXTR - ].


mod-mod-phrase-min := nextword-phrase & 
  [ BOUNDARY -,
    NEXTWORD #2 & synsem & [ LOCAL.CAT.HEAD head,
			     LKEYS.ALTKEYREL #alt ],
    SYNSEM [ LOCAL [ CAT #cat,
		     CONT [ HOOK #hook,
			    MSG #msg ],
		     TOPIC #t ],
	     NON-LOCAL #nl,
	     LKEYS #lkeys,
	     MODIFIED #mod,
	     COMP-IND #comp ],
    ARGS < [ BOUNDARY -,
	     SYNSEM [ FIRST-WORD +,
		      LOCAL [ CAT #cat,
			      CONT [ HOOK #hook,
				     MSG #msg ],
			      TOPIC #t ],
		      NON-LOCAL #nl,
		      LKEYS #lkeys,
		      COMP-IND #comp-in ] ],
	   [ SYNSEM [ LOCAL [ CAT.HEAD.MOD < #2 & 
					   [ LOCAL.CONT.HOOK [ LTOP #lbl ],
					     MODIFIED #mod ] >,
			      CONT.HOOK.XARG #comp ],
		      LKEYS [ KEYREL #relation & [ PRED degadv+ ],
			      ALTKEYREL #alt ],
		      COMP-IND #comp-in ] ] >,
    C-CONT [ RELS <! #relation & [ LBL #lbl,
				   PRED degadv+,
				   ARG0 event ] !>,
	     HCONS <!!> ] ].

mwe-conj-phrase := nextword-phrase & 
  [ BOUNDARY -,
    NEXTWORD synsem & [ LOCAL.CAT.HEAD head ],
    SYNSEM [ LOCAL [ CAT #cat,
		     CONT [ HOOK #hook,
			    MSG #msg ],
		     TOPIC #t ],
	     NON-LOCAL #nl,
	     LKEYS [ ALTKEYREL #relation,
		     KEYREL #keyrel,
		     CNSTR #cnstr,
		     Q #q,
		     ELLREL #ellrel ] ],
    ARGS < [ BOUNDARY -,
	     SYNSEM [ FIRST-WORD +,
		      LOCAL [ CAT #cat,
			      CONT [ HOOK #hook,
				     MSG #msg ],
			      TOPIC #t ],
		      NON-LOCAL #nl,
		      LKEYS [ KEYREL #keyrel,
			      CNSTR #cnstr,
			      Q #q,
			      ELLREL #ellrel ] ] ],
	   func-word &
	   [ SYNSEM [ LKEYS [ KEYREL #relation & [ PRED mwe_conj ] ] ] ] >,
    C-CONT [ RELS <! !>,
	     HCONS <!!> ] ].

mod-mod-phrase := mod-mod-phrase-min &
  [ START #start,
    ARGS < [ START #start ], [ SYNSEM.LOCAL.CAT.HEAD adv ] > ].

deg-arg0-phrase := mod-mod-phrase &
  [ NEXTWORD.LKEYS.KEYREL.ARG0 #index,
    C-CONT.RELS <! [ ARG1 #index ] !> ].

deg-adj-phrase := deg-arg0-phrase &
  [ NEXTWORD.LOCAL.CAT.HEAD adj ].

;; En veldig dyr is
deg-pos-phrase := deg-adj-phrase &
  [ ARGS < [], [ SYNSEM.LKEYS.KEYREL [ PRED deg-pos,
				       ARG1.GRADE positive] ] > ].

;; Den langt dyrere isen
deg-cmp-phrase := deg-adj-phrase &
  [ ARGS < [], [ SYNSEM.LKEYS.KEYREL [ PRED deg-cmp,
				       ARG1.GRADE comparative ] ] > ].

;; Den omtrent dyreste isen
deg-sup-phrase := deg-adj-phrase &
  [ ARGS < [], [ SYNSEM.LKEYS.KEYREL [ PRED deg-sup,
				       ARG1.GRADE superlative ] ] > ].

;; Jon sover omtrent ved isen
deg-adv-phrase := deg-arg0-phrase &
  [ NEXTWORD.LOCAL.CAT.HEAD adv,
    ARGS < [], [ SYNSEM.LKEYS.KEYREL.PRED deg-adv ] > ].

;; Jon sover omtrent ved isen
deg-sadv-phrase := deg-arg0-phrase &
  [ NEXTWORD.LOCAL.CAT.HEAD sadv,
    ARGS < [], [ SYNSEM.LKEYS.KEYREL.PRED deg-sadv ] > ].

;; Bl.a. mannen smiler
deg-nom-phrase := deg-arg0-phrase &
  [ NEXTWORD.LOCAL.CAT.HEAD nominal,
    ARGS < [], [ SYNSEM.LKEYS.KEYREL.PRED deg-nom ] > ].

;; Omtrent alle smiler
deg-qnt-phrase := deg-arg0-phrase &
  [ NEXTWORD [ LOCAL.CAT.HEAD quant,
	       LKEYS.Q.QREL.PRED quant_m_rel ],
    ARGS < [], [ SYNSEM.LKEYS.KEYREL.PRED deg-qnt ] > ].

;; Mannen bare smiler
deg-verb-phrase := deg-arg0-phrase &
  [ NEXTWORD.LOCAL [ CAT.HEAD verb,
		     CONT.HOOK.INDEX.E.TENSE fin-infin ],
    ARGS < [], [ SYNSEM.LKEYS.KEYREL.PRED deg-verb ] > ].

;; Bare smil!
deg-imp-phrase := deg-arg0-phrase &
  [ NEXTWORD.LOCAL [ CAT.HEAD verb,
		     CONT.HOOK.INDEX.E.TENSE imp ],
    ARGS < [], [ SYNSEM.LKEYS.KEYREL.PRED deg-imp ] > ].

;; Omtrent tre menn smiler
deg-num-phrase := mod-mod-phrase &
  [ NEXTWORD [ LOCAL [ CAT.HEAD card,
		       CONT.RELS.LIST.FIRST.ARG0 #index ] ],
    ARGS < [], [ SYNSEM.LKEYS.KEYREL [ PRED deg-num,
				       ARG1 #index ] ] > ].

; init-mod-mod-phrase := start-item & mod-mod-phrase-min &
;   [ ARGS.FIRST start-item,
;     C-CONT [ HCONS <!!> ] ].

init-struc-comma-phrase := start-item & nextword-phrase & uni-link & start-head &
  [ SYNSEM #synsem,
    ARGS < vocative-phrase & [ SYNSEM #synsem ], comma-word > ].

init-struc-min := nextword-phrase &
  [ CONJ no-conj,
    SYNSEM [ FIRST-WORD +,
	     LOCAL [ CAT [ HEAD.ELLIPSIS -,
			   STACK <>,
			   C +,
			   VBL synsem ],
		     CONT [ HOOK.LTOP #arg1,
			    HCONS <! !> ],
		     TOPIC no-topic ],
	     NON-LOCAL.SLASH <>,
	     LKEYS.KEYREL.LBL #arg1 ],
    LINK-INPUT -,
    ARGS < start-word, [] > ].


init-struc-phrase := start-item & init-struc-min & uni-link & start-head &
  [ SYNSEM.LKEYS.KEYREL.LBL #arg1,
    LINK-INPUT -,
    C-CONT [ RELS <! #rel & [ PRED init_rel,
			      LBL #arg1 ] !>,
	     HCONS <!!> ],
    ARGS < start-word,
	   continuative-word &
	   [ SYNSEM.LKEYS.KEYREL #rel ] > ].

; PH 2019-06-21: Put the pn-word constraint in again in order to constrain the
; generator
; PH 2019-03-19: Took out pn-word constraint as second argument
vocative-phrase := init-struc-min &
  [ SYNSEM.LKEYS.KEYREL [ LBL #lbl,
			  ARG0 #arg2 ],
    PUNCT punct,
    ARGS < [ ],
	   pn-word &
	   [ SYNSEM.LKEYS.KEYREL #relation ] >,
    C-CONT.RELS <! [ PRED vocative_rel,
		     LBL #lbl,
		     ARG0 event,
		     ARG1 #arg1,
		     ARG2 #arg2 ],
		 #relation &
		 [ ARG0 #arg1 ] !> ].

; alle slags fisker
; den type skog
det-mod-phrase := binary-phrase &
  [ SYNSEM [ SAT +,
             LOCAL [ CAT [ HEAD #head & [ MOD #mod ],
                           VAL.SISTER synsem & 
                                  [ SAT -,
                                    LOCAL.CAT.HEAD card-noun &
                                           [ MOD #mod,
                                             AGREE.DEFINITENESS indef ] ] ],
                     CONT.HOOK.INDEX #index ] ],
    ARGS < [ SYNSEM #1 & [ LOCAL [ CAT [ HEAD #head & card-det-poss-quant,
                                         VAL.SISTER synsem ],
                                   CONT.HOOK.LTOP #lbl ] ] ],
           [ SYNSEM [ LOCAL [ CAT [ HEAD noun & [ MOD < #1 > ] ],
                            CONT.HOOK.LTOP #lbl ],
		      LKEYS.CNSTR [ LBL #lbl,
				    ARG1 #index ] ] ] >,
    C-CONT [ RELS <! !>,
	     HCONS <!!> ] ]. 

; Removed the STACK.SISTER anti-synsem constraint in order to account for
; noen av kattene bjeffer
; PH 2016-03-16; Added negative LINK constraints on the first daughter
; in order to let modification happen after the arguments are parsed.
; DEBUG 2013-11-24: Added a SISTER anti-synsem constraint in order to 
; avoid that post-modifying possessives (hunden min) takes sisters 
; (hunden min hund)
basic-mod-embedded-phrase := gap-binary & binary-phrase &
			     comp-copy-phrase & neg-embedded-phrase &
  [ SYNSEM.LOCAL [ CAT.STACK.FIRST [ LOCAL [ CAT [ HEAD adj-adv-compl-nominal-verb,
						   HEAD #head-min,
						   VAL #valence-min,
						   CASE #case-min,
						   MC #luk,
						   ARGUMENT #arg,
						   VBL #vbl,
						   C-COGN-ST #cogn-st,
						   STACK #list,
						   COMPARATIVE #bool,
						   QUANT #q,
						   AAIF #aaif,
						   C #c ],
					     CONT.HOOK #hook2,
					     TOPIC #topic ],
				     NON-LOCAL #nl,
				     LKEYS #lk,
				     MODIFIED rmod ] ],
    ARGS < [ CONJ no-conj,
	     BOUNDARY -,
	     SYNSEM  [ LOCAL [ CAT [ QUANT bool & #q,
				     VAL [ CMP1.LINK arg1-,
					   CMP2.LINK arg2-,
					   CMP3.LINK arg3-,
					   CMP4.LINK arg4-,
					   PART prt- ],
				     HEAD #head-min,
				     VAL #valence-min,
				     CASE #case-min,
				     MC #luk,
				     ARGUMENT #arg,
				     VBL #vbl,
				     C-COGN-ST #cogn-st,
				     STACK #list,
				     COMPARATIVE #bool,
				     QUANT #q,
				     AAIF #aaif,
				     C #c ],
			       CONT.HOOK #hook2,
			       TOPIC #topic ],
		       NON-LOCAL #nl,
		       LKEYS #lk ] ], [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ MODIFIED rmod ] > ] > ].

; PH 201-06-15: Changed the Q.QREL anti-quant_m_rel constraint to 
; quant-or-anti-quant_m_rel in order to allow for "Jeg kom fredag"
mod-cond-embedded-phrase-min := basic-mod-embedded-phrase &
  [ SYNSEM [ LOCAL [ CAT [ HEAD #head,
			 VBL #vbl,
			 QUANT #q2 ],
		     CONT.HOOK #hook ],
	     LKEYS [ Q.QREL.PRED quant-or-anti-quant_m_rel ],
	     MODIFIED rmod ],
    ARGS < [ CONJ no-conj,
	     BOUNDARY -,
	     SYNSEM #mod & [ LKEYS [ Q.QREL scope-relation ] ] ],
	   [ SYNSEM [ LOCAL [ CAT [ HEAD #head &
					 [ MOD < #mod > ],
				    VBL #vbl,
				    STACK <>,
				    QUANT #q2 ],
			      CONT.HOOK #hook ],
		      NON-LOCAL.SLASH <> ] ] > ].

mod-cond-embedded-phrase := mod-cond-embedded-phrase-min &
  [ SYNSEM [ LKEYS [ KEYREL #rel ] ],
    ARGS < [ SYNSEM [ LKEYS [ KEYREL [ LBL #lbl,
					      ARG0 #index ] ] ] ],
	   [ SYNSEM [ LKEYS [ KEYREL #rel ] ] ] >,
    C-CONT [ RELS <! #rel & [ LBL #lbl,
			      ARG0 event-or-ref-index,
			      ARG1 #index ] !>,
	     HCONS <!!> ] ].

; PH 2017-11-09: Underspecified the KEYREL.ARG0 value in order to allow for
; nominal modifiers
; PH 2015-10-22: Changed HEAD adj-adv-poss-prep-refl to 
; adj-adv-nominal-prep in order to allow for nominal modifiers like
; "Han smiler hver dag."
mod-embedded-phrase2 := mod-cond-embedded-phrase &
  [ SYNSEM [ LOCAL.CAT [ HEAD adj-adv-nominal-prep &
			      [ NOM - ],
			 VAL [ CMP1.LINK arg1-,
			       CMP2.LINK #cmp2,
			       CMP3.LINK arg3-,
			       CMP4.LINK arg4-,
			       SISTER.LOCAL.CAT.HEAD.MOD < [] > ],
			 ARGUMENT #arg ],
	     LKEYS.KEYREL #rel & [ ARG0 event-or-ref-index ] ],
    ARGS <[ SYNSEM.LOCAL.CAT.VBL anti-synsem ],
	  [ SYNSEM.LOCAL.CAT [ VAL.ARGFRAME arg1+ & #cmp2 & arg3- & arg4- & prt-,
			       ARGUMENT #arg ] ]>,
    C-CONT.RELS <! #rel & [ ] !> ].

mod-embedded-regular-phrase := basic-mod-embedded-phrase &
  [ ARGS < [ SYNSEM.LOCAL.CAT.QUANT + ], [] > ].
mod-embedded-phrase := mod-embedded-phrase2 & mod-embedded-regular-phrase.
mod-emb-vbl-phrase := mod-embedded-phrase &
  [ SYNSEM [ LOCAL.CAT.VAL.SISTER #sister,
	     LKEYS [ KEYREL.ARG0 event,
		     Q.QREL.PRED anti-quant_m_rel ] ],
    ARGS < [ SYNSEM.LOCAL.CAT.HEAD compl-verb ],
	   [ SYNSEM.LOCAL.CAT [ HEAD adj-adv-nominal-prep,
				VAL.SISTER #sister ] ] > ].

mod-emb-vbl-np-phrase := mod-cond-embedded-phrase-min & uni-link &
  [ SYNSEM [ LOCAL.CAT.VAL [ ARGFRAME no-link,
			     SISTER synsem ],
	     LKEYS #lk & [ KEYREL #rel & [ LBL #larg,
					   PRED #pred,
					   ARG0 #arg0 & [ COGN-ST #cn ] ],
			   Q.QREL [ PRED quant_m_rel,
				    ARG0 #arg0,
				    RSTR #harg ],
			   ALTKEYREL.ARG0.COGN-ST #cn ] ],
    ARGS < [ SYNSEM [ LOCAL.CAT.HEAD compl-verb,
		      LKEYS.KEYREL.ARG0 #index ] ],
	   [ SYNSEM [ LOCAL.CAT [ HEAD card-det-quant ],
		      LKEYS #lk ] ] >,
    C-CONT [ RELS <! [ LBL handle,
		       PRED "loc_nonsp_rel",
		       ARG0 event,
		       ARG1 #index,
		       ARG2 #arg0 ],
		   #rel & [ LBL #larg,
			    PRED #pred & time-loc_prd,
			    ARG0 #arg0 ] !>,
	     HCONS <! [ HARG #harg,
			LARG #larg ]  !> ] ].

mod-emb-nom-phrase := mod-embedded-phrase &
  [ ARGS < [ SYNSEM [ LOCAL.CAT.HEAD adv-nominal ] ],
	   [ SYNSEM.LOCAL.CAT.HEAD adv-prep ] > ].

mod-emb-enn-phrase := mod-embedded-phrase2 &
  [ ARGS < [ SYNSEM.LOCAL.CAT.QUANT - ], [ SYNSEM.LKEYS.KEYREL.PRED enn_prd ] > ].

; post-prep-phrase := mod-embedded-phrase &
;   [ SYNSEM.LOCAL.CAT.VAL.ARGFRAME arg2- & postp+,
;     ARGS < [ SYNSEM.LOCAL.CAT.HEAD nominal ], [] > ].

mod-embedded-part-phrase := mod-cond-embedded-phrase & mod-embedded-regular-phrase &
  [ SYNSEM [ LOCAL.CAT [ HEAD adj &
			      [ NOM - ],
			 VAL [ CMP3.LINK arg3-,
			       CMP4.LINK arg4- ] ],
	     LKEYS.KEYREL #rel ],
    C-CONT.RELS <! #rel !> ].

; FIXME: This rule allows "et smil" as a modifier. I guess the idea was to 
; allow numerals as modifiers.                                (2016-01-14; ph)
modnom-embedded-phrase := mod-cond-embedded-phrase & mod-embedded-regular-phrase &
  [ SYNSEM.LOCAL.CAT.HEAD card-commnoun-det-quant & 
			  [ MOD < [ LOCAL [ CAT.HEAD compl-verb,
					    CONT.HOOK.INDEX #ind ] ] > ],
    C-CONT.RELS <! arg12-relation &
		 [ PRED time_rel,
		     ARG2 #ind ] !> ].


; ex: Han sov mens han sov.
; ex: Mens han sov, sov han.
cadv-embedded-phrase := reg-binary-emb-phrase & complementizer-sign & mod-embedded-regular-phrase &
  [ SYNSEM [ LOCAL.CAT [ HEAD cadv,
			 VBL synsem ],
	     LKEYS.KEYREL.ARG0 #ind ],
    ARGS < [ SYNSEM [ LOCAL.CAT.HEAD compl-verb,
		      LKEYS.KEYREL [ LBL #lbl,
				     ARG0 #mod ] ] ], 
	   [ SYNSEM.LKEYS.KEYREL.PRED #pred & cadv+ ] >,
    C-CONT [ RELS <! [ LBL #lbl,
		       PRED #pred,
		       ARG0 event,
		       ARG1 #mod,
		       ARG2 #ind ] !>,
	     HCONS <!!> ] ].

sadv-phrase-min := phrasal & val-or-mod-sign & head-compositional &
		   comp-copy-phrase &
  [ START -,
    SYNSEM [ LOCAL [ CAT #cat,
		     CONT.MSG #msg ],
	     MODIFIED rmod,
	     LKEYS.KEYREL.ARG0 #event ],
    HD-DTR [ BOUNDARY -,
	     SYNSEM [ LOCAL [ CAT #cat & 
				  [ HEAD compl-prep-verb,
				    ARGUMENT.LOCAL.CAT.CASE case,
				    AAIF + ],
			      CONT [ HOOK [ LTOP #lbl ],
				     MSG #msg ] ] ] ],
    C-CONT [ RELS <! relation &
		   [ LBL #lbl,
		     PRED sadv+,
		     arg0 event,
		     ARG1 #event ]!>,
	     HCONS <!!> ] ].

head-sadv-phrase-min := sadv-phrase-min & head-initial & binary-nexus-phrase &
			non-extr-phrase & binary-headed-gap-phrase &
  [ SYNSEM.LOCAL.NEG-OUT #neg-out,
    ARGS < [ SYNSEM #mod & [ FIRST-WORD +,
			     LOCAL [ NEG-OUT #neg-in,
				     CONT.HOOK [ LTOP #lbl ] ] ] ], 
	   [ SYNSEM [ LOCAL [ CAT [ HEAD sadv & [ MOD < #mod > ] ],
			      NEG-IN #neg-in,
			      NEG-OUT #neg-out,
			      CONT.HOOK [ LTOP #lbl ] ],
		      LKEYS.KEYREL #rel ] ] >,
    C-CONT.RELS <! #rel !> ].

sadv-phrase := head-sadv-phrase-min & zero-cop-input.

extr-sadv-phrase := sadv-phrase-min & unary-extr-phrase &
  [ HD-DTR #dtr,
    ARGS < #dtr &
	   [ SYNSEM [ LOCAL [ CAT #cat &
				  [ CASE subj-case,
				    ARGUMENT.LOCAL.CAT.CASE non-subj-case ],
			      CONT.HOOK.LTOP #lbl ],
		      NON-LOCAL.SLASH < [ CAT.HEAD sadv & 
						   [ MOD < [ LOCAL.CAT #cat ] > ],
					  CONT.HOOK.LTOP #lbl,
					  EXTR-REL #relation ] > ] ] >,
    C-CONT.RELS <! #relation !> ].


; PH 2016-05-25: Possessive modifier rule for post-modifying possessives:
; "Hunden min smiler."
post-poss-phrase := phrasal & val-or-mod-sign & head-compositional & head-initial & binary-nexus-phrase &
  [ START -,
    SYNSEM [ LOCAL [ CAT #cat,
		     CONT.MSG #msg ],
	     MODIFIED rmod ],
    ARGS < [ SYNSEM #mod & 
		    [ FIRST-WORD +,
		      LOCAL [ CAT #cat & 
				  [ HEAD noun ],
			      CONT [ HOOK [ LTOP #lbl,
					    INDEX #ind ],
				     MSG #msg ] ],
		      LKEYS.CNSTR.ARG0 #xarg,
		      MODIFIED notmod-or-lmod ] ],
	   [ SYNSEM [ LOCAL [ CAT.HEAD poss & [ MOD < #mod > ],
			      CONT.HOOK [ LTOP #lbl,
					  XARG #xarg ] ],
		      LKEYS.KEYREL  [ LBL #lbl,
				      PRED poss_rel,
				      ARG0 event,
				      ARG1 #ind ] ] ] >,
    C-CONT [ RELS <! !>,
	     HCONS <!!> ] ].

; PH 2019-02-28: added the EXTR-REL.PRED arg3- & arg4- & prp+ constraint
; in order to make generation work
; ex: Alene smiler jeg.
; restrict the possible modifiers
; took out the HD-DTR.SYNSEM.NON-LOCAL.SLASH.FIRST.CAT.CASE non-case constraint 
;                                                                    (2015-02-23; ph)
extr-mod-phrase := unary-extr-phrase &
  [ BOUNDARY -,
    SYNSEM [ LOCAL [ CAT [ HEAD compl-verb,
			   VAL #val2 ],
		     CONT [ HOOK #hook,
			    MSG #msg ],
		     TOPIC #topic ],
	     NON-LOCAL.SLASH <>,
	     LKEYS.KEYREL.LBL #ltop ],
    ARGS < [ SYNSEM [ MODIFIED notmod-or-rmod,
		      LOCAL [ CAT [ HEAD #head,
				    VAL #val2 & [ CMP1.LINK arg1-,
						  CMP2.LINK arg2-,
						  CMP3.LINK arg3-,
						  CMP4.LINK arg4- ],
				    ARGUMENT.LOCAL.CAT.CASE non-subj-case,
				    VBL anti-synsem ],
			      CONT.HOOK #hook & [ LTOP #ltop,
						  INDEX #arg1 ],
			      TOPIC #topic ],
		      NON-LOCAL.SLASH < [ CAT [ HEAD adj-adv-card-cond-compl-noun-prep & 
						     [ MOD < [ LOCAL [ CAT [ HEAD #head ],
								       CONT.HOOK #hook ] ] >,
						       AGREE.GENDER neut ],
						VAL valence &
						     [ SISTER.LOCAL.CONT.HOOK.INDEX.PNG.PN sg ] ],
					  CONT [ HOOK [ LTOP #ltop ],
						 MSG #msg ],
					  EXTR-REL [ LBL #ltop,
						PRED prt- & arg1+ & arg3- & arg4- & prp+,
						ARG0 event,
						ARG1 #arg1 ] ] > ] ] >,
    C-CONT [ RELS <! !>,
	     HCONS <!!> ] ].

;;;;;
;;;;;   SENTENCE ADVERBIALS
;;;;;

;PH 2006-10-09: Took out  MOD..C-COGN-ST in-foc
;PH 2008-03-21: Took out  MOD..C-COGN-ST uniq-or-more
s-word := basic-adv-word & norm-lex-item &
  [ SYNSEM [ LOCAL [ CAT [ HEAD [ MOD < [ LOCAL [ CAT [ ARGUMENT synsem-min,
						    C-COGN-ST cogn-st ] ],
				      MODIFIED xmod ] > ] ],
		     CONT [ HOOK [ LTOP #lbl,
                                   INDEX event & [ E.TENSE no_tense,
				                   SF no-msg_m_rel ],
				   XARG #xarg ],
                            RELS <! !>,
			    HCONS <!!> ] ],
	     LKEYS.KEYREL [ LBL #lbl,
			    ARG1 #xarg ] ] ].

sadv-word := s-word &
  [ SYNSEM.LOCAL.CAT.HEAD sadv ].
;; Han sover da ikke.
spart-word := s-word &
  [ SYNSEM.LOCAL.CAT.HEAD sadv & [ MOD < [ MODIFIED notmod ] > ] ].

univ-sadv-word := sadv-word &
  [ SYNSEM.LOCAL.CAT.HEAD.UNIV + ].

up-univ-sadv-word := univ-sadv-word & non-down-entailing.

down-entail-sadv-word := univ-sadv-word & downward-entailing.

norm-sadv-word := sadv-word & non-down-entailing &
  [ SYNSEM.LOCAL.CAT.HEAD.UNIV - ].


sadv-infl := val-or-mod-sign & inflecting-lex-rule & non-gen-word & keyrel-lex-item &
	     gap-unary &
  [ SYNSEM [ LOCAL [ CAT #cat,
		     CONT [ MSG #msg,
			    HOOK.LTOP #hndl ] ],
	     MODIFIED rmod ],
    DTR #2,
    HD-DTR #2 &[ BOUNDARY -,
	     SYNSEM [ MODIFIED notmod,
                      LOCAL [ CAT #cat & 
				  [ HEAD compl-verb,
				    CASE subj-case ],
			      CONT [ HOOK [ INDEX.E.TENSE imp-fin ],
				     MSG #msg ] ] ] ],
    C-CONT.RELS <! [ PRED _ikke_sadv_rel,
		     LBL #hndl ] !> ].

;;;;;
;;;;;   COORDINATION
;;;;;

;; PH 05-apr-2006: The coordination mechanism is not very well worked out. I
;; assume two sets of coordination rules, one set of sat(urated) conjuncts,
;; which does most of the work. The other set of coordination rules is the
;; unsat(urated) rules which account for coordination of Vs as in `Jon henter,
;; leser og kaster avisen' (Jon fetches, reads and throws the newspaper).

conj-value := sort.
no-pre-conj := conj-value.
in-conj := conj-value.
pre-conj := in-conj.
end-conj := no-pre-conj & in-conj.
no-conj := no-pre-conj.

conj-hook := hook &
  [ CONJ-IND individual ].

conj-cat := cat &
  [ CONJ-CAT category ].

; Removed relation from RELS and link to KEYREL.               (2016-01-15; ph)
conj-word-min := phrase-or-lexrule & keyrel-lex-item &
  [ BOUNDARY -,
    SYNSEM [ LOCAL [ CAT [ HEAD conj,
                           STACK <> ],
                     CONT [ HOOK [ LTOP #lbl,
				   INDEX #carg ],
                            RELS <! !>,
			    HCONS <! !> ] ],
             LKEYS.KEYREL [ LBL #lbl,
			    C-ARG #carg ] ] ].

conj-word := conj-word-min & continuative-item &
  [ SYNSEM.LOCAL.CAT.HEAD conj ].

comma-word := conj-word-min & embedding-mark & popping-mark &
  [ SYNSEM.LOCAL.CAT.HEAD conj,
    BRACKET co-nobr ].

; PH 2020-05-20; Removed MOD ARGS.FIRST.MOD link in order to parse
; menn med skog og mann
; PH 2013-01-31 added a ARGS.FIRST.HEAD nominal constraint in order to restrict
; the rule
conj-phrase := basic-binary-phrase & 
  [ START -,
    INFLECTED +,
    LINK-INPUT -,
    CONJ in-conj,
    BOUNDARY #bool,
    SYNSEM [ LOCAL [ CAT [ HEAD #head & [ MOD list ],
			   VAL #val,
			   STACK #stack,
                           VBL #m,
			   ARGUMENT #arg,
                           CONJ-CAT #cat,
			   CASE #case,
			   QUANT #q,
			   C #c ],
                     CONT [ HOOK #hook,
                            MSG #msg ] ],
             LKEYS #lkeys,
             NON-LOCAL #nl,
             PHR bool,
             SAT #sat ],
    ARGS < [ INFLECTED +,
             BOUNDARY #bool,
	     SYNSEM [ LOCAL [ CAT [ HEAD [ CATEGORY #cat,
					   MOD list ],
				    STACK < [ LOCAL [ CAT [ HEAD #head,
							    VAL #val,
							    ARGUMENT #arg,
							    VBL #m,
							    C #c ],
						      CONT [ HOOK #hook,
							     MSG #msg ] ],
					      NON-LOCAL #nl,
					      LKEYS #lkeys ] . #stack >,
				    CASE #case,
				    QUANT #q ] ],
		      PHR bool,
		      SAT #sat ] ], [ SYNSEM.LKEYS.KEYREL #keyrel ] >,
    C-CONT [ RELS.LIST.FIRST #keyrel ] ].

conj-sat-phrase := conj-phrase &
  [ SYNSEM [ LOCAL.CAT.ARGUMENT [ LOCAL.CONT.HOOK.INDEX #rind,
				  LKEYS [ KEYREL #keyrel,
					  Q.QREL [ ARG0 #rind ] ] ],
	     LKEYS.ALTKEYREL.PRED #conjpred ],
    ARGS < [ SYNSEM [ LOCAL [ CAT [ HEAD nominal,
				    VAL.SISTER anti-synsem,
				    QUANT + ],
			      CONT [ HOOK [ LTOP handle,
					    INDEX #index ] ] ],
		      LKEYS [ KEYREL [ LBL #larg,
				       ARG0 #lind ],
			      Q.QREL #qrel &
				     [ PRED quant_m_rel,
				       ARG0 #lind,
				       RSTR #harg ] ] ] ],
	   [ SYNSEM.LKEYS.KEYREL [ PRED #conjpred,
				   C-ARG #index & ref-ind & [ PNG.PN pl ], 
				   L-INDEX #lind,
				   R-INDEX #rind ] ] >,
    C-CONT [ RELS <! [ LBL #larg2,
		       C-ARG #arg0 ], #keyrel, #qrel,
		   indef-relation &
		   [ PRED udef_q_rel,
		     ARG0 #arg0,
		     RSTR #harg2 ] !>,
	     HCONS <! [ HARG #harg,
			LARG #larg ],
		      [ HARG #harg2,
			LARG #larg2 ]!> ] ].

conj-unsat-phrase := conj-phrase &
  [ SYNSEM.LOCAL.CAT.ARGUMENT.LOCAL.CONT.HOOK.CONJ-IND #rind & event,
    ARGS < [ SYNSEM [ LOCAL [ CAT [ HEAD adj-nominal,
				    VAL.SISTER synsem ],
			      CONT [ HOOK [ LTOP handle,
					    CONJ-IND #lind & event ] ] ],
		      LKEYS.KEYREL #keyrel ] ],
	   [ SYNSEM.LKEYS.KEYREL [ L-INDEX #lind,
				   R-INDEX #rind ] ] >,
    C-CONT [ RELS <! relation, #keyrel !>,
	     HCONS <!  !> ] ].

conj-adj-phrase := binary-phrase &
  [ SYNSEM #sister & [ LOCAL [ CAT.HEAD #head,
			       CONT.HOOK.INDEX #1 ] ],
    ARGS < conj-adj-end-phrase &
	   [ SYNSEM [ LOCAL.CAT.VAL.SISTER #sister,
		      LKEYS.KEYREL [ R-INDEX #rind & event ] ] ],
	   adj-word &
	   [ SYNSEM [ LOCAL.CAT.HEAD #head,
		      LKEYS.KEYREL #keyrel &
				     [ ARG0 #rind,
				       ARG1 #1 ] ] ] >,
    C-CONT [ RELS <! #keyrel !>,
	     HCONS <!  !> ] ].

conj-adj-end-phrase := binary-phrase &
  [ SYNSEM [ LOCAL.CAT [ HEAD conj,
			 STACK <>,
			 VAL.SISTER synsem &
			      [ LOCAL [ CAT #cat ],
				LKEYS #lkeys,
				NON-LOCAL #non-loc ] ],
	     LKEYS.KEYREL #keyrel ],
    ARGS < [ SYNSEM [ LOCAL [ CAT #cat & [ HEAD adj,
					   VAL.SISTER synsem ],
			      CONT [ HOOK [ LTOP handle,
					    CONJ-IND #lind & event ] ] ],
		      LKEYS #lkeys,
		      NON-LOCAL #non-loc ] ],
	   conj-word &
	   [ SYNSEM.LKEYS.KEYREL #keyrel & [ C-ARG event,
					     L-INDEX #lind ] ] >,
    C-CONT [ RELS <! #keyrel !>,
	     HCONS <!  !> ] ].

coord-s-min := basic-binary-phrase & start-item & uni-link-min &
  [ INFLECTED +,
    LINK-INPUT -,
    CONJ no-conj,
    SYNSEM [ LOCAL [ CAT [ HEAD compl-verb,
			   INTRANS #bool,
			   STACK <>,
			   ARGUMENT.LOCAL.CAT.CASE subj-case ],
		     CONT.HOOK.INDEX #rind & [ SF #mess ] ],
	     NON-LOCAL.SLASH <>,
	     LKEYS [ KEYREL.ARG0 #rind,
		     ELLREL.PRED #argframe ] ],
    ARGS < [ SYNSEM [ LOCAL [ CAT [ HEAD head,
				    INTRANS #bool ],
			      CONT.HOOK.INDEX #lind & [ SF #mess ] ],
		      NON-LOCAL.SLASH <>,
		      LKEYS.KEYREL.PRED #argframe ] ],
	  conj-word-min &
	   [ SYNSEM.LKEYS.KEYREL [ L-INDEX #lind,
				   R-INDEX #rind ] ] >,
    C-CONT [ HCONS <!!> ] ].

conj-s-phrase := coord-s-min &
  [ INFLECTED +,
    LINK-INPUT -,
    CONJ no-conj,
    SYNSEM [ LOCAL [ CAT [ HEAD aux,
			   STACK <>,
			   VBL synsem ],
		     CONT.HOOK.INDEX #rind,
		     TOPIC no-topic ],
	     NON-LOCAL.SLASH <> ],
    ARGS < clause &
	   [ SYNSEM.LOCAL.CONT.HOOK.INDEX #lind ],
	  conj-word-min &
	   [ SYNSEM.LKEYS.KEYREL #keyrel &
				 [ L-INDEX #lind,
				   R-INDEX #rind ] ] >,
    C-CONT [ RELS <! #keyrel & [ PRED reg_conj ] !>,
	     HCONS <!!> ] ].

conj-or-app-embedded-phrase := embedded-phrase-min & basic-binary-phrase & c-cont-rel-0 &
  [ CONJ #conj,
    LINK-INPUT -,
    SYNSEM [ LOCAL [ CAT [ HEAD #head,
			   VAL.ARGFRAME #argframe,
			   QUANT #q,
			   CASE #case,
			   VAL.SISTER #sis,
			   STACK < [ LOCAL.CAT [ VAL #val,
						 VBL #m,
						 C #c ],
				     NON-LOCAL #nl ], ... > ],
		     CONT.HOOK #hook ],
	     LKEYS #lkeys ],
    ARGS < [ CONJ #conj,
	     BOUNDARY -,
	     SYNSEM [ LOCAL [ CAT [ VAL #val,
				    ARGUMENT [ LOCAL.CONT.HOOK #hook,
					       LKEYS #lkeys ],
				    VBL #m,
				    CONJ-CAT #cc,
				    CASE #case,
				    C #c ] ],
		      NON-LOCAL #nl ] ], 
	   word &
	   [ CONJ no-conj,
	     SYNSEM [ LOCAL [ CAT [ HEAD #head & adj-nominal & [ CATEGORY #cc ],
				    VAL.ARGFRAME #argframe,
					 QUANT #q,
					 CASE #case,
					 VAL.SISTER #sis ],
				   CONT.HOOK [ INDEX event-or-ref-index ] ],
			   LKEYS #lkeys ] ] > ].

conj-embedded-phrase := conj-or-app-embedded-phrase &
  [ ARGS < conj-phrase, [] > ].

par-embedded-phrase := conj-or-app-embedded-phrase &
  [ ARGS < emb-par-phrase, [] > ].

;conj-emb-unsat-phrase := conj-embedded-phrase &
;  [ ARGS < conj-unsat-phrase , [ SYNSEM.LOCAL.CAT.VAL.SISTER synsem ] > ].
conj-emb-phrase := conj-embedded-phrase &
  [ ARGS < conj-phrase , [ SYNSEM.LOCAL.CAT.VAL.SISTER synsem-min ] > ].

conj-comma-sat-phrase := conj-sat-phrase & 
  [ CONJ pre-conj,
    ARGS < [ ], comma-word > ].

conj-end-sat-phrase := conj-sat-phrase & 
  [ CONJ end-conj,
    ARGS < [ ],
	   conj-word  > ].

conj-comma-unsat-phrase := conj-unsat-phrase & 
  [ CONJ pre-conj,
    ARGS < [ ], comma-word > ].

conj-end-unsat-phrase := conj-unsat-phrase & 
  [ CONJ end-conj,
    ARGS < [ ], conj-word > ].

coord-2frame := uni-link-min & binary-phrase &
 [ SYNSEM [ LOCAL [ CAT [ HEAD aux,
			  VAL.ARGFRAME #argframe,
			  STACK #stack ] ],
	    LKEYS.KEYREL.PRED #argframe ],
   ARGS < [ SYNSEM.LOCAL [ CAT [ VAL [ CMP1.LINK arg1-,
				       CMP2.LINK arg2-,
				       CMP3.LINK arg3-,
				       CMP4.LINK arg4- ],
				 STACK #stack ] ] ],
	  [ ] > ].

coord-basic := binary-phrase &
  [ SYNSEM phr-synsem &
	   [ LOCAL [ CONT [ HOOK [ INDEX #rind ],
			    MSG #msg ],
		     AGR #agr ]  ],
    ARGS < [ SYNSEM [ LOCAL [ CAT [ HEAD subcompl-verb,
				    VBL anti-synsem ],
			      CONT [ HOOK.INDEX #lind &
						[ SF #msg ],
				     MSG #msg ],
			      AGR #agr ] ] ],
	   conj-word-min & [ SYNSEM.LOCAL.CONT.HOOK.LTOP #lbl ] >,
    C-CONT.RELS.LIST.FIRST [ LBL #lbl,
			     L-INDEX #lind,
			     R-INDEX  #rind ] ].

coord-expr := coord-basic &
  [ SYNSEM.LOCAL.CAT.VBL synsem,
    C-CONT.RELS <! [] !> ].


; PH 2016-02-04: Took out the ARGUMENT link to the SLASH element in order
; to account for this sentence:
; Kari ga jeg en is og du en sjokolade.
; Kari ga jeg en is og ga du en sjokolade.
coord-vp-min := coord-basic & coord-2frame &
  [ START -,
    SYNSEM [ LOCAL [ CAT [ ARGUMENT.LOCAL.CAT.CASE subj-case,
			   INTRANS #intrans,
			   VAL.CMP4.MARKED -,
			   VBL.LOCAL.CAT.ARGUMENT.LOCAL.CAT.CASE subj-case,
			   C + ],
		     TOPIC #topic ],
	     NON-LOCAL.SLASH < #topic >,
	     LKEYS [ KEYREL.ARG0 #rind,
		     ELLREL.PRED #argframe ] ],
    LINK-INPUT -,
    ARGS < [ BOUNDARY -,
	     SYNSEM [ LOCAL [ CAT [ HEAD subcompl-verb,
				    INTRANS #intrans ],
			      CONT.HOOK.INDEX #lind,
                              TOPIC #topic ],
		      NON-LOCAL.SLASH <>,
		      LKEYS.KEYREL.PRED #argframe ] ],
	   conj-word-min &
	   [ SYNSEM.LKEYS.KEYREL [ L-INDEX #lind,
				   R-INDEX #rind ] ]  >,
    C-CONT [ RELS.LIST.FIRST [ PRED atom ],
	     HCONS <!!> ] ].

coord-vp-phrase := coord-vp-min & coord-expr & neg-link &
  [ ARGS < [ CONJ no-pre-conj,
	     BOUNDARY - ], [ SYNSEM.LKEYS.KEYREL #keyrel ] >,
    C-CONT.RELS <! #keyrel & [ PRED reg_conj ] !> ].

pseudeo-coord :=  coord-basic &
  [ SYNSEM.NON-LOCAL #nl,
    ARGS < [ SYNSEM.NON-LOCAL #nl ],
	   [ SYNSEM.LKEYS.KEYREL.PRED "_og_conj_rel" ] > ].


bicl-subcoord-phrase := pseudeo-coord & coord-2frame & uni-link &
  [ SYNSEM [ LOCAL.CAT [ CASE non-subj-case,
			 ARGUMENT.LOCAL [ CONT.HOOK.INDEX #xarg,
					  CAT.CASE non-subj-case ],
			 VBL synsem &
			      [ LOCAL.CONT.HOOK [ INDEX.E.TENSE #tense ] ] ],
	     NON-LOCAL #sl,
	     --PHR-KEY no-msg ],
    ARGS < [ SYNSEM [ LOCAL [ CAT [ VAL [ ARGFRAME  arg1- & arg3-,
					  CMP2.LOCAL.CONT.HOOK.INDEX #xarg ] ],
			      CONT [ HOOK.INDEX.E.TENSE #tense ] ],
		      NON-LOCAL #sl,
		      LKEYS.KEYREL.PRED bicl_rel ] ], 
	   conj-word & [ SYNSEM.LKEYS.KEYREL.PRED "_og_conj_rel" ] >,
    C-CONT [ RELS.LIST.FIRST.PRED "bicl_sub_coord_rel",
	     HCONS <!!> ],
    LINK-INPUT + ].

subcoord2-phrase := pseudeo-coord &
  [ SYNSEM [ LOCAL [ CAT [ HEAD #head,
			   CASE non-subj-case,
			   STACK #rest,
			   VAL #val,
			   ARGUMENT.LOCAL [ CAT.CASE non-subj-case ],
			   VBL.LOCAL.CONT.HOOK.INDEX #rind & [ E.TENSE #tense ] ],
		     CONT.HOOK.LTOP #lbl ],
	     NON-LOCAL #nl,
	     --PHR-KEY no-msg ],
    ARGS < [ SYNSEM [ LOCAL [ CAT [ HEAD #head & subcompl-infcompl-verb,
				    STACK #rest & 0-1-list,
				    VAL #val & 
					 [ ARGFRAME arg1+ & #link,
					   CMP1.LINK arg1-,
					   CMP3.LINK #link,
					   CMP4.LINK #link ] ],
			      CONT.HOOK [ INDEX [ E.TENSE #tense ],
					  LTOP #lbl ] ],
		      NON-LOCAL #nl ] ], 
	   conj-word & [ SYNSEM.LKEYS.KEYREL [ LBL #lbl,
					       PRED "_og_conj_rel" ] ] >,
    C-CONT.RELS  <! [ R-INDEX #rind ] !>,
    LINK-INPUT - ].

monocl-subcoord := subcoord2-phrase &
  [ ARGS < [ SYNSEM [ LOCAL.CAT.VAL [ ARGFRAME #link,
				      CMP2.LINK #link ],
		      LKEYS.KEYREL.PRED monocl_rel ] ], []>,
    C-CONT [ RELS.LIST.FIRST.PRED "monocl_sub_coord_rel",
	     HCONS <!!> ] ].

eoc-coord := subcoord2-phrase &
  [ ARGS < [ SYNSEM [ LOCAL.CAT.VAL [ ARGFRAME arg2+,
				      CMP2.LINK arg2- ],
		      LKEYS.KEYREL.PRED eoc_rel ] ], []>,
    C-CONT [ RELS.LIST.FIRST.PRED "eoc_sub_coord_rel",
	     HCONS <!!> ] ].

conj-mod-word := mod-mod-word &
  [ SYNSEM.LOCAL.CAT.HEAD mod-mod & [ MOD list ] ].

; conj-mod-phrase := head-final & head-compositional &
;   [ SYNSEM [ LOCAL [ CAT #cat,
;                      CONT.HOOK #hook ],
;              NON-LOCAL #nl ],
;     ARGS < conj-mod-word & [ SYNSEM [ LOCAL.CONT.HOOK #hook,
;                                       LKEYS.ALTKEYREL.PRED #pred ] ], 
;            conj-top-phrase & 
;              [ SYNSEM [ LOCAL [ CAT #cat,
;                                 CONT.HOOK #hook ],
;                         NON-LOCAL #nl,
;                         LKEYS.KEYREL.PRED #pred ] ] >,
;     C-CONT.RELS <!!>,
;     LINK-INPUT - ].

;;;;;
;;;;;   PUNCTUATION MARKS
;;;;;

period-word := inflecting-lex-rule & post-punct-word &
  [ SYNSEM #ss,
    INFLECTED +,
    PUNCT punct,
    LINK-INPUT #l,
    ARGS < [ SYNSEM #ss,
	     INFLECTED +,
	     SYNSEM.FIRST-WORD -,
	     PUNCT no-punct,
	     LINK-INPUT #l ] > ].

punct-word := word-or-lexrule &
  [ SYNSEM [ FIRST-WORD -,
	     LOCAL [ CAT.HEAD non-head,
		     CONT [ RELS <! [] !> ] ] ] ].

pre-punct-word := punct-word &
  [ SYNSEM.LOCAL.CAT.STACK <> ].

embedding-mark := word-or-lexrule.

open-bracket-word := pre-punct-word & embedding-mark &
  [ COLON -,
    BRACKET brack ].

post-punct-word := word-or-lexrule.

popping-mark := word-or-lexrule.

close-bracket-word := post-punct-word & punct-word & popping-mark.

start-item := sign &
  [ START +,
    SYNSEM [ FIRST-WORD +,
	     LOCAL.CAT [ AAIF +,
			 C +,
			 VAL.CMP4.MARKED - ],
	     NON-LOCAL.SLASH <>,
	     LKEYS.ALTKEYREL.PRED reg_conj,
	     COMP-IND index ] ].

start-head := sign &
  [ SYNSEM.LOCAL.CAT.HEAD subcompl-infcompl-verb ].

start-word := start-item & uni-link & start-head & word &
  [ CONJ no-conj,
    SYNSEM [ FIRST-WORD +,
	     LOCAL [ CAT [ HEAD.ELLIPSIS -,
			   STACK <>,
			   C +,
			   VBL synsem ],
		     CONT [ RELS <! !>,
			    HOOK.INDEX event,
			    HCONS <! !> ],
		     TOPIC no-topic ],
	     NON-LOCAL.SLASH <> ],
    LINK-INPUT - ].

colon-word := pre-punct-word & embedding-mark &
  [ COLON +,
    BRACKET no-brack,
    SYNSEM.LOCAL.CAT.VAL.SISTER [ SAT +,
                                  LOCAL [ CAT.HEAD adj-adv-nominal-prep ] ] ].

; comma-word := pre-punct-word & post-punct-word &
;   [ COLON -,
;     BRACKET comma ].

; pre-punct-phrase := basic-binary-phrase & first-word-phrase &
;   [ BRACKET co-nobr,
;     COLON #col,
;     BOUNDARY -,
;     SYNSEM [ LOCAL [ CAT [ HEAD prep,
;                            VAL [ CMP2 [ LINK arg2-,
;                                         SAT + ],
;                                  SISTER anti-synsem ],
; 			   STACK <> ],
;                      CONT.HOOK.LTOP #lbl ],
;              NON-LOCAL.SLASH <> ],
;     ARGS < pre-punct-word &
;            [ BRACKET #br,
;              COLON #col ],
;            [ INFLECTED +,
;              BRACKET #br,
;              BOUNDARY -,
;              SYNSEM [ SAT +,
;                       LOCAL [ CAT.HEAD adj-adv-nominal-prep,
;                               CONT.HOOK.INDEX #1 ] ] ] >,
;     C-CONT.RELS <! [ PRED "parenthesis_rel",
;                      LBL #lbl,
;                      ARG0 #1 ] !> ].

;; Phrase for initiating parentheticals
emb-par-phrase := basic-binary-phrase & start-item & embedded-phrase-min-min & uni-link &
  [ INFLECTED +,
    LINK-INPUT -,
    CONJ no-conj,
    BRACKET #bracket,
    SYNSEM [ LOCAL [ CAT [ HEAD start,
			   STACK.FIRST.LOCAL.CAT [ VAL #val,
						   CASE #c,
						   QUANT #q,
						   AAIF #fc,
						   ARGUMENT #arg,
						   VBL #verbal ],
			   VBL synsem ],
		     CONT.HOOK.INDEX #rind ],
	     NON-LOCAL.SLASH <> ],
    ARGS < phrase &
	   [ BOUNDARY -,
	     SYNSEM [ MODIFIED rmod,
		      LOCAL [ CAT [ HEAD nominal,
				    VAL #val,
				    CASE #c,
				    QUANT #q,
				    AAIF #fc,
				    ARGUMENT #arg,
				    VBL #verbal ],
			      CONT.HOOK.INDEX #lind ] ] ],
	   embedding-mark &
	   [ BRACKET #bracket,
	     SYNSEM.LKEYS.KEYREL [ L-INDEX #lind,
				   R-INDEX #rind ] ] >,
    C-CONT [ RELS <!!>,
	     HCONS <!!> ] ].

; colon-phrase := basic-binary-phrase & c-cont-1 &
;   [ BRACKET noco-nobr,
;     COLON +,
;     BOUNDARY -,
;     SYNSEM [ LOCAL [ CAT [ HEAD prep,
;                            VAL.CMP2 [ LINK arg2-,
;                                       SAT + ] ],
;                      CONT.HOOK.LTOP #lbl ],
;              NON-LOCAL.SLASH <> ],
;     ARGS < colon-word & [ SYNSEM.LOCAL.CAT.VAL.SISTER #sister ],
;            [ INFLECTED +,
;              BOUNDARY -,
;              SYNSEM #sister & [ SAT +,
;                       LOCAL [ CAT.HEAD adj-adv-nominal-prep,
;                               CONT.HOOK.INDEX #1 ] ] ] >,
;     C-CONT.RELS <! [ PRED "colon_rel",
;                      LBL #lbl,
;                      ARG0 #1 ] !> ].

; close-bracket-phrase := basic-binary-phrase &
;   [ BRACKET #br,
;     BOUNDARY #bool,
;     SYNSEM #synsem,
;     ARGS < word &
;            [ BOUNDARY #bool,
;              SYNSEM #synsem ],
;            post-punct-word &
;            [ BRACKET #br ] >,
;     C-CONT [ RELS <!!>,
; 	     HCONS <!!> ] ].


;;; Inuqit phrases

inquit-input-phrase := binary-phrase & uni-link &
  [ START -,
    SYNSEM [ LOCAL [ CAT [ STACK <>,
			 HEAD aux-verb,
			 CASE subj-case,
			 VBL synsem,
			 AAIF -,
			 C + ],
		     CONT.HOOK.INDEX.SF #mess,
		     TOPIC.CAT.HEAD.MESS #mess & prop_m_rel ],
	     NON-LOCAL.SLASH < [ CAT [ HEAD.MOD <>,
				       CASE non-subj-case ],
				 EXTR-REL #keyrel,
				 EXTR-LINK 2inq ] > ],
    ARGS < [ SYNSEM.LKEYS.KEYREL #keyrel ], comma-word >,
    C-CONT [ RELS <!!>,
	     HCONS <!!> ],
    LINK-INPUT - ].

inquit-s-phrase := inquit-input-phrase &
  [ SYNSEM.NON-LOCAL.SLASH < [ CONT.HOOK.INDEX #index ] >,
    ARGS < phrase &
	   [ BOUNDARY +,
	     SYNSEM [ LOCAL [ CAT [ HEAD aux-verb,
				    VAL [ CMP1.LINK arg1-,
					  CMP2.LINK arg2-,
					  CMP4.LINK arg4- ] ],
			      CONT.HOOK.INDEX #index ],
		      NON-LOCAL.SLASH <> ] ], [] > ].

inquit-xp-phrase := inquit-input-phrase &
  [ SYNSEM.NON-LOCAL.SLASH < [ CONT.HOOK.INDEX #1 ] >,
    ARGS <pop-phrase &
	  [ CONJ no-conj,
	    SYNSEM [ LOCAL.CAT [ HEAD aux-verb,
				 STACK < >,
				 VBL synsem,
				 C + ],
		     MODIFIED notmod,
		     NON-LOCAL.SLASH < [ CONT.HOOK.INDEX #1 ] > ] ], [] > ].

;;; Rel types for tiny lexicon
når_prd := predsort.
når_prp := når_prd & prp+.
_når_adv_rel := når_prp & adv-link.

senere_prd := predsort.
senere_prp := senere_prd & prp+.
_senere_adv_rel := senere_prp & adv-link.

_på_adv_rel := på_prp & adv-link.
_på_p_rel := på_prp & arg1+ & 2np & arg3- & arg4- & prt-.
_lodd_n_rel := lodd_prd & arg1- & arg2- & arg3- & arg4- & prt- & atom.
lodd_n := lodd_prd & idiomform.
lodd_prd := link.

frem_prd := predsort.
frem_prp := frem_prd & prp+.
på_prd := predsort.
på_prp := på_prd & prp+.
på_prt := på_prd & prt+.
ned_prd := predsort.
ned_prp := ned_prd & prp+.
ned_prt := ned_prd & prt+.
til_prd := predsort.
til_prp := til_prd & prp+.
til_prt := til_prd & prt+.
tilbake_prd := predsort.
tilbake_prp := tilbake_prd & prp+.
tilbake_prt := tilbake_prd & prt+.
frem_prt := frem_prd & prt+.
ut_prd := predsort.
ut_prp := ut_prd & prp+.
ut_prt := ut_prd & prt+.
bort_prd := predsort.
bort_prp := bort_prd & prp+.
bort_prt := bort_prd & prt+.
_bort_adv_rel := bort_prp & adv-link.
_bort_p_rel := bort_prp & arg1+ & 2np & arg3- & arg4- & prt-.
med_prd := predsort.
med_prp := med_prd & prp+.
med_prt := med_prd & prt+.
i_prd := predsort.
i_prp := i_prd & prp+.
i_prt := i_prd & prt+.
_i_p_rel := i_prp & arg1+ & 2np & arg3- & arg4- & prt-.
opp_prd := predsort.
opp_prp := opp_prd & prp+.
opp_prt := opp_prd & prt+.
_opp_adv_rel := opp_prp & adv-link.
_opp_p_rel := opp_prp & arg1+ & 2np & arg3- & arg4- & prt-.
igjen_prd := predsort.
igjen_prp := igjen_prd & prp+.
igjen_prt := igjen_prd & prt+.
ved_prd := predsort.
ved_prp := ved_prd & prp+.
ved_prt := ved_prd & prt+.
noe_prd := predsort.
noe_prt := noe_prd & prt+.
imot_prd := predsort.
imot_prp := imot_prd & prp+.
imot_prt := imot_prd & prt+.
_imot_adv_rel := imot_prp & adv-link.
_imot_p_rel := imot_prp & arg1+ & 2np & arg3- & arg4- & prt-.
rundt_prd := predsort.
rundt_prp := rundt_prd & prp+.
rundt_prt := rundt_prd & prt+.
av_prd := predsort.
av_prp := av_prd & prp+.
av_prt := av_prd & prt+.
_av_adv_rel := av_prp & adv-link.
_av_p_rel := av_prp & arg1+ & 2np & arg3- & arg4- & prt-.
godt_prt := godt_prd & prt+.
å_prd := predsort.
å_prt := å_prd & prt+.
rede_prd := predsort.
rede_prt := rede_prd & prt+.
frabedt_prd := predsort.
frabedt_prt := frabedt_prd & prt+.
braute_v := vrb+.
_braute_1_rel := braute_v & vbl+ & 1np & arg2- & arg3- & arg4- & prt-.
_braute-inq_12_rel := braute_v & vbl+ & 1np & 2inq & arg3- & arg4- & prt-.
sove_v := vrb+.
_sove-bort_12_rel := sove_v & vbl+ & 1np & 2np & arg3- & arg4- & bort_prt.
_sove-over_1_rel := sove_v & vbl+ & 1np & arg2- & arg3- & arg4- & over_prt.
_sove-hen_1_rel := sove_v & vbl+ & 1np & arg2- & arg3- & arg4- & hen_prt.
_sove-inn_1_rel := sove_v & vbl+ & 1np & arg2- & arg3- & arg4- & inn_prt.
_sove-ut_1_rel := sove_v & vbl+ & 1np & arg2- & arg3- & arg4- & ut_prt.
_sove_2_rel := sove_v & vbl+ & arg1- & 2np & arg3- & arg4- & prt-.
_sove-ut_12_rel := sove_v & vbl+ & 1np & 2np & arg3- & arg4- & ut_prt.
over_prd := predsort.
over_prp := over_prd & prp+.
over_prt := over_prd & prt+.
hen_prd := predsort.
hen_prp := hen_prd & prp+.
hen_prt := hen_prd & prt+.
inn_prd := predsort.
inn_prp := inn_prd & prp+.
inn_prt := inn_prd & prt+.
_over_adv_rel := over_prp & adv-link.
_over_p_rel := over_prp & arg1+ & 2np & arg3- & arg4- & prt-.

mann_prd := predsort.
_mann_n_rel := predsort.

konkurs_n := konkurs_prd & idiomform.
konkurs_prd := predsort.
_konkurs_n_rel := konkurs_prd & arg1- & arg2- & arg3- & arg4- & prt- & atom.
smile_v := vrb+.
_smile*av_14_rel := smile_v & vbl+ & 1np & arg2- & arg3- & 4np & av_prp & prt-.
_smile*til_14_rel := smile_v & vbl+ & 1np & arg2- & arg3- & 4np & til_prp & prt-.
_smile_1_rel := smile_v & vbl+ & 1np & arg2- & arg3- & arg4- & prt-.
hevde_v := vrb+.
_hevde-cp_12_rel := hevde_v & vbl+ & 1np & 2cp & arg3- & arg4- & prt-.
_hevde-refl_1_rel := hevde_v & vbl+ & 1np & refl & arg2+ & arg3- & arg4- & prt-.
_hevde_12_rel := hevde_v & vbl+ & 1np & 2np & arg3- & arg4- & prt-.
_hevde_a_rel := hevde_v & adj+ & 1np & 2np & arg3- & arg4- & prt-.
_hevde-ip1_12_rel := hevde_v & vbl+ & 1np & 2ip1 & arg3- & arg4- & prt-.
legge_v := vrb+.
_legge*til-cp_14_rel := legge_v & vbl+ & 1np & arg2- & arg3- & 4cp & til_prp & prt-.
_legge*inn_14_rel := legge_v & vbl+ & 1np & arg2- & arg3- & 4np & inn_prp & prt-.
_legge*til_14_rel := legge_v & vbl+ & 1np & arg2- & arg3- & 4np & til_prp & prt-.
_legge-ap_14_rel := legge_v & vbl+ & 1np & refl & arg2+ & arg3- & 4ap & prp- & prt-.
_legge*under-refl_12_rel := legge_v & vbl+ & 1np & 2np & arg3- & arg4+ & refl & under_prp & prt-.
_legge*på-refl_12_rel := legge_v & vbl+ & 1np & 2np & arg3- & arg4+ & refl & på_prp & prt-.
_legge*fra-refl_12_rel := legge_v & vbl+ & 1np & 2np & arg3- & arg4+ & refl & fra_prp & prt-.
_legge-på_1_rel := legge_v & vbl+ & 1np & arg2- & arg3- & arg4- & på_prt.
_legge-opp_1_rel := legge_v & vbl+ & 1np & arg2- & arg3- & arg4- & opp_prt.
_legge-til_12_rel := legge_v & vbl+ & 1np & 2np & arg3- & arg4- & til_prt.
_legge-på_12_rel := legge_v & vbl+ & 1np & 2np & arg3- & arg4- & på_prt.
_legge-inn_12_rel := legge_v & vbl+ & 1np & 2np & arg3- & arg4- & inn_prt.
_legge-opp_12_rel := legge_v & vbl+ & 1np & 2np & arg3- & arg4- & opp_prt.
_legge-ned_12_rel := legge_v & vbl+ & 1np & 2np & arg3- & arg4- & ned_prt.
_legge_12_rel := legge_v & vbl+ & 1np & 2np & arg3- & arg4- & prt-.
_legge_a_rel := legge_v & adj+ & 1np & 2np & arg3- & arg4- & prt-.
_legge-refl_1_rel := legge_v & vbl+ & 1np & refl & arg2+ & arg3- & arg4- & prt-.
_legge-til-cp_12_rel := legge_v & vbl+ & 1np & 2cp & arg3- & arg4- & til_prt.
_legge-frem_12_rel := legge_v & vbl+ & 1np & 2np & arg3- & arg4- & frem_prt.
_legge-igjen_12_rel := legge_v & vbl+ & 1np & 2np & arg3- & arg4- & igjen_prt.
_legge*på-refl_1_rel := legge_v & vbl+ & 1np & arg2- & arg3- & arg4+ & refl & på_prp & prt-.
_legge-til_1_rel := legge_v & vbl+ & 1np & arg2- & arg3- & arg4- & til_prt.
_legge-i_12_rel := legge_v & vbl+ & 1np & 2np & arg3- & arg4- & i_prt.
_legge-om_12_rel := legge_v & vbl+ & 1np & 2np & arg3- & arg4- & om_prt.
_legge-vekk_12_rel := legge_v & vbl+ & 1np & 2np & arg3- & arg4- & vekk_prt.
_legge-ut_1_rel := legge_v & vbl+ & 1np & arg2- & arg3- & arg4- & ut_prt.
_legge-ut_12_rel := legge_v & vbl+ & 1np & 2np & arg3- & arg4- & ut_prt.
_legge-ut*på_14_rel := legge_v & vbl+ & 1np & arg2- & arg3- & 4np & på_prp & ut_prt.
_legge-refl-ut*med_14_rel := legge_v & vbl+ & 1np & refl & arg2+ & arg3- & 4np & med_prp & ut_prt.
_legge-opp*til-cp_14_rel := legge_v & vbl+ & 1np & arg2- & arg3- & 4cp & til_prp & opp_prt.
_legge-over*til_14_rel := legge_v & vbl+ & 1np & arg2- & arg3- & 4np & til_prp & over_prt.
_legge-til*for_14_rel := legge_v & vbl+ & 1np & arg2- & arg3- & 4np & for_prp & til_prt.
_legge-til*for_124_rel := legge_v & vbl+ & 1np & 2np & arg3- & 4np & for_prp & til_prt.
merke_prd := predsort.
merke_n := merke_prd & idiomform.
_merke_n_rel := merke_prd & arg1- & arg2- & arg3- & arg4- & prt- & atom.
_legge*merke*til_14_rel := legge_v & vbl+ & 1np & merke_n & arg2+ & arg3- & 4np & til_prd & prp+ & prt-.
_legge*merke*til-cp_14_rel := legge_v & vbl+ & 1np & merke_n & arg2+ & arg3- & 4cp & til_prd & prp+ & prt-.
_legge*merke*til-wh_14_rel := legge_v & vbl+ & 1np & merke_n & arg2+ & arg3- & 4wh & til_prd & prp+ & prt-.
vekt_n := vekt_prd & idiomform.
vekt_prd := predsort.
_vekt_n_rel := vekt_prd & arg1- & arg2- & arg3- & arg4- & prt- & atom.
_legge*vekt*på_14_rel := legge_v & vbl+ & 1np & vekt_n & arg2+ & arg3- & 4np & på_prd & prp+ & prt-.
_legge*vekt*på-cp_14_rel := legge_v & vbl+ & 1np & vekt_n & arg2+ & arg3- & 4cp & på_prd & prp+ & prt-.
skjul_n := skjul_prd & idiomform.
skjul_prd := predsort.
_skjul_n_rel := skjul_prd & arg1- & arg2- & arg3- & arg4- & prt- & atom.
_legge*skjul*på_14_rel := legge_v & vbl+ & 1np & skjul_n & arg2+ & arg3- & 4np & på_prd & prp+ & prt-.
_legge*skjul*på-cp_14_rel := legge_v & vbl+ & 1np & skjul_n & arg2+ & arg3- & 4cp & på_prd & prp+ & prt-.
svøm_n := svøm_prd & idiomform.
svøm_prd := predsort.
_svøm_n_rel := svøm_prd & arg1- & arg2- & arg3- & arg4- & prt- & atom.
_legge*på*svøm_1_rel := legge_v & vbl+ & 1np & arg2- & arg3- & på_prd & prp+ & 4idiom & svøm_n & prt-.
gå_v := vrb+.
_gå_12_rel := gå_v & vbl+ & 1np & 2np & arg3- & arg4- & prt-.
_gå*av_14_rel := gå_v & vbl+ & 1np & arg2- & arg3- & 4np & av_prp & prt-.
_gå*gjennom_14_rel := gå_v & vbl+ & 1np & arg2- & arg3- & 4np & gjennom_prp & prt-.
_gå*med_14_rel := gå_v & vbl+ & 1np & arg2- & arg3- & 4np & med_prp & prt-.
_gå*på_14_rel := gå_v & vbl+ & 1np & arg2- & arg3- & 4np & på_prp & prt-.
_gå*for_14_rel := gå_v & vbl+ & 1np & arg2- & arg3- & 4np & for_prp & prt-.
_gå-refl_12_rel := gå_v & vbl+ & 1np & 2np & arg3+ & refl & arg4- & prt-.
gå-refl-bort_1_rel := gå_v & vbl+ & 1np & refl & arg2+ & arg3- & arg4- & bort_prt.
_gå*konkurs_1_rel := gå_v & vbl+ & 1np & konkurs_n & arg2+ & arg3- & arg4- & prt-.
_gå-ip_2_rel := gå_v & vbl+ & arg1- & 2ip & arg3- & arg4- & prt-.
_gå-an-ip_2_rel := gå_v & vbl+ & arg1- & 2ip & arg3- & arg4- & an_prt.
_gå-an-cp_2_rel := gå_v & vbl+ & arg1- & 2cp & arg3- & arg4- & an_prt.
_gå-med*på_14_rel := gå_v & vbl+ & 1np & arg2- & arg3- & 4np & på_prp & med_prt.
_gå-ut*over_14_rel := gå_v & vbl+ & 1np & arg2- & arg3- & 4np & over_prp & ut_prt.
_gå-ut*på_14_rel := gå_v & vbl+ & 1np & arg2- & arg3- & 4np & på_prp & ut_prt.
_gå-opp*for-wh_24_rel := gå_v & vbl+ & arg1- & 2wh & arg3- & 4np & for_prp & opp_prt.
_gå-med*på-cp_14_rel := gå_v & vbl+ & 1np & arg2- & arg3- & 4cp & på_prp & med_prt.
_gå-ut*fra-cp_14_rel := gå_v & vbl+ & 1np & arg2- & arg3- & 4cp & fra_prp & ut_prt.
_gå-ut*ifra-cp_14_rel := gå_v & vbl+ & 1np & arg2- & arg3- & 4cp & ifra_prp & ut_prt.
_gå-med*på-ip1_14_rel := gå_v & vbl+ & 1np & arg2- & arg3- & 4ip1 & på_prp & med_prt.
_gå-sammen*om-ip1_14_rel := gå_v & vbl+ & 1np & arg2- & arg3- & 4ip1 & om_prp & sammen_prt.
_gå-ut*på-cp_14_rel := gå_v & vbl+ & 1np & arg2- & arg3- & 4cp & på_prp & ut_prt.
_gå-ut*på-ip1_14_rel := gå_v & vbl+ & 1np & arg2- & arg3- & 4ip1 & på_prp & ut_prt.
_gå-over*til-ip1_14_rel := gå_v & vbl+ & 1np & arg2- & arg3- & 4ip1 & til_prp & over_prt.
_gå*for-refl_1_rel := gå_v & vbl+ & 1np & arg2- & arg3- & arg4+ & refl & for_prp & prt-.
_gå-i*med_14_rel := gå_v & vbl+ & 1np & arg2- & arg3- & 4np & med_prp & i_prt.
_gå-i_1_rel := gå_v & vbl+ & 1np & arg2- & arg3- & arg4- & i_prt.
_gå-igjen_1_rel := gå_v & vbl+ & 1np & arg2- & arg3- & arg4- & igjen_prt.
_gå*i*oppløsning_1_rel := gå_v & vbl+ & 1np & arg2- & arg3- & i_prd & prp+ & 4idiom & oppløsning_n & prt-.
_gå-under_1_rel := gå_v & vbl+ & 1np & arg2- & arg3- & arg4- & under_prt.
_gå-av_1_rel := gå_v & vbl+ & 1np & arg2- & arg3- & arg4- & av_prt.
_gå-med_1_rel := gå_v & vbl+ & 1np & arg2- & arg3- & arg4- & med_prt.
_gå-tilbake_1_rel := gå_v & vbl+ & 1np & arg2- & arg3- & arg4- & tilbake_prt.
_gå_2_rel := gå_v & vbl+ & arg1- & 2np & arg3- & arg4- & prt-.
_gå_0_rel := gå_v & vbl+ & arg1- & arg2- & arg3- & arg4- & prt-.
_gå-av*med_14_rel := gå_v & vbl+ & 1np & arg2- & arg3- & 4np & med_prp & av_prt.
_gå-ut*med_14_rel := gå_v & vbl+ & 1np & arg2- & arg3- & 4np & med_prp & ut_prt.
_gå-ned_1_rel := gå_v & vbl+ & 1np & arg2- & arg3- & arg4- & ned_prt.
_gå-istykker_1_rel := gå_v & vbl+ & 1np & arg2- & arg3- & arg4- & istykker_prt.
_gå-sund_1_rel := gå_v & vbl+ & 1np & arg2- & arg3- & arg4- & sund_prt.
_gå-lei_1_rel := gå_v & vbl+ & 1np & arg2- & arg3- & arg4- & lei_prt.
_gå-lei*av-cp_14_rel := gå_v & vbl+ & 1np & arg2- & arg3- & 4cp & av_prp & lei_prt.
_gå-ut_1_rel := gå_v & vbl+ & 1np & arg2- & arg3- & arg4- & ut_prt.
_gå-over_1_rel := gå_v & vbl+ & 1np & arg2- & arg3- & arg4- & over_prt.
_gå-ap_14_rel := gå_v & vbl+ & 1np & refl & arg2+ & arg3- & 4ap & prp- & prt-.
gå-refl-til_1_rel := gå_v & vbl+ & 1np & refl & arg2+ & arg3- & arg4- & til_prt.
gå-refl-vekk_1_rel := gå_v & vbl+ & 1np & refl & arg2+ & arg3- & arg4- & vekk_prt.
_gå-ut_12_rel := gå_v & vbl+ & 1np & 2np & arg3- & arg4- & ut_prt.
_gå-inn_12_rel := gå_v & vbl+ & 1np & 2np & arg3- & arg4- & inn_prt.
_gå_1_rel := gå_v & vbl+ & 1np & arg2- & arg3- & arg4- & prt-.

skulle_v := vrb+. 
_skulle_12_rel := skulle_v & vbl+ & 1np & 2np & arg3- & arg4- & prt-.


oppløsning_prd := predsort.
oppløsning_n := oppløsning_prd & idiomform.
istykker_prd := predsort.
istykker_prt := istykker_prd & prt+.
sund_prd := predsort.
sund_prt := sund_prd & prt+.
lei_prd := predsort.
lei_prt := lei_prd & prt+.
an_prd := predsort.
an_prp := an_prd & prp+.
an_prt := an_prd & prt+.
sammen_prd := predsort.
sammen_prp := sammen_prd & prp+.
sammen_prt := sammen_prd & prt+.
ifra_prd := predsort.
ifra_prp := ifra_prd & prp+.
ifra_prt := ifra_prd & prt+.
under_prd := predsort.
under_prp := under_prd & prp+.
under_prt := under_prd & prt+.
fra_prd := predsort.
fra_prp := fra_prd & prp+.
fra_prt := fra_prd & prt+.
vekk_prd := predsort.
vekk_prp := vekk_prd & prp+.
vekk_prt := vekk_prd & prt+.
på*lenge_prd := predsort.
på*lenge_prp := på*lenge_prd & prp+.
_på*lenge_adv_rel := på*lenge_prp & adv-link.
alene_prd := predsort.
alene_prp := alene_prd & prp+.
_alene_adv_rel := alene_prp & adv-link.
_fra_adv_rel := fra_prp & adv-link.
_fra_p_rel := fra_prp & arg1+ & 2np & arg3- & arg4- & prt-.
_fra_x_rel := fra_prd & cadv+.

veldig_prd := predsort.
_veldig_deg-pos_rel := veldig_prd & deg-pos.
_veldig_deg-qnt_rel := veldig_prd & deg-qnt.

uvanlig_prd := predsort.
_uvanlig_deg-pos_rel := uvanlig_prd & deg-pos.
_uvanlig_deg-qnt_rel := uvanlig_prd & deg-qnt.

dels_prd := predsort.
_dels_deg-pos_rel := dels_prd & deg-pos.

mer_prd := predsort.
_mer_deg-pos_rel := mer_prd & deg-pos.
_mer_deg-cmp_rel := mer_prd & deg-cmp.
mer_prp := mer_prd & prp+.
_mer_adv_rel := mer_prp & adv-link.

mindre_prd := predsort.
_mindre_deg-pos_rel := mindre_prd & deg-pos.

_mest_deg-pos_rel := mest_prd & deg-pos.

_minst_deg-pos_rel := minst_prd & deg-pos.

_langt_deg-cmp_rel := langt_prd & deg-cmp.

omtrent_prd := predsort.
_omtrent_deg-sup_rel := omtrent_prd & deg-sup.
_omtrent_deg-pos_rel := omtrent_prd & deg-pos.
_omtrent_deg-adv_rel := omtrent_prd & deg-adv.
_omtrent_deg-num_rel := omtrent_prd & deg-num.
_omtrent_deg-qnt_rel := omtrent_prd & deg-qnt.

nesten_prd := predsort.
_nesten_deg-pos_rel := nesten_prd & deg-pos.
_nesten_deg-cmp_rel := nesten_prd & deg-cmp.
_nesten_deg-sup_rel := nesten_prd & deg-sup.
_nesten_deg-adv_rel := nesten_prd & deg-adv.
_nesten_deg-num_rel := nesten_prd & deg-num.
_nesten_deg-qnt_rel := nesten_prd & deg-qnt.

bl-a_prd := predsort.
_bl-a_deg-nom_rel := bl-a_prd & deg-nom.
_bl-a_deg-adv_rel := bl-a_prd & deg-adv.
_bl-a_deg-pos_rel := bl-a_prd & deg-pos.
_bl-a_deg-cmp_rel := bl-a_prd & deg-cmp.
_bl-a_deg-sup_rel := bl-a_prd & deg-sup.

_bare_deg-verb_rel := bare_prd & deg-verb.
_bare_deg-imp_rel := bare_prd & deg-imp.

mer*enn_prd := predsort.
_mer*enn_deg-verb_rel := mer*enn_prd & deg-verb.

alt*i*alt_prd := predsort.
_alt*i*alt_deg-adv_rel := alt*i*alt_prd & deg-adv.
_alt*i*alt_deg-cmp_rel := alt*i*alt_prd & deg-cmp.
_alt*i*alt_deg-pos_rel := alt*i*alt_prd & deg-pos.
_alt*i*alt_deg-sup_rel := alt*i*alt_prd & deg-sup.

ca_prd := predsort.
_ca_deg-adv_rel := ca_prd & deg-adv.
_ca_deg-num_rel := ca_prd & deg-num.
_ca_deg-qnt_rel := ca_prd & deg-qnt.

halv_prd := predsort.
_halv_deg-num_rel := halv_prd & deg-num.

maksimum_prd := predsort.
_maksimum_deg-num_rel := maksimum_prd & deg-num.

minimum_prd := predsort.
_minimum_deg-num_rel := minimum_prd & deg-num.

_kanskje_deg-verb_rel := kanskje_prd & deg-verb.
_kanskje_adv_rel := kanskje_prp & adv-link.
_kanskje_deg-adv_rel := kanskje_prd & deg-adv.
_kanskje_deg-cmp_rel := kanskje_prd & deg-cmp.
_kanskje_deg-pos_rel := kanskje_prd & deg-pos.
_kanskje_deg-sup_rel := kanskje_prd & deg-sup.

_mye_deg-adv_rel := mye_prd & deg-adv.
_mye_deg-cmp_rel := mye_prd & deg-cmp.

svært*mye_prd := predsort.
_svært*mye_deg-cmp_rel := svært*mye_prd & deg-cmp.

_rundt_deg-num_rel := rundt_prd & deg-num.

nummer_prd := predsort.
_nummer_deg-num_rel := nummer_prd & deg-num.

senest_prd := predsort.
_senest_deg-adv_rel := senest_prd & deg-adv.

sist_prd := predsort.
_sist_deg-adv_rel := sist_prd & deg-adv.

super_conj := predsort.
mwe_conj := link & super_conj.
både_prd := mwe_conj.
enten_prd := mwe_conj.
verken_prd := mwe_conj.
og_prd := super_conj.
men_prd := super_conj.
eller_prd := super_conj.

_både*og_c_rel := både_prd & og_prd.
_enten*eller_c_rel := enten_prd & eller_prd.
_verken*eller_c_rel := verken_prd & eller_prd.

reg_conj := norm_rel.
_og_c_rel := og_prd & reg_conj.
_men_c_rel := men_prd & reg_conj.
_eller_c_rel := eller_prd & reg_conj.

cont_conj := init_rel.
_og_cont_rel := og_prd & init_rel.
_men_cont_rel := men_prd & init_rel.


ja_prd := predsort.
_ja_ij_rel := init_rel & ja_prd.

vocative_rel := init_rel.


dit_prd := predsort.
dit_prp := dit_prd & prp+.
_dit_adv_rel := dit_prp & adv-link.

flokk_n := flokk_prd & idiomform.
flokk_prd := predsort.
_flokk_meas_rel := flokk_prd & arg1- & arg2- & arg3- & arg4- & prt- & meas+.
_flokk_n_rel := flokk_prd & arg1- & arg2- & arg3- & arg4- & prt- & atom.


_godt_deg-adv_rel := godt_prd & deg-adv.
_godt_deg-pos_rel := godt_prd & deg-pos.

noensteds_prd := predsort.
noensteds_prp := noensteds_prd & prp+.
_noensteds_adv_rel := noensteds_prp & adv-link.


overhodet_prd := predsort.
overhodet_prp := overhodet_prd & prp+.
_overhodet_adv_rel := overhodet_prp & adv-link.
_overhodet_deg-sadv_rel := overhodet_prd & deg-sadv.

_gjøre_124-ap_rel := gjøre_v & vbl+ & 1np & 2np & arg3- & 4ap & prp- & prt-.
gjøre_v := vrb+.
_gjøre-ferdig_12_rel := gjøre_v & vbl+ & 1np & 2np & arg3- & arg4- & ferdig_prt.
_gjøre-klar_12_rel := gjøre_v & vbl+ & 1np & 2np & arg3- & arg4- & klar_prt.

; Hunden kommer til å bjeffe
komme_v := vrb+.
_komme*til-ip1_14_rel := komme_v & vbl+ & 1np & arg2- & arg3- & 4ip1 & til_prp & prt-.

plage_v := vrb+.
_plage-cp_23_rel := plage_v & vbl+ & arg1- & 2cp & 3np & arg4- & prt-.
_plage_12_rel := plage_v & vbl+ & 1np & 2np & arg3- & arg4- & prt-.
_plage_a_rel := plage_v & adj+ & 1np & 2np & arg3- & arg4- & prt-.

overlate_v := vrb+.
_overlate*til-ip4_124_rel := overlate_v & vbl+ & 1np & 2ip4 & arg3- & 4np & til_prp & prt-.

ide_prd := predsort.
_ide-cp_rel := ide_prd & arg1- & 2cp & arg3- & arg4- & prt- & atom.
_ide_n_rel := ide_prd & arg1- & arg2- & arg3- & arg4- & prt- & atom.

tidt*og*ofte_prd := predsort.
tidt*og*ofte_prp := tidt*og*ofte_prd & prp+.
_tidt*og*ofte_adv_rel := tidt*og*ofte_prp & adv-link.

; Rule for direct object in second conjunct should be unary rule